C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 1   


C251 COMPILER V5.57.0, COMPILATION OF MODULE MMI_Reconnect
OBJECT MODULE PLACED IN .\output\AB1520D_AiroStereoHeadset\MMI_Reconnect.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE source\MMI\MMI_Reconnect.c XSMALL HPTR FUNCTIONS(REENTRANT) ROM(HUGE) 
                    -WARNINGLEVEL(3) OPTIMIZE(9,SPEED) BROWSE ORDER INCDIR(.\source\COMMON;.\source\SECTOR;.\source\ABSDRIVER;.\source\OS;.\s
                    -ource\HC;.\source\LM;.\source\LC;.\source\ROM;.\source\ROM\COMMON;.\source\ROM\OS;.\source\ROM\HC;.\source\ROM\LL;.\sour
                    -ce\ROM\LC;.\source\ROM\HAL;.\source\ROM\KERNEL;.\source\ROM\DRIVER;.\source\ROM\L2CAP;.\source\ROM\GAP;.\source\ROM\MMI_
                    -LE;.\source\ROM\SECTOR;.\source\ROM\SECTOR\Config0;.\source\SECTOR\Config0;.\source\SECTOR\Config1;.\source\SECTOR\DspDa
                    -ta;.\source\SECTOR\Runtime;.\source\SECTOR\VoiceData;.\source\SECTOR\SectorBoundary;.\source\SECTOR\ToolMisc) DEFINE(FLA
                    -SH_INIT=1,AB1520D,MIGRATE_ROM_TO_FLASH,DFU_LOADER_IN_BOOT_CODE,TWS_SETTINGS) DEBUG PRINT(.\LST\AB1520D_AiroStereoHeadset
                    -\MMI_Reconnect.lst) TABS(2) OBJECT(.\output\AB1520D_AiroStereoHeadset\MMI_Reconnect.obj) 

stmt  level    source

    1          #include "reside_flash.inc"
    2          
    3          #define _MMI_RECONNECT_C_
    4          
    5          #include "rc.h"
    6          #include "bt_config_profile.h"
    7          #include "os_flash.h"
    8          
    9          #include "MMI.h"
   10          #include "MMI_Base.h"
   11          #include "MMI_Protocol.h"
   12          #include "MMI_Reconnect.h"
   13          #include "MMI_Driver.h"
   14          #include "MMI_State.h"
   15          #include "MMI_HCI.h"
   16          #include "MMI_AirModule.h"
   17          #include "MMI_SDAP.h"
   18          #include "MMI_A2DP.h"
   19          
   20          
   21          
   22          PRIVATE void MMI_LinkKey_RemoveSequenceLinkHistory(LinkHistoryType XDATA_PTR linkListPtr, U8 index, U8 is
             -AirLink);
   23          
   24          PRIVATE void MMI_Reconnect_AddReconnectList(U8 type, U8 XDATA_PTR bdAddrPtr, U8 XDATA_PTR classOfDevPtr)
   25          {
   26   1        U8 index;
   27   1        MMIReonnectDataType XDATA_PTR targetDataPtr;
   28   1        MMIReonnectDataType XDATA_PTR backDataPtr;
   29   1        
   30   1        /* mantis 8255
   31   1        for(index = 0; index < MAX_MULTI_POINT_NO; index++)
   32   1        {
   33   1          if(MMI_IsActiveLink(index) && SYS_IsBDAddrIsTheSame(bdAddrPtr,&gMMI_ctl.mmiInfo[index].bdAddr[0]))
   34   1            return;
   35   1        }*/
   36   1        
   37   1        LightDbgPrint("==AddReconList:%x,%x,%x",(U8)bdAddrPtr[0],(U8)bdAddrPtr[1],(U8)bdAddrPtr[2]);
   38   1      
   39   1        //1. Prepare reconnectList Memory
   40   1        if(gMMI_ctl.reconnectCtl.reconnectListPtr == (MMIReconnectListType XDATA_PTR)NULL)
   41   1        {
   42   2          gMMI_ctl.reconnectCtl.reconnectListPtr = (MMIReconnectListType XDATA_PTR)SYS_MemoryGet(sizeof(MMIReconn
             -ectListType));
   43   2          if(gMMI_ctl.reconnectCtl.reconnectListPtr)
   44   2          {
   45   3            OSMEM_memset_xdata((U8 XDATA_PTR)gMMI_ctl.reconnectCtl.reconnectListPtr, 0, sizeof(MMIReconnectListTyp
             -e));
   46   3            gMMI_ctl.reconnectCtl.reconnectListPtr->currentHighPriorityIndex = 0xFF;
   47   3            gMMI_ctl.reconnectCtl.reconnectListPtr->currentTargetIndex = 0xFF;
   48   3          }
   49   2          else
C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 2   

   50   2          {
   51   3            //Allocate Memory fail, no reconnection!
   52   3            return;
   53   3          }
   54   2        }
   55   1      
   56   1      
   57   1        if(type == RECONNECT_LINK_LOSS || type == RECONNECT_WATCHDOG)
   58   1        {
   59   2          if(type == RECONNECT_LINK_LOSS && gMMI_nvram.timerCtl.reconnectdurationLinkLossTimer)
   60   2          {
   61   3            gMMI_ctl.reconnectCtl.reconnectListPtr->isDurationTimerSet = TRUE;
   62   3            OST_SetTimer(&gMMI_ctl.reconnectCtl.reconnectListPtr->reconnectDurationTimer,gMMI_nvram.timerCtl.recon
             -nectdurationLinkLossTimer* HALF_SEC);
   63   3          }
   64   2          //Find the duplicated data
   65   2          for(index = 0; index < NVRAM_LINK_KEY_ITEMS; index++)
   66   2          {
   67   3            if(SYS_IsBDAddrIsTheSame((U8 XDATA_PTR)bdAddrPtr, &gMMI_ctl.reconnectCtl.reconnectListPtr->reconLinkLo
             -ssWatchDogData[index].bdAddr[0]))
   68   3              break;
   69   3          }
   70   2      
   71   2      
   72   2          //New data! Allocate the new data space
   73   2          if(index == NVRAM_LINK_KEY_ITEMS)
   74   2          {
   75   3            for(index = 0; index < NVRAM_LINK_KEY_ITEMS; index++)
   76   3            {
   77   4              if(gMMI_ctl.reconnectCtl.reconnectListPtr->reconLinkLossWatchDogData[index].reconnectType == RECONNEC
             -T_TYPE_NULL)
   78   4              {
   79   5                break;
   80   5              }
   81   4            }
   82   3          }
   83   2      
   84   2          //No empty space, delete the last one
   85   2          if(index == NVRAM_LINK_KEY_ITEMS)
   86   2            index = (NVRAM_LINK_KEY_ITEMS-1);
   87   2      
   88   2      
   89   2          //2. Set Parameters
   90   2          targetDataPtr = &gMMI_ctl.reconnectCtl.reconnectListPtr->reconLinkLossWatchDogData[index];
   91   2          OSMEM_memcpy_xdata_xdata(&(targetDataPtr->bdAddr[0]), bdAddrPtr, 6);
   92   2          OSMEM_memcpy_xdata_xdata(&(targetDataPtr->classOfDev[0]), classOfDevPtr, 3);
   93   2          targetDataPtr->reconnectType = type;
   94   2          if(type == RECONNECT_LINK_LOSS)
   95   2          {
   96   3            if(MMI_EOF == MMI_LinkKey_SearchAirLinkKeyIndex(bdAddrPtr, FALSE))
   97   3              targetDataPtr->retryCnt = gMMI_nvram.reConnectInfo.linkLossReTryCnt;
   98   3            else
   99   3              targetDataPtr->retryCnt = gMMI_nvram.twsLinkLossRetryCnt;
  100   3          }
  101   2          else
  102   2          {
  103   3            targetDataPtr->retryCnt = gMMI_nvram.reConnectInfo.watchDogReTryCnt;
  104   3          }
  105   2      
  106   2          if(index)
  107   2          {
  108   3            backDataPtr = (MMIReonnectDataType XDATA_PTR)SYS_MemoryGet(sizeof(MMIReonnectDataType));
  109   3            if(backDataPtr)
  110   3            {
  111   4              if(gMMI_ctl.reconnectCtl.reconnectListPtr->currentHighPriorityIndex < index)
  112   4                gMMI_ctl.reconnectCtl.reconnectListPtr->currentHighPriorityIndex++;
C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 3   

  113   4      
  114   4              OSMEM_memcpy_xdata_xdata((U8 XDATA_PTR)backDataPtr, (U8 XDATA_PTR)targetDataPtr, sizeof(MMIReonnectDa
             -taType));
  115   4              for(; index; index--)
  116   4              {
  117   5                OSMEM_memcpy_xdata_xdata((U8 XDATA_PTR)&gMMI_ctl.reconnectCtl.reconnectListPtr->reconLinkLossWatchDo
             -gData[index], (U8 XDATA_PTR)&gMMI_ctl.reconnectCtl.reconnectListPtr->reconLinkLossWatchDogData[index-1], sizeof(MMIReonn
             -ectDataType));
  118   5              }
  119   4              OSMEM_memcpy_xdata_xdata((U8 XDATA_PTR)&gMMI_ctl.reconnectCtl.reconnectListPtr->reconLinkLossWatchDog
             -Data[0], (U8 XDATA_PTR)backDataPtr, sizeof(MMIReonnectDataType));
  120   4              OSMEM_Put((U8 XDATA_PTR) backDataPtr);
  121   4            }
  122   3          }
  123   2        }
  124   1        else
  125   1        {
  126   2          //Find the duplicated data
  127   2          for(index = 0; index < NVRAM_LINK_KEY_ITEMS; index++)
  128   2          {
  129   3            if(SYS_IsBDAddrIsTheSame((U8 XDATA_PTR)bdAddrPtr, &gMMI_ctl.reconnectCtl.reconnectListPtr->reconnectDa
             -ta[index].bdAddr[0]))
  130   3              break;
  131   3          }
  132   2      
  133   2          //New data! Allocate the new data space
  134   2          if(index == NVRAM_LINK_KEY_ITEMS)
  135   2          {
  136   3            for(index = 0; index < NVRAM_LINK_KEY_ITEMS; index++)
  137   3            {
  138   4              if(gMMI_ctl.reconnectCtl.reconnectListPtr->reconnectData[index].reconnectType == RECONNECT_TYPE_NULL)
  139   4              {
  140   5                break;
  141   5              }
  142   4            }
  143   3          }
  144   2      
  145   2          //No empty space, delete the last one
  146   2          if(index == NVRAM_LINK_KEY_ITEMS)
  147   2            index = (NVRAM_LINK_KEY_ITEMS-1);
  148   2      
  149   2          //2. Set Parameters
  150   2          targetDataPtr = &gMMI_ctl.reconnectCtl.reconnectListPtr->reconnectData[index];
  151   2          OSMEM_memcpy_xdata_xdata(&(targetDataPtr->bdAddr[0]), bdAddrPtr, 6);
  152   2          OSMEM_memcpy_xdata_xdata(&(targetDataPtr->classOfDev[0]), classOfDevPtr, 3);
  153   2          targetDataPtr->reconnectType = type;
  154   2          targetDataPtr->retryCnt = gMMI_nvram.reConnectInfo.autoRecTryCnt;
  155   2      
  156   2        }
  157   1      }
  158          
  159          PRIVATE void MMI_Reconnect_AddListByLinkKeyIndex(U8 type, U8 index)
  160          {
  161   1        if(gMMI_driver_variation_nvram.link_history_info[index].key_status == NVRAM_KEY_OK)
  162   1        {
  163   2          MMI_Reconnect_AddReconnectList( type, 
  164   2                          (U8 XDATA_PTR)&gMMI_driver_variation_nvram.link_history_info[index].linkData.bdAddr[0],
  165   2                          (U8 XDATA_PTR)&gMMI_driver_variation_nvram.link_history_info[index].classOfDev[0]);
  166   2        }
  167   1      }
  168          
  169          PRIVATE void MMI_Reconnect_AddListByAirLinkKeyIndex(U8 type, U8 index)
  170          {
  171   1        LightDbgPrint("==AddListByAirLink:%d",(U8)index, (U8)gMMI_driver_variation_nvram.air_link_history_info[i
             -ndex].key_status);
  172   1        if(gMMI_driver_variation_nvram.air_link_history_info[index].key_status == NVRAM_KEY_OK)
C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 4   

  173   1        {
  174   2          MMI_Reconnect_AddReconnectList( type, 
  175   2                          (U8 XDATA_PTR)&gMMI_driver_variation_nvram.air_link_history_info[index].linkData.bdAddr[0],
  176   2                          (U8 XDATA_PTR)&gMMI_driver_variation_nvram.air_link_history_info[index].classOfDev[0]);
  177   2        }
  178   1      }
  179          
  180          PRIVATE void MMI_Reconnect_AddListByFastDongle(U8 type)
  181          {
  182   1        if(gMMI_driver_variation_nvram.fast_dongle_link_history_info.key_status == NVRAM_KEY_OK)
  183   1        {
  184   2          MMI_Reconnect_AddReconnectList( type, 
  185   2                          (U8 XDATA_PTR)&gMMI_driver_variation_nvram.fast_dongle_link_history_info.linkData.bdAddr[0],
  186   2                          (U8 XDATA_PTR)&gMMI_driver_variation_nvram.fast_dongle_link_history_info.classOfDev[0]);
  187   2        }
  188   1      }
  189          
  190          PRIVATE void MMI_Reconnect_AddListByBdAddr(U8 type, U8 XDATA_PTR bdAddr)
  191          {
  192   1        LinkHistoryType XDATA_PTR linkListPtr = MMI_LinkKey_SearchHistoryByBdAddr(bdAddr, TRUE, FALSE);
  193   1        
  194   1        if(linkListPtr)
  195   1        {
  196   2          MMI_Reconnect_AddReconnectList(type, bdAddr, &linkListPtr->classOfDev[0]);
  197   2        }
  198   1      }
  199          
  200          PUBLIC void MMI_Reconnect_AddListByMode(U8 type, U8 reconnectMode)
  201          {
  202   1        U8 i;
  203   1        switch(reconnectMode)
  204   1        {
  205   2          case RECONNECT_FAST_DONGLE:
  206   2            MMI_Reconnect_AddListByFastDongle(type);  
  207   2            break;
  208   2          case RECONNECT_TWS:
  209   2            MMI_Reconnect_AddListByAirLinkKeyIndex(type, 0);
  210   2            break;
  211   2          case RECONNECT_LAST_TWO:
  212   2            MMI_Reconnect_AddListByLinkKeyIndex(type, 0);
  213   2            MMI_Reconnect_AddListByLinkKeyIndex(type, 1);
  214   2            break;
  215   2          case RECONNECT_LAST_ONE:
  216   2            MMI_Reconnect_AddListByLinkKeyIndex(type, 0);
  217   2            break;
  218   2          case RECONNECT_AG_IND_0:
  219   2            MMI_Reconnect_AddListByBdAddr(type, &gMMI_driver_variation_nvram.misc_para.agInd[0].member[0]);
  220   2            break;
  221   2          case RECONNECT_AG_IND_0_1:
  222   2            MMI_Reconnect_AddListByBdAddr(type, &gMMI_driver_variation_nvram.misc_para.agInd[0].member[0]);
  223   2          case RECONNECT_AG_IND_1:
  224   2            if(!SYS_IsBDAddrIsTheSame(&gMMI_driver_variation_nvram.misc_para.agInd[0].member[0],&gMMI_driver_varia
             -tion_nvram.misc_para.agInd[1].member[0]))
  225   2              MMI_Reconnect_AddListByBdAddr(type, &gMMI_driver_variation_nvram.misc_para.agInd[1].member[0]);
  226   2            break;
  227   2      
  228   2          case RECONNECT_LAST_DISC:
  229   2            for(i = 0;  i < MAX_MULTI_POINT_NO; i++)
  230   2            {
  231   3              if(MAX_MULTI_POINT_NO == MMI_GetLinkIndexByBdA(&gMMI_driver_variation_nvram.misc_para.agInd[i].member
             -[0]))
  232   3              {
  233   4                MMI_Reconnect_AddListByBdAddr(type, &gMMI_driver_variation_nvram.misc_para.agInd[i].member[0]);
  234   4                break;
  235   4              }
  236   3            }
C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 5   

  237   2            break;
  238   2      
  239   2          case RECONNECT_LIST:
  240   2            for(i = 0;  i < NVRAM_AIR_LINK_KEY_NO; i++)
  241   2              MMI_Reconnect_AddListByAirLinkKeyIndex(type, i);
  242   2              
  243   2            for(i = 0;  i < gMMI_nvram.storedLinkKeyCnt; i++)
  244   2              MMI_Reconnect_AddListByLinkKeyIndex(type, i);
  245   2            break;
  246   2            
  247   2          case RECONNECT_ALL_DROPPED_LINKS:
  248   2            for(i = 0; i < NVRAM_AIR_LINK_KEY_NO; i++)
  249   2            {
  250   3              if((gMMI_driver_variation_nvram.air_link_history_info[i].miscMask & NVRAM_LINK_KEY_MISC_MASK_CONNECTE
             -D) &&
  251   3                MAX_MULTI_POINT_NO == MMI_GetLinkIndexByBdA(&gMMI_driver_variation_nvram.air_link_history_info[i].li
             -nkData.bdAddr[0]))
  252   3              {
  253   4                MMI_Reconnect_AddListByAirLinkKeyIndex(type, i);
  254   4              }
  255   3            } 
  256   2            for(i = 0; i < gMMI_nvram.storedLinkKeyCnt; i++)
  257   2            {
  258   3              if((gMMI_driver_variation_nvram.link_history_info[i].miscMask & NVRAM_LINK_KEY_MISC_MASK_CONNECTED) &
             -&
  259   3                MAX_MULTI_POINT_NO == MMI_GetLinkIndexByBdA(&gMMI_driver_variation_nvram.link_history_info[i].linkDa
             -ta.bdAddr[0]))
  260   3              {
  261   4                MMI_Reconnect_AddListByLinkKeyIndex(type, i);
  262   4              }
  263   3            }
  264   2            break;
  265   2          
  266   2          case RECONNECT_TWS_0101:
  267   2          case RECONNECT_TWS_0011:
  268   2            if(type == RECONNECT_LINK_LOSS)
  269   2            {
  270   3              MMI_Reconnect_AddListByAirLinkKeyIndex(type, 1);
  271   3              MMI_Reconnect_AddListByAirLinkKeyIndex(type, 0);        
  272   3            }
  273   2            else
  274   2            {
  275   3              MMI_Reconnect_AddListByAirLinkKeyIndex(type, 0);
  276   3              MMI_Reconnect_AddListByAirLinkKeyIndex(type, 1);        
  277   3            }
  278   2            break;
  279   2      
  280   2          default:
  281   2            break;
  282   2        }
  283   1      }
  284          
  285          PUBLIC BOOL MMI_Reconnect_SearchList(U8 dataCnt, U8 XDATA_PTR currentIndexPtr)
  286          {
  287   1        if(dataCnt)
  288   1        {
  289   2          if(*currentIndexPtr == 0xFF)
  290   2          {
  291   3            *currentIndexPtr = 0;
  292   3          }
  293   2          else if(*currentIndexPtr == (dataCnt-1))
  294   2          {
  295   3            *currentIndexPtr = 0xFF;
  296   3            return FALSE;
  297   3          }
  298   2          else
C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 6   

  299   2          {
  300   3            (*currentIndexPtr)++;
  301   3          }
  302   2      
  303   2          return TRUE;
  304   2        }
  305   1        return FALSE;
  306   1      }
  307          
  308          PUBLIC U8 MMI_Reconnect_GetListCnt(U8 isNormalData)
  309          {
  310   1        U8 index;
  311   1        U8 cnt = 0;
  312   1        
  313   1        if(!gMMI_ctl.reconnectCtl.reconnectListPtr)
  314   1          return 0;
  315   1      
  316   1        for(index = 0; index < NVRAM_LINK_KEY_ITEMS; index++)
  317   1        {
  318   2          if(isNormalData)
  319   2          {
  320   3            if(gMMI_ctl.reconnectCtl.reconnectListPtr->reconnectData[index].reconnectType != RECONNECT_TYPE_NULL)
  321   3            {
  322   4              cnt++;
  323   4            }
  324   3          }
  325   2          else
  326   2          {
  327   3            if(gMMI_ctl.reconnectCtl.reconnectListPtr->reconLinkLossWatchDogData[index].reconnectType != RECONNECT
             -_TYPE_NULL)
  328   3            {
  329   4              cnt++;
  330   4            }
  331   3          }
  332   2        }
  333   1        return cnt;
  334   1      }
  335          
  336          PUBLIC void MMI_Reconnect_DeleteListByBdAddr(U8 XDATA_PTR bdAddrPtr)
  337          {
  338   1        U8 isNormalData = TRUE;
  339   1        MMIReonnectDataType XDATA_PTR dataPtr;
  340   1        MMIReonnectDataType XDATA_PTR backUpPtr;
  341   1        U8 index, i;
  342   1        U8 XDATA_PTR currentIndexPtr;
  343   1      
  344   1      
  345   1        if(gMMI_ctl.reconnectCtl.reconnectListPtr == (MMIReconnectListType XDATA_PTR)NULL)
  346   1          return;
  347   1      
  348   1        DeleteInvalidReconnectData:
  349   1        index = NVRAM_LINK_KEY_ITEMS;
  350   1        if(isNormalData)
  351   1          currentIndexPtr = &gMMI_ctl.reconnectCtl.reconnectListPtr->currentTargetIndex;
  352   1        else
  353   1          currentIndexPtr = &gMMI_ctl.reconnectCtl.reconnectListPtr->currentHighPriorityIndex;
  354   1      
  355   1        while(index--)
  356   1        {
  357   2          if(isNormalData)
  358   2            dataPtr = &gMMI_ctl.reconnectCtl.reconnectListPtr->reconnectData[index];
  359   2          else
  360   2            dataPtr = &gMMI_ctl.reconnectCtl.reconnectListPtr->reconLinkLossWatchDogData[index];
  361   2      
  362   2          if(dataPtr->reconnectType != RECONNECT_TYPE_NULL)
  363   2          {
C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 7   

  364   3            if(SYS_IsBDAddrIsTheSame(&dataPtr->bdAddr[0], bdAddrPtr))
  365   3            {
  366   4              goto DELETE_RECONNECT_DATA;
  367   4            }
  368   3      
  369   3            if(dataPtr->retryCnt)
  370   3            {
  371   4              continue;
  372   4            }
  373   3            DELETE_RECONNECT_DATA:
  374   3            dataPtr->reconnectType = RECONNECT_TYPE_NULL;
  375   3            OSMEM_memset_xdata((U8 XDATA_PTR)dataPtr, 0, sizeof(MMIReonnectDataType));
  376   3            if(index <= *currentIndexPtr)
  377   3            {
  378   4              if(index)
  379   4                *currentIndexPtr = *currentIndexPtr-1;
  380   4              else
  381   4                *currentIndexPtr = 0xFF;
  382   4            }
  383   3          }
  384   2        }
  385   1      
  386   1        for(index = 0; index < NVRAM_LINK_KEY_ITEMS ; index++)
  387   1        {
  388   2          if(isNormalData)
  389   2            dataPtr = &gMMI_ctl.reconnectCtl.reconnectListPtr->reconnectData[index];
  390   2          else
  391   2            dataPtr = &gMMI_ctl.reconnectCtl.reconnectListPtr->reconLinkLossWatchDogData[index];
  392   2      
  393   2          if(dataPtr->reconnectType == RECONNECT_TYPE_NULL)
  394   2          {
  395   3            for(i = index+1; i < NVRAM_LINK_KEY_ITEMS; i++)
  396   3            {
  397   4              if(isNormalData)
  398   4                backUpPtr = &gMMI_ctl.reconnectCtl.reconnectListPtr->reconnectData[i];
  399   4              else
  400   4                backUpPtr = &gMMI_ctl.reconnectCtl.reconnectListPtr->reconLinkLossWatchDogData[i];
  401   4      
  402   4              if(backUpPtr->reconnectType != RECONNECT_TYPE_NULL)
  403   4              {
  404   5                OSMEM_memcpy_xdata_xdata((U8 XDATA_PTR)dataPtr, (U8 XDATA_PTR)backUpPtr, sizeof(MMIReonnectDataType)
             -);
  405   5                backUpPtr->reconnectType = RECONNECT_TYPE_NULL;
  406   5                break;
  407   5              }
  408   4            }
  409   3          }
  410   2        }
  411   1      
  412   1        if(isNormalData)
  413   1        {
  414   2          isNormalData= FALSE;
  415   2          goto DeleteInvalidReconnectData;
  416   2        }
  417   1      }
  418          
  419          PUBLIC void MMI_Reconnect_DeleteInvalidList(void)
  420          {
  421   1        U8 linkIndex;
  422   1      
  423   1        for(linkIndex = 0; linkIndex < MAX_MULTI_POINT_NO; linkIndex++)
  424   1        {
  425   2          if(MMI_IsActiveLink(linkIndex))
  426   2          {
  427   3            MMI_Reconnect_DeleteListByBdAddr(&gMMI_ctl.mmiInfo[linkIndex].bdAddr[0]);
  428   3      
C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 8   

  429   3            #ifdef AIR_MODULE
  430   3            MMI_AIR_Reconnect_DeleteInvalidList(linkIndex);
  431   3            #endif
  432   3          }
  433   2        }
  434   1      }
  435          
  436          PRIVATE MMIReonnectDataType XDATA_PTR MMI_Reconnect_GetTarget(void)
  437          {
  438   1        MMIReonnectDataType XDATA_PTR reconectTargetPtr;
  439   1        reconectTargetPtr= (MMIReonnectDataType XDATA_PTR)NULL;
  440   1      
  441   1        if(MMI_Reconnect_SearchList(MMI_Reconnect_GetListCnt(LIST_HIGH_PRI_DATA), &gMMI_ctl.reconnectCtl.reconne
             -ctListPtr->currentHighPriorityIndex))
  442   1          reconectTargetPtr = &gMMI_ctl.reconnectCtl.reconnectListPtr->reconLinkLossWatchDogData[gMMI_ctl.reconne
             -ctCtl.reconnectListPtr->currentHighPriorityIndex];
  443   1        else if(MMI_Reconnect_SearchList(MMI_Reconnect_GetListCnt(LIST_NORMAL_DATA), &gMMI_ctl.reconnectCtl.reco
             -nnectListPtr->currentTargetIndex))
  444   1          reconectTargetPtr = &gMMI_ctl.reconnectCtl.reconnectListPtr->reconnectData[gMMI_ctl.reconnectCtl.reconn
             -ectListPtr->currentTargetIndex];
  445   1        else if(MMI_Reconnect_SearchList(MMI_Reconnect_GetListCnt(LIST_HIGH_PRI_DATA), &gMMI_ctl.reconnectCtl.re
             -connectListPtr->currentHighPriorityIndex))
  446   1          reconectTargetPtr = &gMMI_ctl.reconnectCtl.reconnectListPtr->reconLinkLossWatchDogData[gMMI_ctl.reconne
             -ctCtl.reconnectListPtr->currentHighPriorityIndex];
  447   1        else if(MMI_Reconnect_SearchList(MMI_Reconnect_GetListCnt(LIST_NORMAL_DATA), &gMMI_ctl.reconnectCtl.reco
             -nnectListPtr->currentTargetIndex))
  448   1          reconectTargetPtr = &gMMI_ctl.reconnectCtl.reconnectListPtr->reconnectData[gMMI_ctl.reconnectCtl.reconn
             -ectListPtr->currentTargetIndex];
  449   1        
  450   1        return reconectTargetPtr;
  451   1      }
  452          
  453          PRIVATE BOOL MMI_Reconnect_Start(U8 type)
  454          {
  455   1        U8 linkIndex;
  456   1        MMIReonnectDataType XDATA_PTR reconectTargetPtr;
  457   1        
  458   1        FIND_AGAIN:
  459   1      
  460   1        if( gMMI_ctl.reconnectCtl.reconnectListPtr == (MMIReconnectListType XDATA_PTR)NULL || MMI_KEY_STATE_POWE
             -R_OFF == MMI_GetKeyState()
  461   1          ||(0 == MMI_Reconnect_GetListCnt(LIST_NORMAL_DATA) && 0 == MMI_Reconnect_GetListCnt(LIST_HIGH_PRI_DATA)
             -))
  462   1        {
  463   2          goto STOP_RECONNECT;
  464   2        }
  465   1        
  466   1        #ifdef AIR_MODULE
  467   1        if((reconectTargetPtr = (MMIReonnectDataType XDATA_PTR)MMI_AIR_Reconnect_GetTarget(type)) != (MMIReonnec
             -tDataType XDATA_PTR)NULL)
  468   1        {
  469   2          goto CHECK_RECONNECT_TARGET_LINK;
  470   2        }
  471   1        #endif
  472   1      
  473   1        if((reconectTargetPtr = MMI_Reconnect_GetTarget()) == (MMIReonnectDataType XDATA_PTR)NULL)
  474   1        {
  475   2          STOP_RECONNECT:
  476   2          MMI_Reconnect_ClearCtl();
  477   2      
  478   2          if(MMI_DISCOVER_AFTER_POWERON_RECONNECT_FAIL_FEAT && type == RECONNECT_PWR_ON)
  479   2          {
  480   3            MMI_SetEnterDiscoverable(TRUE);
  481   3          }
  482   2          return FALSE;
  483   2        }
C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 9   

  484   1        
  485   1        #ifdef AIR_MODULE
  486   1        CHECK_RECONNECT_TARGET_LINK:
  487   1        #endif
  488   1        for(linkIndex = 0; linkIndex < MAX_MULTI_POINT_NO; linkIndex++)
  489   1        {
  490   2          if(MMI_IsActiveLink(linkIndex) && SYS_IsBDAddrIsTheSame(&reconectTargetPtr->bdAddr[0], &gMMI_ctl.mmiInf
             -o[linkIndex].bdAddr[0]))
  491   2          {
  492   3            if(gMMI_ctl.mmiInfo[linkIndex].linkPara.miscMask & MMI_LINK_DETACHING)
  493   3            {
  494   4              if(type == RECONNECT_USER_INIT)
  495   4                SYS_SetTimer(&gMMI_ctl.mmiTimerInfo.sysTimer.userReconnectKeyEventTimer,ONE_SEC);
  496   4            }
  497   3            else if (MMI_IsActiveLink(linkIndex) && !MMI_GetConnectedProfileCount(linkIndex, TRUE) && MMI_SDAP_IsQ
             -ueryComplete(linkIndex))
  498   3            {
  499   4              gMMI_ctl.mmiInfo[linkIndex].linkPara.miscMask &= ~MMI_DISC_ACTIVE;
  500   4              MMI_PrepareActiveProfileConnection(linkIndex);
  501   4            }
  502   3            MMI_Reconnect_DeleteInvalidList();
  503   3            
  504   3            if((reconectTargetPtr = MMI_Reconnect_GetTarget()) == (MMIReonnectDataType XDATA_PTR)NULL)
  505   3              goto STOP_RECONNECT;
  506   3          }
  507   2        }
  508   1        
  509   1        if(MMI_IsUnderPage())
  510   1          return FALSE;
  511   1        
  512   1        linkIndex = MMI_GetEmptyLinkIndex(&reconectTargetPtr->bdAddr[0], TRUE);
  513   1        if(linkIndex >= MAX_MULTI_POINT_NO)
  514   1        {
  515   2          if(linkIndex == MMI_GET_EMPTY_LINK_SAME_BD_ADDR)
  516   2          {
  517   3            MMI_Reconnect_DeleteInvalidList();
  518   3            MMI_Reconnect_SetDelayTimer(HALF_SEC);
  519   3            return FALSE;
  520   3          }
  521   2          else
  522   2            goto STOP_RECONNECT;
  523   2        }
  524   1      
  525   1        if(reconectTargetPtr->retryCnt)
  526   1        {
  527   2          //#ifdef DBG_UART_ENABLE_MMI
  528   2          LightDbgPrint("USR - Reconnect:%d, %d",(U8)gMMI_ctl.reconnectCtl.reconnectListPtr->currentHighPriorityI
             -ndex, (U8)gMMI_ctl.reconnectCtl.reconnectListPtr->currentTargetIndex);
  529   2          //#endif
  530   2          MMI_HCI_SendCreateConnection( linkIndex,
  531   2                          (U8 XDATA_PTR)&reconectTargetPtr->bdAddr[0], 
  532   2                          type,
  533   2                          (U8 XDATA_PTR)&reconectTargetPtr->classOfDev[0]);
  534   2          
  535   2          if(reconectTargetPtr->retryCnt != 0xFF)
  536   2            reconectTargetPtr->retryCnt--;
  537   2      
  538   2          return TRUE;
  539   2        }
  540   1      
  541   1        MMI_Reconnect_DeleteListByBdAddr((U8 XDATA_PTR)&reconectTargetPtr->bdAddr[0]);
  542   1        goto FIND_AGAIN;
  543   1      }
  544          
  545          PUBLIC BOOL MMI_Reconnect_ToUARTIndex(U8 index)
  546          {
C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 10  

  547   1        if(index >= gMMI_nvram.storedLinkKeyCnt)
  548   1        {
  549   2          index -= gMMI_nvram.storedLinkKeyCnt;
  550   2          
  551   2          if(index < NVRAM_AIR_LINK_KEY_NO)
  552   2          {
  553   3            if(MAX_MULTI_POINT_NO == MMI_GetLinkIndexByBdA(&gMMI_driver_variation_nvram.air_link_history_info[inde
             -x].linkData.bdAddr[0]))
  554   3              MMI_Reconnect_AddListByAirLinkKeyIndex(RECONNECT_USER_INIT, index);
  555   3            else
  556   3              return FALSE;
  557   3          }
  558   2          else
  559   2          {
  560   3            MMI_Reconnect_AddListByFastDongle(RECONNECT_USER_INIT);
  561   3          }
  562   2        }
  563   1        else
  564   1        {
  565   2          if(MAX_MULTI_POINT_NO == MMI_GetLinkIndexByBdA(&gMMI_driver_variation_nvram.link_history_info[index].li
             -nkData.bdAddr[0]))
  566   2          {
  567   3            MMI_Reconnect_AddListByLinkKeyIndex(RECONNECT_USER_INIT, index);
  568   3          }
  569   2          else
  570   2          {
  571   3            return FALSE;
  572   3          }
  573   2        }
  574   1      
  575   1        if(MMI_Reconnect_Start(RECONNECT_USER_INIT))
  576   1        {
  577   2          return TRUE;
  578   2        }
  579   1        return FALSE;
  580   1      }
  581          
  582          PUBLIC void MMI_Reconnect_ClearCtl(void)
  583          {
  584   1        SYS_MemoryRelease(U8_XDATA_PTR_PTR_CASTING &gMMI_ctl.reconnectCtl.reconnectListPtr);
  585   1      }
  586          
  587          PUBLIC void MMI_Reconnect_SetDelayTimer(U32 timeValue)
  588          {
  589   1        if(gMMI_ctl.reconnectCtl.reconnectListPtr)
  590   1        {
  591   2          gMMI_ctl.reconnectCtl.reconnectListPtr->isDelayTimerSet = TRUE;
  592   2          OST_SetTimer(&gMMI_ctl.reconnectCtl.reconnectListPtr->reConnectDelayTimer, timeValue);
  593   2        }
  594   1      }
  595          
  596          PUBLIC void MMI_Reconnect_CheckTimer(void)
  597          {
  598   1        if(gMMI_ctl.reconnectCtl.reconnectListPtr)
  599   1        {
  600   2          if(gMMI_ctl.reconnectCtl.reconnectListPtr->isDurationTimerSet && OST_TimerExpired(&gMMI_ctl.reconnectCt
             -l.reconnectListPtr->reconnectDurationTimer))
  601   2          {
  602   3            gMMI_ctl.reconnectCtl.reconnectListPtr->isDurationTimerSet = FALSE;
  603   3            MMI_Reconnect_ClearCtl();
  604   3          }
  605   2          if(gMMI_ctl.reconnectCtl.reconnectListPtr->isDelayTimerSet && OST_TimerExpired(&gMMI_ctl.reconnectCtl.r
             -econnectListPtr->reConnectDelayTimer))
  606   2          {
  607   3            gMMI_ctl.reconnectCtl.reconnectListPtr->isDelayTimerSet = FALSE;
  608   3            MMI_Reconnect(RECONNECT_CHECK);
C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 11  

  609   3          }
  610   2        }
  611   1      }
  612          
  613          PUBLIC void MMI_Reconnect(U8 type)
  614          {
  615   1          // there are 3 stages, add reconnect data, check if reconnected is needed, reconnect
  616   1        
  617   1        U8 settings;
  618   1        #if defined AIR_MODULE && defined PRODUCT_TYPE_K
                 MMIReonnectDataType XDATA_PTR reconectTargetPtr;
                 #endif
  621   1      
  622   1        // Check return condition 
  623   1        #ifdef SUPPORT_1TO2AG_SOUNDBAR
                   if (CURRENT_ACTIVE_LINK_CNT >= 2
                 #else
  626   1          if(CURRENT_ACTIVE_LINK_CNT >= gMMI_ctl.currentSupportDeviceNo  
  627   1        #endif
  628   1          || MMI_KEY_STATE_POWER_OFF == MMI_GetKeyState()
  629   1          || (!MMI_LinkKey_GetPDLNumber() && gMMI_driver_variation_nvram.fast_dongle_link_history_info.key_status
             - != NVRAM_KEY_OK))
  630   1         {
  631   2          MMI_Reconnect_ClearCtl();
  632   2          return;
  633   2         }
  634   1      
  635   1        if(type > RECONNECT_TYPE_NULL && type < RECONNECT_LINK_LOSS)
  636   1        {
  637   2          if(gMMI_ctl.reconnectCtl.reconnectListPtr  && gMMI_ctl.reconnectCtl.reconnectListPtr->currentTargetInde
             -x != 0xFF)
  638   2          {
  639   3            if(MMI_STOP_CURRENT_RECONNECT_BY_NEW_RECONNECT_EVT_FEAT)
  640   3            {
  641   4              OSMEM_memset_xdata((U8 XDATA_PTR)&gMMI_ctl.reconnectCtl.reconnectListPtr->reconnectData[0], 0, (sizeo
             -f(MMIReonnectDataType)*NVRAM_LINK_KEY_ITEMS));
  642   4              gMMI_ctl.reconnectCtl.reconnectListPtr->currentTargetIndex = 0xFF;
  643   4            }
  644   3            else
  645   3              return;
  646   3          }
  647   2        }
  648   1      
  649   1        //add reconnect data
  650   1        switch(type)
  651   1        {
  652   2          case RECONNECT_PWR_ON:
  653   2            settings = gMMI_nvram.reConnectInfo.afterPowerOn; 
  654   2            goto KEY_RECONNECT;
  655   2          case RECONNECT_USER_INIT:
  656   2            settings = gMMI_nvram.reConnectInfo.userInitiated;
  657   2            
  658   2            KEY_RECONNECT:
  659   2            if(0 == MMI_LinkKey_GetPDLNumber())
  660   2              MMI_Reconnect_AddListByMode(type, RECONNECT_FAST_DONGLE);
  661   2            
  662   2            #ifdef AIR_MODULE
  663   2            MMI_AIR_ReconnectUserInit(type, settings);
  664   2            #endif
  665   2            MMI_Reconnect_AddListByMode(type, settings);
  666   2            break;
  667   2      
  668   2          case RECONNECT_LAST_ONCE_AUDIOTRANSFER:
  669   2          case RECONNECT_LAST_ONCE_REDIAL:
  670   2          case RECONNECT_LAST_ONCE_VOICE_DIAL:
  671   2            MMI_Reconnect_AddListByMode(type, RECONNECT_LAST_DISC);
C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 12  

  672   2            break;
  673   2      
  674   2          case RECONNECT_FIRST_ONCE:
  675   2          case RECONNECT_FIRST_ONCE_REDIAL:
  676   2          case RECONNECT_FIRST_ONCE_VOICE_DIAL:
  677   2            MMI_Reconnect_AddListByMode(type, RECONNECT_AG_IND_0);
  678   2            break;
  679   2      
  680   2          case RECONNECT_SECONDARY_ONCE:
  681   2          case RECONNECT_SECONDARY_ONCE_REDIAL:
  682   2          case RECONNECT_SECONDARY_ONCE_VOICE_DIAL:
  683   2            MMI_Reconnect_AddListByMode(type, RECONNECT_AG_IND_1);
  684   2            break;
  685   2      
  686   2          case RECONNECT_LINK_LOSS:
  687   2            //#ifdef DBG_UART_ENABLE_MMI
  688   2            LightDbgPrint("MMI-ReConn_After OOR:%d,%d",(U8)gMMI_nvram.reConnectInfo.afterLinkLoss, (U8)gMMI_nvram.
             -reConnectInfo.linkLossReTryCnt);
  689   2            //#endif
  690   2            if( gMMI_nvram.reConnectInfo.afterLinkLoss == RECONNECT_UNNECESSARY)
  691   2            {
  692   3              OSMEM_memset_xdata((U8 XDATA_PTR)&gMMI_ctl.reconnectCtl.linkLossBdAddr, 0, sizeof(BD_ADDR));
  693   3              return;
  694   3            }
  695   2            
  696   2            #ifdef AIR_MODULE
  697   2            gMMI_ctl.reconnectCtl.linkLossLoopCnt = gMMI_nvram.linkLossLoopCnt;
  698   2            if(MMI_AIR_ReconnectLinkLoss((U8 XDATA_PTR)&gMMI_ctl.reconnectCtl.linkLossBdAddr))
  699   2            {
  700   3              OSMEM_memset_xdata((U8 XDATA_PTR)&gMMI_ctl.reconnectCtl.linkLossBdAddr, 0, sizeof(BD_ADDR));
  701   3              break;
  702   3            }
  703   2            #endif
  704   2            MMI_Reconnect_AddListByBdAddr(type, (U8 XDATA_PTR)&gMMI_ctl.reconnectCtl.linkLossBdAddr);
  705   2            OSMEM_memset_xdata((U8 XDATA_PTR)&gMMI_ctl.reconnectCtl.linkLossBdAddr, 0, sizeof(BD_ADDR));
  706   2            break;
  707   2          case RECONNECT_WATCHDOG:
  708   2            MMI_Reconnect_AddListByMode(type, RECONNECT_ALL_DROPPED_LINKS);
  709   2            break;
  710   2          case RECONNECT_CHECK:
  711   2            type = gMMI_ctl.reconnectCtl.type;
  712   2            #if defined AIR_MODULE && defined PRODUCT_TYPE_K
                     if(type == RECONNECT_LINK_LOSS)
                     {
                       reconectTargetPtr = (MMIReonnectDataType XDATA_PTR)MMI_AIR_Reconnect_GetTarget(type);
                       if((reconectTargetPtr == (MMIReonnectDataType XDATA_PTR)NULL))
                       {;
                         //MMI_Reconnect_DeleteListByBdAddr((U8 XDATA_PTR)&reconectTargetPtr->bdAddr[0]);
                         reconectTargetPtr = MMI_Reconnect_GetTarget();
                         if((reconectTargetPtr == (MMIReonnectDataType XDATA_PTR)NULL) || reconectTargetPtr->retryCnt == 0)
                         {
                           if(reconectTargetPtr->retryCnt == 0)
                             MMI_Reconnect_DeleteListByBdAddr((U8 XDATA_PTR)&reconectTargetPtr->bdAddr[0]);
                           
                           if(gMMI_ctl.reconnectCtl.linkLossLoopCnt == 0)
                             break;
                           
                           MMI_Reconnect_AddListByMode(RECONNECT_LINK_LOSS, gMMI_nvram.reConnectInfo.afterPowerOn);
                           MMI_Reconnect_AddListByMode(RECONNECT_USER_INIT, RECONNECT_LAST_ONE);
                           //Link Loss Loop Count == 255 is always loop
                           if(gMMI_ctl.reconnectCtl.linkLossLoopCnt != 0xFF)
                             gMMI_ctl.reconnectCtl.linkLossLoopCnt--;
                         }
                           
                       }
               
C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 13  

                     }
                     #endif
  739   2            break;
  740   2          case RECONNECT_TWS_PAIRING:
  741   2            MMI_Reconnect_AddListByMode(type, RECONNECT_TWS);
  742   2            break;
  743   2          case RECONNECT_TWS_FOLLOW:
  744   2            if(gMMI_nvram.twsKChannel == NVRAM_PROFILE_RIGHT)
  745   2            {
  746   3              MMI_Reconnect_AddListByAirLinkKeyIndex(type, 1);
  747   3            }
  748   2            else if( gMMI_nvram.twsKChannel == NVRAM_PROFILE_LEFT)
  749   2            {
  750   3              MMI_Reconnect_AddListByAirLinkKeyIndex(type, 0);            
  751   3            }   
  752   2            break;
  753   2          case RECONNECT_TWS_RELAY:
  754   2            if(gMMI_nvram.twsKChannel == NVRAM_PROFILE_RIGHT)
  755   2            {
  756   3              MMI_Reconnect_AddListByAirLinkKeyIndex(type, 0);
  757   3            }
  758   2            else if( gMMI_nvram.twsKChannel == NVRAM_PROFILE_LEFT)
  759   2            {
  760   3              MMI_Reconnect_AddListByAirLinkKeyIndex(type, 1);            
  761   3            }   
  762   2            break;
  763   2        }
  764   1      
  765   1        MMI_Reconnect_Start(type);
  766   1      }
  767          
  768          PUBLIC U8 MMI_Reconnect_GetPagingLink(void)
  769          {
  770   1        U8 linkIndex;
  771   1        
  772   1        for(linkIndex = 0; linkIndex < MAX_MULTI_POINT_NO; linkIndex++)
  773   1        {
  774   2          if(MMI_CONN_STATE_WAITING_ACTIVE == MMI_GetConnectionState(linkIndex))
  775   2            return linkIndex;
  776   2        }
  777   1        
  778   1        return MMI_EOF;
  779   1      }
  780          
  781          PUBLIC void MMI_Reconnect_DisableFunc(void)
  782          {
  783   1        gMMI_ctl.reconnectCtl.disableReconnect = TRUE;
  784   1      }
  785          
  786          PUBLIC void MMI_Reconnect_EnableFunc(void)
  787          {
  788   1        gMMI_ctl.reconnectCtl.disableReconnect = FALSE;
  789   1      }
  790          
  791          PUBLIC BOOL MMI_Reconnect_FindTarget(U8 XDATA_PTR bdAddr)
  792          {
  793   1        U8 isNormalData = TRUE;
  794   1        MMIReonnectDataType XDATA_PTR dataPtr;
  795   1        U8 index;
  796   1      
  797   1        if(gMMI_ctl.reconnectCtl.reconnectListPtr == (MMIReconnectListType XDATA_PTR)NULL)
  798   1          return FALSE;
  799   1      
  800   1        FIND_TARGET:
  801   1        index = NVRAM_LINK_KEY_ITEMS;
  802   1      
C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 14  

  803   1        while(index--)
  804   1        {
  805   2          if(isNormalData)
  806   2            dataPtr = &gMMI_ctl.reconnectCtl.reconnectListPtr->reconnectData[index];
  807   2          else
  808   2            dataPtr = &gMMI_ctl.reconnectCtl.reconnectListPtr->reconLinkLossWatchDogData[index];
  809   2      
  810   2          if(dataPtr->reconnectType != RECONNECT_TYPE_NULL)
  811   2          {
  812   3            if(SYS_IsBDAddrIsTheSame(&dataPtr->bdAddr[0],bdAddr))
  813   3              return TRUE;
  814   3          }
  815   2        }
  816   1      
  817   1        if(isNormalData)
  818   1        {
  819   2          isNormalData= FALSE;
  820   2          goto FIND_TARGET;
  821   2        }
  822   1        
  823   1        return FALSE;
  824   1      }
  825          
  826          //----------------------------------------------------
  827          //------------------- Link History ----------------------
  828          //----------------------------------------------------
  829          
  830          PRIVATE U8 MMI_LinkKey_ShiftLinkKeyToTop (U8 targetIndex)
  831          {
  832   1        // Just connected and paired
  833   1        LinkHistoryType XDATA_PTR tempMemoryPtr;
  834   1      
  835   1        if(targetIndex && (tempMemoryPtr = (LinkHistoryType XDATA_PTR)SYS_MemoryGet(sizeof(LinkHistoryType))))
  836   1        {
  837   2          OSMEM_memcpy_xdata_xdata ((U8 XDATA_PTR)tempMemoryPtr, (U8 XDATA_PTR)&gMMI_driver_variation_nvram.link_
             -history_info[targetIndex],sizeof(LinkHistoryType));
  838   2          for(; targetIndex > 0; targetIndex--)
  839   2          {
  840   3            OSMEM_memcpy_xdata_xdata ((U8 XDATA_PTR)&gMMI_driver_variation_nvram.link_history_info[targetIndex], (
             -U8 XDATA_PTR)&gMMI_driver_variation_nvram.link_history_info[targetIndex-1],sizeof(LinkHistoryType));
  841   3          }
  842   2          OSMEM_memcpy_xdata_xdata ((U8 XDATA_PTR)&gMMI_driver_variation_nvram.link_history_info[0], (U8 XDATA_PT
             -R)tempMemoryPtr, sizeof(LinkHistoryType));
  843   2          OSMEM_Put((U8 XDATA_PTR)tempMemoryPtr);
  844   2      
  845   2          MMI_SECTOR_SetUpdateFlag(TRUE);
  846   2          targetIndex = 0;
  847   2        }
  848   1        return targetIndex;
  849   1      }
  850          
  851          PUBLIC U8 MMI_LinkKey_ShiftAirLinkKeyToTop (U8 targetIndex)
  852          {
  853   1        // Just connected and paired
  854   1        LinkHistoryType XDATA_PTR tempMemoryPtr;
  855   1      
  856   1        if(targetIndex && (tempMemoryPtr = (LinkHistoryType XDATA_PTR)SYS_MemoryGet(sizeof(LinkHistoryType))))
  857   1        {
  858   2          OSMEM_memcpy_xdata_xdata ((U8 XDATA_PTR)tempMemoryPtr, (U8 XDATA_PTR)&gMMI_driver_variation_nvram.air_l
             -ink_history_info[targetIndex],sizeof(LinkHistoryType));
  859   2          for(; targetIndex > 0; targetIndex--)
  860   2          {
  861   3            OSMEM_memcpy_xdata_xdata ((U8 XDATA_PTR)&gMMI_driver_variation_nvram.air_link_history_info[targetIndex
             -], (U8 XDATA_PTR)&gMMI_driver_variation_nvram.air_link_history_info[targetIndex-1],sizeof(LinkHistoryType));
  862   3          }
  863   2          OSMEM_memcpy_xdata_xdata ((U8 XDATA_PTR)&gMMI_driver_variation_nvram.air_link_history_info[0], (U8 XDAT
C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 15  

             -A_PTR)tempMemoryPtr, sizeof(LinkHistoryType));
  864   2          OSMEM_Put((U8 XDATA_PTR)tempMemoryPtr);
  865   2          MMI_SECTOR_SetUpdateFlag(TRUE);
  866   2          targetIndex = 0;
  867   2        }
  868   1        return targetIndex;
  869   1      }
  870          
  871          PUBLIC BOOL MMI_LinkKey_IsLinkWatchdog(void)
  872          {
  873   1        U8 index;
  874   1        for(index=0; index < gMMI_nvram.storedLinkKeyCnt; index++)
  875   1        {
  876   2          if(gMMI_driver_variation_nvram.link_history_info[index].miscMask &NVRAM_LINK_KEY_MISC_MASK_CONNECTED)
  877   2          {
  878   3            return TRUE;
  879   3          }
  880   2        }
  881   1        for(index=0; index < NVRAM_AIR_LINK_KEY_NO; index++)
  882   1        {
  883   2          if(gMMI_driver_variation_nvram.air_link_history_info[index].miscMask & NVRAM_LINK_KEY_MISC_MASK_CONNECT
             -ED)
  884   2          {
  885   3            return TRUE;
  886   3          }
  887   2        }
  888   1        return FALSE;
  889   1      }
  890          
  891          PUBLIC void MMI_LinkKey_ClearConnectedFlag(void)
  892          {
  893   1        U8 index;
  894   1        for(index=0; index <  gMMI_nvram.storedLinkKeyCnt; index++)
  895   1        {
  896   2          gMMI_driver_variation_nvram.link_history_info[index].miscMask &= (~NVRAM_LINK_KEY_MISC_MASK_CONNECTED);
  897   2        }
  898   1        
  899   1        for(index=0; index <  NVRAM_AIR_LINK_KEY_NO; index++)
  900   1        {
  901   2          gMMI_driver_variation_nvram.air_link_history_info[index].miscMask &= (~NVRAM_LINK_KEY_MISC_MASK_CONNECT
             -ED);
  902   2        }
  903   1        MMI_SECTOR_SetUpdateFlag(TRUE);
  904   1      }
  905          
  906          PUBLIC U8 MMI_LinkKey_SearchLinkKeyIndex(U8 XDATA_PTR bd_addr, U8 needKeyOk)
  907          {
  908   1        U8 i;
  909   1        LinkHistoryType XDATA_PTR linkListPtr;
  910   1      
  911   1        for (i = 0; i < gMMI_nvram.storedLinkKeyCnt; i++)
  912   1        {
  913   2          linkListPtr = &gMMI_driver_variation_nvram.link_history_info[i];
  914   2      
  915   2          if(SYS_IsBDAddrIsTheSame(&(linkListPtr->linkData.bdAddr[0]), bd_addr))
  916   2          {
  917   3            if(!needKeyOk)
  918   3              break;
  919   3      
  920   3            if(linkListPtr->key_status == NVRAM_KEY_OK)
  921   3              break;
  922   3          }
  923   2        }
  924   1        if(i ==  gMMI_nvram.storedLinkKeyCnt)
  925   1          i = MMI_EOF;
  926   1      
C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 16  

  927   1        return i;
  928   1      }
  929          
  930          PUBLIC U8 MMI_LinkKey_SearchAirLinkKeyIndex(U8 XDATA_PTR bd_addr, U8 needKeyOk)
  931          {
  932   1        U8 i;
  933   1        LinkHistoryType XDATA_PTR linkListPtr;
  934   1      
  935   1        for (i = 0; i < NVRAM_AIR_LINK_KEY_NO; i++)
  936   1        {
  937   2          linkListPtr = &gMMI_driver_variation_nvram.air_link_history_info[i];
  938   2      
  939   2          if(SYS_IsBDAddrIsTheSame(&(linkListPtr->linkData.bdAddr[0]), bd_addr))
  940   2          {
  941   3            if(!needKeyOk)
  942   3              break;
  943   3      
  944   3            if(linkListPtr->key_status == NVRAM_KEY_OK)
  945   3              break;
  946   3          }
  947   2        }
  948   1        if(i ==  NVRAM_AIR_LINK_KEY_NO)
  949   1          i = MMI_EOF;
  950   1      
  951   1        return i;
  952   1      }
  953          
  954          PRIVATE U8 MMI_LinkKey_SearchFastDongleLink(U8 XDATA_PTR bd_addr, U8 needKeyOk)
  955          {
  956   1        if(SYS_IsBDAddrIsTheSame(&(gMMI_driver_variation_nvram.fast_dongle_link_history_info.linkData.bdAddr[0])
             -, bd_addr))
  957   1        {
  958   2          if(!needKeyOk)
  959   2            return 0;
  960   2      
  961   2          if(gMMI_driver_variation_nvram.fast_dongle_link_history_info.key_status == NVRAM_KEY_OK)
  962   2            return 0;
  963   2        }
  964   1        return MMI_EOF;
  965   1      }
  966          
  967          PUBLIC U8 MMI_LinkKey_GetNormalPDLNumber(void)
  968          {
  969   1        U8 i;
  970   1        U8 linkKeyCount = 0;
  971   1      
  972   1        for(i = 0;i < gMMI_nvram.storedLinkKeyCnt;i++)
  973   1        {
  974   2          if (gMMI_driver_variation_nvram.link_history_info[i].key_status == NVRAM_KEY_OK)
  975   2            ++linkKeyCount;
  976   2        }
  977   1      
  978   1        return linkKeyCount;
  979   1      }
  980          
  981          PUBLIC U8 MMI_LinkKey_GetPDLNumber(void)
  982          {
  983   1        U8 i;
  984   1        U8 linkKeyCount = 0;
  985   1      
  986   1        for(i = 0;i < gMMI_nvram.storedLinkKeyCnt;i++)
  987   1        {
  988   2          if (gMMI_driver_variation_nvram.link_history_info[i].key_status == NVRAM_KEY_OK)
  989   2            ++linkKeyCount;
  990   2        }
  991   1        for(i = 0;i < NVRAM_AIR_LINK_KEY_NO;i++)
C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 17  

  992   1        {
  993   2          if (gMMI_driver_variation_nvram.air_link_history_info[i].key_status == NVRAM_KEY_OK)
  994   2            ++linkKeyCount;
  995   2        }
  996   1      
  997   1        return linkKeyCount;
  998   1      }
  999          
 1000          PUBLIC U8 MMI_LinkKey_GetAirLinkPDLNumber(void)
 1001          {
 1002   1        U8 i;
 1003   1        U8 linkKeyCount = 0;
 1004   1      
 1005   1        for(i = 0;i < NVRAM_AIR_LINK_KEY_NO;i++)
 1006   1        {
 1007   2          if (gMMI_driver_variation_nvram.air_link_history_info[i].key_status == NVRAM_KEY_OK)
 1008   2            ++linkKeyCount;
 1009   2        }
 1010   1      
 1011   1        return linkKeyCount;
 1012   1      }
 1013          
 1014          PUBLIC void MMI_LinkKey_ClearLinkHistory(U8 index)
 1015          {
 1016   1        MMI_LinkKey_RemoveSequenceLinkHistory((LinkHistoryType XDATA_PTR) &gMMI_driver_variation_nvram.link_hist
             -ory_info, index, FALSE);
 1017   1      }
 1018          
 1019          PUBLIC void MMI_LinkKey_ClearAirLinkHistory(U8 index)
 1020          {
 1021   1        MMI_LinkKey_RemoveSequenceLinkHistory((LinkHistoryType XDATA_PTR) &gMMI_driver_variation_nvram.air_link_
             -history_info, index, TRUE);
 1022   1      }
 1023          
 1024          PUBLIC void MMI_LinkKey_ClearFastDongleLinkHistory(void)
 1025          {
 1026   1        OSMEM_memset_xdata ((U8 XDATA_PTR)&gMMI_driver_variation_nvram.fast_dongle_link_history_info, 0, sizeof(
             -LinkHistoryType));
 1027   1      }
 1028          
 1029          PUBLIC void MMI_LinkKey_MoveLinkToAirLink(U8 XDATA_PTR bdAddrPtr)
 1030          {
 1031   1        U8 i = MMI_LinkKey_SearchLinkKeyIndex((U8 XDATA_PTR)bdAddrPtr, FALSE);
 1032   1        U8 air_i = MMI_LinkKey_SearchAirLinkKeyIndex((U8 XDATA_PTR)bdAddrPtr, FALSE);
 1033   1        
 1034   1        if(i == MMI_EOF)
 1035   1        {
 1036   2          if(air_i != MMI_EOF && air_i)
 1037   2          {
 1038   3            MMI_LinkKey_ShiftAirLinkKeyToTop(air_i);
 1039   3            MMI_SECTOR_SetUpdateFlag(TRUE);
 1040   3          }
 1041   2        }
 1042   1        else
 1043   1        {
 1044   2          if(air_i == MMI_EOF)
 1045   2          {
 1046   3            air_i = NVRAM_AIR_LINK_KEY_NO - 1;
 1047   3            OSMEM_memcpy_xdata_xdata (&gMMI_driver_variation_nvram.air_link_history_info[air_i], &gMMI_driver_vari
             -ation_nvram.link_history_info[i],  sizeof(LinkHistoryType) /*6 + 16 + 1*/);
 1048   3            MMI_LinkKey_ShiftAirLinkKeyToTop(air_i);
 1049   3          }
 1050   2          else if(air_i)
 1051   2          { 
 1052   3            MMI_LinkKey_ShiftAirLinkKeyToTop(air_i);
 1053   3          }
C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 18  

 1054   2          MMI_SECTOR_SetUpdateFlag(TRUE);
 1055   2          MMI_LinkKey_ClearLinkHistory(i);
 1056   2        }
 1057   1      }
 1058          
 1059          PUBLIC void MMI_LinkKey_DeleteLinkHistory(U8 XDATA_PTR bdAddrPtr)
 1060          {
 1061   1        U8 i = MMI_LinkKey_SearchLinkKeyIndex((U8 XDATA_PTR)bdAddrPtr, FALSE);
 1062   1        if(i != MMI_EOF)
 1063   1        {
 1064   2          MMI_LinkKey_ClearLinkHistory(i);
 1065   2          MMI_SECTOR_SetUpdateFlag(TRUE);
 1066   2        }
 1067   1      }
 1068          
 1069          PUBLIC void MMI_LinkKey_DeleteAirLinkHistory(U8 XDATA_PTR bdAddrPtr)
 1070          {
 1071   1        U8 air_i = MMI_LinkKey_SearchAirLinkKeyIndex((U8 XDATA_PTR)bdAddrPtr, FALSE);
 1072   1        if(air_i != MMI_EOF)
 1073   1        {
 1074   2          MMI_LinkKey_ClearAirLinkHistory(air_i);
 1075   2          MMI_SECTOR_SetUpdateFlag(TRUE);
 1076   2        }
 1077   1      }
 1078          
 1079          PUBLIC LinkHistoryType XDATA_PTR MMI_LinkKey_SearchHistoryByBdAddr(U8 XDATA_PTR bdAddrPtr, BOOL isNeedOk,
             - BOOL isNeedShiftTop)
 1080          {
 1081   1        U8 i;
 1082   1        
 1083   1        if((i = MMI_LinkKey_SearchLinkKeyIndex(bdAddrPtr, isNeedOk)) == MMI_EOF)   //cant find
 1084   1        {
 1085   2          if((i = MMI_LinkKey_SearchAirLinkKeyIndex(bdAddrPtr, isNeedOk)) == MMI_EOF)
 1086   2          {
 1087   3            if((i = MMI_LinkKey_SearchFastDongleLink(bdAddrPtr, isNeedOk)) != MMI_EOF)
 1088   3            {
 1089   4              return (&gMMI_driver_variation_nvram.fast_dongle_link_history_info);
 1090   4            }
 1091   3          }
 1092   2          else
 1093   2          {
 1094   3            #ifndef PRODUCT_TYPE_K
 1095   3            if(isNeedShiftTop)
 1096   3              i = MMI_LinkKey_ShiftAirLinkKeyToTop(i);
 1097   3            #endif
 1098   3      
 1099   3            return (&gMMI_driver_variation_nvram.air_link_history_info[i]);     
 1100   3          }
 1101   2        }
 1102   1        else
 1103   1        {
 1104   2          if(isNeedShiftTop)
 1105   2            i = MMI_LinkKey_ShiftLinkKeyToTop(i);
 1106   2            
 1107   2          return (&gMMI_driver_variation_nvram.link_history_info[i]); 
 1108   2        }
 1109   1        return (LinkHistoryType XDATA_PTR)NULL;
 1110   1      }
 1111          
 1112          PRIVATE void MMI_LinkKey_SetConnected(U8 linkIndex)
 1113          {
 1114   1        LinkHistoryType XDATA_PTR linkListPtr= MMI_LinkKey_SearchHistoryByBdAddr((U8 XDATA_PTR)&gMMI_ctl.mmiInfo
             -[linkIndex].bdAddr[0], FALSE, TRUE);
 1115   1        
 1116   1        if(linkListPtr)
 1117   1        {
C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 19  

 1118   2          linkListPtr->miscMask |= NVRAM_LINK_KEY_MISC_MASK_CONNECTED;
 1119   2          MMI_SECTOR_SetUpdateFlag(TRUE);
 1120   2        }
 1121   1      }
 1122          
 1123          PUBLIC void MMI_LinkKey_SetLinkSoundLevelByHistory(U8 linkIndex)
 1124          {
 1125   1        U8 soundLevel, scoSmallStep;
 1126   1        #ifdef A2DP_Profile
 1127   1        U8 a2dpSoundLevel, a2dpSmallStep;
 1128   1        #endif
 1129   1        LinkHistoryType XDATA_PTR linkListPtr= MMI_LinkKey_SearchHistoryByBdAddr((U8 XDATA_PTR)&gMMI_ctl.mmiInfo
             -[linkIndex].bdAddr[0], FALSE, FALSE);
 1130   1        
 1131   1        if(linkListPtr == (LinkHistoryType XDATA_PTR)NULL)
 1132   1        {
 1133   2          soundLevel = DEFAULT_SCO_SOUND_LEVEL;
 1134   2          scoSmallStep = DEFAULT_IDLE_SMALL_STEP;
 1135   2          #ifdef A2DP_Profile
 1136   2          a2dpSoundLevel = DEFAULT_A2DP_SOUND_LEVEL;
 1137   2          a2dpSmallStep = 0;  
 1138   2          #endif
 1139   2        }
 1140   1        else
 1141   1        {
 1142   2          soundLevel = linkListPtr->sound_level;
 1143   2          scoSmallStep = linkListPtr->scoSmallStep;
 1144   2          #ifdef A2DP_Profile
 1145   2          a2dpSoundLevel = linkListPtr->a2dpSoundLevel;
 1146   2          a2dpSmallStep = linkListPtr->a2dpSmallSteps;  
 1147   2          #endif
 1148   2        }
 1149   1        
 1150   1        CURRENT_MIC_SOUND_LEVEL_IN_A2DP(linkIndex) = DEFAULT_MIC_SOUND_LEVEL_IN_A2DP;
 1151   1        MMI_DRV_SetSCOVolValue(linkIndex, soundLevel, scoSmallStep);
 1152   1        CURRENT_SCO_VGM(linkIndex) = GET_SCO_VGS_BY_LEVEL(soundLevel);
 1153   1        #ifdef A2DP_Profile
 1154   1        MMI_A2DP_SetVolByLevel(linkIndex, (MMI_A2DP_VOLUME_SYNC_HFP_VOLUME_FEAT) ? soundLevel : a2dpSoundLevel, 
             -(MMI_A2DP_VOLUME_SYNC_HFP_VOLUME_FEAT) ? scoSmallStep : a2dpSmallStep);
 1155   1        #endif
 1156   1      }
 1157          
 1158          PUBLIC void MMI_LinkKey_LoadHistory(U8 linkIndex)
 1159          {
 1160   1        MMI_LinkKey_SetConnected(linkIndex);  
 1161   1      }
 1162          
 1163          PUBLIC void MMI_LinkKey_UpdateHistory (U8 XDATA_PTR ptr1, U8 isSuccessful)
 1164          {
 1165   1        U8 i, linkIndex;
 1166   1        LinkHistoryType XDATA_PTR linkListPtr = MMI_LinkKey_SearchHistoryByBdAddr(ptr1, FALSE, TRUE);
 1167   1        
 1168   1        if(isSuccessful)
 1169   1        { 
 1170   2          linkIndex = MMI_GetLinkIndexByBdA(ptr1);
 1171   2          if(linkListPtr ==(LinkHistoryType XDATA_PTR)NULL) // New link
 1172   2          {
 1173   3            i = gMMI_nvram.storedLinkKeyCnt - 1; // choose the oldest link
 1174   3            MMI_LinkKey_ClearLinkHistory(i);
 1175   3            i = MMI_LinkKey_ShiftLinkKeyToTop(i);
 1176   3            linkListPtr = &gMMI_driver_variation_nvram.link_history_info[i];
 1177   3            linkListPtr->sound_level = DEFAULT_SCO_SOUND_LEVEL;
 1178   3            linkListPtr->scoSmallStep = DEFAULT_IDLE_SMALL_STEP;
 1179   3            linkListPtr->a2dpSoundLevel = DEFAULT_A2DP_SOUND_LEVEL;
 1180   3            linkListPtr->a2dpSmallSteps = 0;
 1181   3            
C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 20  

 1182   3            if(linkIndex != MAX_MULTI_POINT_NO)
 1183   3            {
 1184   4              OSMEM_memcpy_xdata_xdata (  (U8 XDATA_PTR)&linkListPtr->classOfDev[0],(U8 XDATA_PTR)gMMI_ctl.mmiInfo[l
             -inkIndex].linkPara.classOfDev,3);
 1185   4            }
 1186   3          }
 1187   2          linkListPtr->profile = 0;
 1188   2          OSMEM_memcpy_xdata_xdata (&linkListPtr->linkData, ptr1,  sizeof(HciLinkKeyNtf) /*6 + 16 + 1*/);
 1189   2          linkListPtr->key_status = NVRAM_KEY_OK;
 1190   2          if(MMI_GetConnectedProfileCount(linkIndex, TRUE))
 1191   2          {
 1192   3            //write flash until it gets connected
 1193   3            MMI_SECTOR_SetUpdateFlag(TRUE);
 1194   3          }
 1195   2        }
 1196   1        else
 1197   1        {
 1198   2          if(linkListPtr !=(LinkHistoryType XDATA_PTR)NULL)
 1199   2          {
 1200   3            OSMEM_memset_xdata ((U8 XDATA_PTR)linkListPtr, 0, sizeof(LinkHistoryType));
 1201   3            MMI_SECTOR_SetUpdateFlag(TRUE);
 1202   3          }
 1203   2        }
 1204   1      }
 1205          
 1206          PRIVATE void MMI_LinkKey_SaveHistory(U8 linkIndex, BOOL setDisconnected)
 1207          {
 1208   1        LinkHistoryType XDATA_PTR linkListPtr = MMI_LinkKey_SearchHistoryByBdAddr(&gMMI_ctl.mmiInfo[linkIndex].b
             -dAddr[0], FALSE, FALSE);
 1209   1        
 1210   1        if(linkListPtr !=(LinkHistoryType XDATA_PTR)NULL) // New link
 1211   1        {
 1212   2          if (setDisconnected)
 1213   2          {
 1214   3            linkListPtr->miscMask &= (~NVRAM_LINK_KEY_MISC_MASK_CONNECTED);
 1215   3          }
 1216   2          linkListPtr->sound_level = CURRENT_SCO_SOUND_LEVEL(linkIndex);
 1217   2          linkListPtr->scoSmallStep = CURRENT_SCO_SMALL_STEP(linkIndex);
 1218   2          linkListPtr->a2dpSoundLevel = CURRENT_A2DP_SOUND_LEVEL(linkIndex);
 1219   2          linkListPtr->a2dpSmallSteps =  CURRENT_A2DP_SMALL_STEP(linkIndex);
 1220   2          MMI_SECTOR_SetUpdateFlag(TRUE);
 1221   2          #ifdef AIR_MODULE
 1222   2          MMI_AIR_SaveHistory(linkIndex);
 1223   2          #endif
 1224   2        }
 1225   1      }
 1226          
 1227          PUBLIC void MMI_LinkKey_SaveHistoryInRunTime(U8 linkIndex)
 1228          {
 1229   1        MMI_LinkKey_SaveHistory(linkIndex, FALSE);
 1230   1      }
 1231          
 1232          PUBLIC void MMI_LinkKey_SaveHistoryWhenDisconnect(U8 linkIndex)
 1233          {
 1234   1        MMI_LinkKey_SaveHistory(linkIndex, TRUE);
 1235   1      }
 1236          
 1237          //This function is called when new pair devices exist at the same time.
 1238          PUBLIC void MMI_LinkKey_UpdateAGInd(U8 linkIndex)
 1239          {
 1240   1        U8 i, nextActiveLink;
 1241   1      
 1242   1        for(i = 0 ; i < MAX_MULTI_POINT_NO; i++)
 1243   1        {
 1244   2          if(SYS_IsBDAddrIsTheSame(&gMMI_ctl.mmiInfo[linkIndex].bdAddr[0],&gMMI_driver_variation_nvram.misc_para.
             -agInd[i].member[0]))
C251 COMPILER V5.57.0,  MMI_Reconnect                                                      08/11/20  06:33:55  PAGE 21  

 1245   2            return;
 1246   2        }
 1247   1      
 1248   1        //New
 1249   1        if (CURRENT_ACTIVE_LINK_CNT==1)
 1250   1        {
 1251   2          OSMEM_memcpy_xdata_xdata(&gMMI_driver_variation_nvram.misc_para.agInd[0].member[0], &gMMI_ctl.mmiInfo[l
             -inkIndex].bdAddr[0], sizeof(BD_ADDR));
 1252   2          OSMEM_memcpy_xdata_xdata(&gMMI_driver_variation_nvram.misc_para.agInd[1].member[0], &gMMI_ctl.mmiInfo[l
             -inkIndex].bdAddr[0], sizeof(BD_ADDR));
 1253   2        }
 1254   1        else if(CURRENT_ACTIVE_LINK_CNT ==2 )
 1255   1        {
 1256   2          if ((nextActiveLink = MMI_GetNextActiveLink(linkIndex)) != MMI_EOF)
 1257   2          {
 1258   3            if(SYS_IsBDAddrIsTheSame(&gMMI_ctl.mmiInfo[nextActiveLink].bdAddr[0], &gMMI_driver_variation_nvram.mis
             -c_para.agInd[0].member[0]))
 1259   3              OSMEM_memcpy_xdata_xdata(&gMMI_driver_variation_nvram.misc_para.agInd[1].member[0], &gMMI_ctl.mmiInfo
             -[linkIndex].bdAddr[0], sizeof(BD_ADDR));
 1260   3            else
 1261   3              OSMEM_memcpy_xdata_xdata(&gMMI_driver_variation_nvram.misc_para.agInd[0].member[0], &gMMI_ctl.mmiInfo
             -[linkIndex].bdAddr[0], sizeof(BD_ADDR));
 1262   3          }
 1263   2        }
 1264   1        MMI_SECTOR_SetUpdateFlag(TRUE);
 1265   1      }
 1266          
 1267          PRIVATE void MMI_LinkKey_RemoveSequenceLinkHistory( LinkHistoryType XDATA_PTR linkListPtr, U8 index, U8 i
             -sAirLink)
 1268          {
 1269   1        U8 maxCount;
 1270   1        if (isAirLink)
 1271   1          maxCount = NVRAM_AIR_LINK_KEY_NO;
 1272   1        else
 1273   1          maxCount = NVRAM_LINK_KEY_ITEMS;
 1274   1        //Remove Index LinkHistory and Sequqnce LinkHistory
 1275   1        for( index; index < maxCount - 1; index++)
 1276   1        {
 1277   2          OSMEM_memcpy_xdata_xdata ((LinkHistoryType XDATA_PTR)&linkListPtr[index], (U8 XDATA_PTR)&linkListPtr[in
             -dex + 1], sizeof(LinkHistoryType));
 1278   2        }
 1279   1        OSMEM_memset_xdata((U8 XDATA_PTR)&linkListPtr[maxCount - 1], 0, sizeof(LinkHistoryType));
 1280   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =    ------     ------
  ecode size           =      4806     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        96     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
