//////////////////////////////////////////////////////////
// Copyright@ 2009 Airoha.  All right reserved.
//////////////////////////////////////////////////////////
#include "reside_flash.inc"

#define _MMI_DRIVER_C_

#include "os.h"
#include "bt_config_profile.h"

#include "drv_sector.h"
#include "drv_gpio.h"
#include "MMI.h"
#include "MMI_Driver.h"
#include "MMI_Protocol.h"
#include "MMI_HFP.h"
#include "MMI_AVRCP.h"
#include "MMI_A2DP.h"
#include "MMI_AirModule.h"
#include "MMI_FM.h"
#include "MMI_LineIn.h"
#include "MMI_ChgBat.h"
#include "MMI_Timer.h"
#include "MMI_State.h"
#include "MMI_HCI.h"
#include "MMI_SectorManager.h"
#include "MMI_TestMode.h"
#include "MMI_Reconnect.h"
#include "MMI_LED.h"
#include "..\HC\HC_Interface.h"
#include "align_flash.h"
#include "align_osmem.h"
#include "sector_config1.h"
#include "..\DSP\DSP_Interface.h"
#ifdef HID_Profile
#include "MMI_HID.h"
#endif

#ifdef SUPPORT_VOICE_PROMPT
	#include "..\Driver\VoicePrompt.h"
#endif

#ifdef SUPPORT_VOICE_COMMAND
	#include "..\Driver\VoiceCommand.h"
	#include "..\Driver\voice_command_adaption_data_ctl.h"
#endif

#include "..\A2DP\A2DP_Interface.h"
#include "..\AVRCP\AVRCP_Interface.h"


#include "sector_voice_data.h"

#include "..\ABSDRIVER\drv_sector_flash.h"

#ifdef OLED_ENABLE
#include "..\Driver\OLED.h"
#endif
#include "..\Driver\AudioControl.h"
#include "..\Driver\Driver_Key.h"
#include "..\COMMON\bt_config_profile.h"
#include "..\ROM\DRIVER\drv_adc1.h"
#include "..\ROM\COMMON\rc.h"
#include "..\MMI\MMI_HCI.h"

#ifdef AIRAPP_Profile
	#include "..\AirApp\AirApp_Interface.h"
#endif

#include "..\Driver\Driver_LED.h"
#include "..\Driver\Driver_Temp.h"
#include "..\ABSDRIVER\drv_gpio_flash.h"

#include "..\SDK_Proxy\SDK_Proxy.h"
#include "..\Driver\Driver.h"

#ifdef AIR_MODULE
#include "..\MMI_FUNCTION\MMI_Air_Function.h"
#endif

#define RINGTONE_VOL_LEVELS 4
#define RINGTONE_MAX_VOL 0
#define RINGTONE_MIN_VOL 3

PRIVATE void MMI_DRV_KeyEvtMapInit(void);
PRIVATE void MMI_DRV_ADDAInit(void);
PRIVATE void MMI_DRV_AudioSettingsInit(void);
PRIVATE void MMI_DRV_ParaInit(void);

//////////// Key //////////////////////////////
PRIVATE BOOL MMI_DRV_CheckBtnSequence(KeyIndex keyIndex, U8 keyAction);
PRIVATE void MMI_DRV_CheckResetPairedDevice(U16 eventCode);


//////////// Audio ///////////////////////////

#ifdef SUPPORT_VOICE_COMMAND
PRIVATE void MMI_DRV_SetVoiceCommandTimer(U16 mediaEvent);
#endif

#ifdef SUPPORT_VOICE_COMMAND
extern PUBLIC DRIVER_VC_ACTION_TYPE CODE_PTR VoiceCommand_GetActionTable(U8 actionIndex);
extern PUBLIC DRIVER_VOICE_COMMAND_ACTION_APD_TYPE CODE_PTR VoiceCommand_GetAPDActionTable(U8 actionIndex);
PRIVATE U16 MMI_DRV_LookUpKeyMapTable(U16 keyEvent);
#endif

PRIVATE void MMI_DRV_KeyReconnectUserInit(U8 linkIndex);
PRIVATE void MMI_DRV_KeyDiscoverable(U8 linkIndex);
PRIVATE void MMI_DRV_KeyNonDiscoverable(U8 linkIndex);
PRIVATE void MMI_DRV_KeyConnectedToDiscoverable(U8 linkIndex);
PRIVATE void MMI_DRV_KeyConnectedToConnectable(U8 linkIndex);
PRIVATE void MMI_DRV_KeyNFCDiscoverable(U8 linkIndex);
PRIVATE void MMI_DRV_KeyConfirmationAccept(U8 linkIndex);
PRIVATE void MMI_DRV_KeyConfirmationReject(U8 linkIndex);
PRIVATE void MMI_DRV_KeyDbgKeyToggle(U8 linkIndex);
PRIVATE void MMI_DRV_KeyVoiceUp(U8 linkIndex);
PRIVATE void MMI_DRV_KeyVoiceDown(U8 linkIndex);
PRIVATE void MMI_DRV_KeyCheckBatteryStatus(U8 linkIndex);
PRIVATE void MMI_DRV_KeyBuzzerMuteToggle(U8 linkIndex);
PRIVATE void MMI_DRV_KeyToggleVolume(U8 linkIndex);
PRIVATE void MMI_DRV_KeyVolOrientationNormal(U8 linkIndex);
PRIVATE void MMI_DRV_KeyVolOrientationInvert(U8 linkIndex);
PRIVATE void MMI_DRV_KeyToggleLED(U8 linkIndex);
PRIVATE void MMI_DRV_KeyEnableLED(U8 linkIndex);
PRIVATE void MMI_DRV_KeyDisableLED(U8 linkIndex);
PRIVATE void MMI_DRV_KeyCancelLEDIndication(U8 linkIndex);
PRIVATE void MMI_DRV_KeyMediaTrigger(U8 linkIndex);
PRIVATE void MMI_DRV_KeyPowerOnDiscoverable(U8 linkIndex);
PRIVATE void MMI_DRV_KeyPowerOn(U8 linkIndex);
PRIVATE void MMI_DRV_KeyPowerOff(U8 linkIndex);
PRIVATE void MMI_DRV_KeyReset(U8 linkIndex);
PRIVATE void MMI_DRV_KeyResetPairedDevices(U8 linkIndex);
PRIVATE void MMI_DRV_KeyMaxDeviceAllowUp(U8 linkIndex);
PRIVATE void MMI_DRV_KeyMaxDeviceAllowDown(U8 linkIndex);
PRIVATE void MMI_DRV_KeyMaxDeviceAllowToggle(U8 linkIndex);
PRIVATE void MMI_DRV_KeyReconnectAfterPowerOn(U8 linkIndex);
PRIVATE void MMI_DRV_KeyVoicePromptToggle(U8 linkIndex);
PRIVATE void MMI_DRV_KeyVoicePromptEnable(U8 linkIndex);
PRIVATE void MMI_DRV_KeyVoicePromptDisable(U8 linkIndex);
#ifdef SUPPORT_VOICE_PROMPT
PRIVATE void MMI_DRV_KeyVoicePromptLanChange(U8 linkIndex);
PRIVATE void MMI_DRV_KeyVoicePromptLanSel(U8 linkIndex);
PRIVATE void MMI_DRV_KeyVoicePromptLanCfm(U8 linkIndex);
#endif
PRIVATE void MMI_DRV_KeyButtonLockOn(U8 linkIndex);
PRIVATE void MMI_DRV_KeyButtonLockOff(U8 linkIndex);
PRIVATE void MMI_DRV_KeyButtonLockToggle(U8 linkIndex);
PRIVATE void MMI_DRV_KeyMicUp(U8 linkIndex);
PRIVATE void MMI_DRV_KeyMicDown(U8 linkIndex);
PRIVATE void MMI_DRV_KeyMicMuteToggle(U8 linkIndex);
PRIVATE void MMI_DRV_KeyMicMuteOn(U8 linkIndex);
PRIVATE void MMI_DRV_KeyMicMuteOff(U8 linkIndex);
PRIVATE void MMI_DRV_KeySCOSwitch(U8 linkIndex);
PRIVATE void MMI_DRV_KeyPEQModeChange(U8 linkIndex);
PRIVATE void MMI_DRV_KeyMultiPlayModeToggle(U8 linkIndex);
PRIVATE void MMI_DRV_KeyCheckStatusOfConnection(U8 linkIndex);
PRIVATE void MMI_DRV_KeyChangeSoundEffect(U8 linkIndex);
PRIVATE void MMI_DRV_KeyControlDBBOnOff(U8 linkIndex);
PRIVATE void MMI_DRV_EnableDUTModeCMD(U8 linkIndex);
PRIVATE void MMI_DRV_KeyMicEnableL(U8 linkIndex);
PRIVATE void MMI_DRV_KeyMicEnableR(U8 linkIndex);
PRIVATE void MMI_DRV_KeyMicToSpkEnable(U8 linkIndex);
PRIVATE void MMI_DRV_KeyMicToSpkDisable(U8 linkIndex);
PRIVATE void MMI_DRV_KeyEnableECNR(U8 linkIndex);
PRIVATE void MMI_DRV_KeyDisableECNR(U8 linkIndex);
PRIVATE void MMI_DRV_Key2KToneEnable(U8 linkIndex);
PRIVATE void MMI_DRV_Key2KToneDisable(U8 linkIndex);
PRIVATE void MMI_DRV_KeySwitchStereoMono(U8 linkIndex);

#ifdef SUPPORT_MIC_IN_A2DP_MODE
PRIVATE void MMI_DRV_MicSpkActionInA2DPMode(U8 linkIndex, BOOL isEnable, BOOL isMicVolSyncSounLevel);
PRIVATE void MMI_DRV_ControlMicInA2DPMode(U8 linkIndex);
PRIVATE void MMI_DRV_KeyAudioTransparency(U8 linkIndex);
#endif
PRIVATE void MMI_DRV_KeyRoleChange(U8 linkIndex);

PRIVATE U16 MMI_DRV_CheckKeyReconnect(U16 keyCode);
PRIVATE U16 MMI_DRV_CheckKeyVoicePrompt(U16 keyCode);
PRIVATE U16 MMI_DRV_CheckKeyDiscoverable(U16 keyCode);
PRIVATE U16 MMI_DRV_CheckKeyVoiceDown(U16 keyCode);
PRIVATE U16 MMI_DRV_CheckKeyPowerOff(U16 keyCode);
PRIVATE U16 MMI_DRV_CheckKeyVoiceCommandEnable(U16 keyCode);
PRIVATE U16 MMI_DRV_CheckKeyMuteOnOff(U16 keyCode);
PRIVATE U16 MMI_DRV_CheckKeySCOSwitch(U16 keyCode);
PRIVATE U16 MMI_DRV_CheckKeyUnderA2DP(U16 keyCode);
PRIVATE U16 MMI_DRV_CheckKeyAudioTransparency(U16 keyCode);

#ifdef AUDIO_BIST
PUBLIC void MMI_DRV_AudioBistSetTimer(void);
PUBLIC void MMI_DRV_AudioBistCheckTimer(void);
PUBLIC void MMI_DRV_AudioBistSetResult(U16 SNRResult, U16 SNDRResult);
#ifdef FT_AUDIO_BIST
PUBLIC void MMI_DRV_AudioFTBIST(void);
#endif
#endif

U8 CODE audioDevLinkGrpMappingTable[] =
{
	AUDIO_DEVICE_SCO,
	AUDIO_DEVICE_SCO_HSP,
	AUDIO_DEVICE_SCO_IDLE,
	AUDIO_DEVICE_MUSIC,
	AUDIO_DEVICE_MUSIC_CALL_NOTIFY,
	AUDIO_DEVICE_KEY_AT_CMD,
	AUDIO_DEVICE_CALL_STATE,
	AUDIO_DEVICE_AVRCP_PLAY,
};

U8 CODE audioDevSysMappingTable[] =
{
	AUDIO_DEVICE_LINE_IN,
	AUDIO_DEVICE_FM,
	AUDIO_DEVICE_DEMO_SOUND,
	AUDIO_DEVICE_MIC_TO_SPK,
};

KeyEvtMapType CODE keyEventMap[KEY_TOTAL_NO] =
{
	{NOT_KEY_EVENT, 	0}, //KEY_INVALID,
	{SYSTEM_KEY_EVENT,	SYSTEM_KEY_EVENT_KEY_RECONNECT_USER_INIT}, //KEY_RECONNECT_USER_INIT
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_DISCOVERABLE},//KEY_DISCOVERABLE,
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_NONDISCOVERABLE}, //KEY_NONDISCOVERABLE,
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_CONNECTED_TO_DISCOVERABLE}, //KEY_CONNECTED_TO_DISCOVERABLE,
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_CONNECTED_TO_CONNECTABLE}, //KEY_CONNECTED_TO_CONNECTABLE,
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_NFC_DISCOVREABLE}, //KEY_NFC_DISCOVREABLE,
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_CONFIRMATION_ACCEPT}, //KEY_CONFIRMATION_ACCEPT,
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_CONFIRMATION_REJECT}, //KEY_CONFIRMATION_REJECT,
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_DEBUG_KEY_TOGGLE}, //KEY_DEBUG_KEY_TOGGLE,
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_VOICEUP}, //KEY_VOICEUP,
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_VOICEDN}, //KEY_VOICEDN,
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_CHECK_BATTERY_STATUS}, //KEY_CHECK_BATTERY_STATUS,
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_BUZZER_MUTE_TOGGLE}, //KEY_BUZZER_MUTE_TOGGLE,
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_TOGGLE_VOLUME}, //KEY_TOGGLE_VOLUME,
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_VOLUME_ORIENTATION_NORMAL}, //KEY_VOLUME_ORIENTATION_NORMAL,
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_VOLUME_ORIENTATION_INVERT}, //KEY_VOLUME_ORIENTATION_INVERT,
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_TOGGLE_LED}, //KEY_TOGGLE_LED,
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_ENABLE_LED}, //KEY_ENABLE_LED,
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_DISABLE_LED}, //KEY_DISABLE_LED,
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_CANCEL_LED_INDICATION}, //KEY_CANCEL_LED_INDICATION,
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_MEDIA_TRIGGER_1}, //KEY_MEDIA_TRIGGER_1,
	{SYSTEM_KEY_EVENT, 	SYSTEM_KEY_EVENT_KEY_MEDIA_TRIGGER_2}, //KEY_MEDIA_TRIGGER_2,

	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_POWER_ON_THEN_ENTERDISCOVERABLE},//KEY_POWER_ON_THEN_ENTERDISCOVERABLE, // For NFC
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_POWER_ON},//KEY_POWER_ON,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_POWER_OFF},//KEY_POWER_OFF,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_RESET},//KEY_RESET,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_RESET_PAIRED_DEVICES},//KEY_RESET_PAIRED_DEVICES,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_MAX_DEVICE_ALLOWED_UP},//KEY_MAX_DEVICE_ALLOWED_UP,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_MAX_DEVICE_ALLOWED_DOWN},//KEY_MAX_DEVICE_ALLOWED_DOWN,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_MAX_DEVICE_ALLOWED_TOGGLE},//KEY_MAX_DEVICE_ALLOWED_TOGGLE,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_RECONNECT_AFTER_POWER_ON},//KEY_RECONNECT_AFTER_POWER_ON,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_TOGGLE},//KEY_VOICE_PROMPT_TOGGLE,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_ENABLE},//KEY_VOICE_PROMPT_ENABLE,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_DISABLE},//KEY_VOICE_PROMPT_DISABLE,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_LANG_CHANGE},//KEY_VOICE_PROMPT_LANG_CHANGE,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_LANG_SELECT},//KEY_VOICE_PROMPT_LANG_SELECT,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_LANG_CONFIRM},//KEY_VOICE_PROMPT_LANG_CONFIRM,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_TEST_VOICE_PROMPT_PLAY},//KEY_TEST_VOICE_PROMPT_PLAY,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_TEST_VOICE_PROMPT_NEXT},//KEY_TEST_VOICE_PROMPT_NEXT,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_BUTTONLOCKON},//KEY_BUTTONLOCKON,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_BUTTONLOCKOFF},//KEY_BUTTONLOCKOFF,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_BUTTONLOCKTOGGLE},//KEY_BUTTONLOCKTOGGLE,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_VOICE_COMMAND_ENABLE},//KEY_VOICE_COMMAND_ENABLE,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_MICUP},//KEY_MICUP,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_MICDN},//KEY_MICDN,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_MIC_MUTE_TOGGLE},//KEY_MIC_MUTE_TOGGLE,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_MIC_MUTE_ON},//KEY_MIC_MUTE_ON,
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_MIC_MUTE_OFF},//KEY_MIC_MUTE_OFF,

	{AIR_KEY_EVENT,  	AIR_KEY_EVENT_KEY_AIR_ENTER_AIR_PAIRING},//KEY_AIR_ENTER_AIR_PAIRING,
	{AIR_KEY_EVENT,  	AIR_KEY_EVENT_KEY_AIR_EXIT_AIR_PAIRING},//KEY_AIR_EXIT_AIR_PAIRING,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_AUDIO_TRANSFER},//KEY_AUDIO_TRANSFER,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_SET_VOICE_RECOGNITION},//KEY_SET_VOICE_RECOGNITION,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_RDIAL},//KEY_RDIAL,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_DIALMEM},//KEY_DIALMEM,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_DIALNUM},//KEY_DIALNUM,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_CNLOUTGOING},//KEY_CNLOUTGOING,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_REJCALL},//KEY_REJCALL,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_REJCALL_SECOND_PHONE},//KEY_REJCALL_SECOND_PHONE,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_ONHOLD_CALL},//KEY_ONHOLD_CALL,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_ACPCALL},//KEY_ACPCALL,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_ENDCALL},//KEY_ENDCALL,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_3WAYRELNUDUB},//KEY_3WAYRELNUDUB,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_3WAYRELNACP},//KEY_3WAYRELNACP,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_3WAYRELNACP_X},//KEY_3WAYRELNACP_X,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_3WAYHOLDNACP},//KEY_3WAYHOLDNACP,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_3WAYHOLDNACP_X},//KEY_3WAYHOLDNACP_X,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_3WAYADD},//KEY_3WAYADD,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_3WAYCALLTRANSFER},//KEY_3WAYCALLTRANSFER,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_HSP_BUTTON_PRESSED},//KEY_HSP_BUTTON_PRESSED,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_DISABLE_NREC},//KEY_DISABLE_NREC,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_GETCALLNUM},//KEY_GETCALLNUM,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_QUERY_CALL_LIST},//KEY_QUERY_CALL_LIST,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_SEND_DTMF},//KEY_SEND_DTMF,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_ATTACH_LAST_VOICE_TAG_RECORDED},//KEY_ATTACH_LAST_VOICE_TAG_RECORDED,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_SEND_CLIP},//KEY_SEND_CLIP,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_SET_VOICE_RECOGNITION_SECONDARY},//KEY_SET_VOICE_RECOGNITION_SECONDARY,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_RDIAL_SECONDARY},//KEY_RDIAL_SECONDARY,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_SET_VOICE_RECOGNITION_CANCEL},//KEY_SET_VOICE_RECOGNITION_CANCEL,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_SET_VOICE_RECOGNITION_SECONDARY_CANCEL},//KEY_SET_VOICE_RECOGNITION_SECONDARY_CANCEL,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_SIRI_START_OR_CONTINUE},//KEY_SIRI_START_OR_CONTINUE,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_SIRI_END},//KEY_SIRI_END,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_SIRI_START_OR_CONTINUE_SECONDARY},//KEY_SIRI_START_OR_CONTINUE_SECONDARY,
	{HFP_KEY_EVENT,  	HFP_KEY_EVENT_KEY_SIRI_END_SECONDARY},//KEY_SIRI_END_SECONDARY,


	{AVRCP_KEY_EVENT,  	AVRCP_KEY_EVENT_KEY_AVRCP_PLAY},//KEY_AVRCP_PLAY,
	{AVRCP_KEY_EVENT,  	AVRCP_KEY_EVENT_KEY_AVRCP_STOP},//KEY_AVRCP_STOP,
	{AVRCP_KEY_EVENT,  	AVRCP_KEY_EVENT_KEY_AVRCP_PAUSE},//KEY_AVRCP_PAUSE,
	{AVRCP_KEY_EVENT,  	AVRCP_KEY_EVENT_KEY_AVRCP_RECORD},//KEY_AVRCP_RECORD,
	{AVRCP_KEY_EVENT,  	AVRCP_KEY_EVENT_KEY_AVRCP_REWIND_PUSH},//KEY_AVRCP_REWIND_PUSH,
	{AVRCP_KEY_EVENT,  	AVRCP_KEY_EVENT_KEY_AVRCP_FAST_FORWARD_PUSH},//KEY_AVRCP_FAST_FORWARD_PUSH,
	{AVRCP_KEY_EVENT,  	AVRCP_KEY_EVENT_KEY_AVRCP_EJECT},//KEY_AVRCP_EJECT,
	{AVRCP_KEY_EVENT,  	AVRCP_KEY_EVENT_KEY_AVRCP_FORWARD},//KEY_AVRCP_FORWARD,	//0x5B
	{AVRCP_KEY_EVENT,  	AVRCP_KEY_EVENT_KEY_AVRCP_BACKWARD},//KEY_AVRCP_BACKWARD,
	{AVRCP_KEY_EVENT,  	AVRCP_KEY_EVENT_KEY_AVRCP_REWIND_RELEASE},//KEY_AVRCP_REWIND_RELEASE,
	{AVRCP_KEY_EVENT,  	AVRCP_KEY_EVENT_KEY_AVRCP_FAST_FORWARD_RELEASE},//KEY_AVRCP_FAST_FORWARD_RELEASE,
	{AVRCP_KEY_EVENT,  	AVRCP_KEY_EVENT_KEY_AVRCP_REPEAT_MODE_CHANGE},//KEY_AVRCP_REPEAT_MODE_CHANGE,
	{AVRCP_KEY_EVENT,  	AVRCP_KEY_EVENT_KEY_AVRCP_SHUFFLE_MODE_CHANGE},//KEY_AVRCP_SHUFFLE_MODE_CHANGE,
	{AVRCP_KEY_EVENT,  	AVRCP_KEY_EVENT_KEY_AVRCP_ACTIVE_TOGGLE},//KEY_AVRCP_ACTIVE_TOGGLE,

	{SYSTEM_KEY_EVENT,	SYSTEM_KEY_EVENT_KEY_PEQ_MODE_CHANGE}, //KEY_PEQ_MODE_CHANGE,

	{FM_KEY_EVENT,  	FM_KEY_EVENT_KEY_FM_POWERON},//KEY_FM_POWERON,
	{FM_KEY_EVENT,  	FM_KEY_EVENT_KEY_FM_POWEROFF},//KEY_FM_POWEROFF,
	{FM_KEY_EVENT,  	FM_KEY_EVENT_KEY_SEEKUP},//KEY_SEEKUP,
	{FM_KEY_EVENT,  	FM_KEY_EVENT_KEY_SEEKDOWN},//KEY_SEEKDOWN,  //0x66
	{FM_KEY_EVENT,  	FM_KEY_EVENT_KEY_TUNEUP},//KEY_TUNEUP,
	{FM_KEY_EVENT,  	FM_KEY_EVENT_KEY_TUNEDN},//KEY_TUNEDN,
	{FM_KEY_EVENT,  	FM_KEY_EVENT_KEY_FM_MUTETOGGLE},//KEY_FM_MUTETOGGLE,

	{LINE_IN_KEY_EVENT,  	LINE_IN_KEY_EVENT_KEY_ENTER_LINEIN_MODE},//KEY_ENTER_LINEIN_MODE,
	{LINE_IN_KEY_EVENT,  	LINE_IN_KEY_EVENT_KEY_EXIT_LINEIN_MODE},//KEY_EXIT_LINEIN_MODE,
	{LINE_IN_KEY_EVENT,  	LINE_IN_KEY_EVENT_KEY_LINEIN_MUTE_TOGGLE},//KEY_LINEIN_MUTE_TOGGLE,

	{TESTMODE_KEY_EVENT,  	TESTMODE_KEY_EVENT_KEY_ENTER_TESTMODE},//KEY_ENTER_TESTMODE,
	{TESTMODE_KEY_EVENT,  	TESTMODE_KEY_EVENT_KEY_SWITCH_TEST_MODE_CHANNEL},//KEY_SWITCH_TEST_MODE_CHANNEL,
	{TESTMODE_KEY_EVENT,  	TESTMODE_KEY_EVENT_KEY_SWITCH_TEST_MODE_POWER},//KEY_SWITCH_TEST_MODE_POWER,
	{TESTMODE_KEY_EVENT,  	TESTMODE_KEY_EVENT_KEY_SWITCH_TEST_MODE_STATE},//KEY_SWITCH_TEST_MODE_STATE,
	{TESTMODE_KEY_EVENT,  	TESTMODE_KEY_EVENT_KEY_SWITCH_TEST_MODE_TX_PACKET_TYPE},//KEY_SWITCH_TEST_MODE_TX_PACKET_TYPE,
	{SYSTEM_KEY_EVENT,		SYSTEM_KEY_EVENT_KEY_SCO_SWITCH}, //KEY_SCO_SWITCH,
	{AIR_KEY_EVENT,			AIR_KEY_EVENT_KEY_AIR_ENTER_AIR_SECURE_PAIRING},//KEY_AIR_ENTER_AIR_SECURE_PAIRING,
	{SYSTEM_KEY_EVENT,  	SYSTEM_KEY_EVENT_KEY_MULTI_A2DP_PLAY_MODE_TOGGLE},//KEY_MULTI_A2DP_PLAY_MODE_TOGGLE,
	{SYSTEM_KEY_EVENT,  	SYSTEM_KEY_EVENT_KEY_CHECK_STATUS_OF_CONNECTION},//KEY_CHECK_STATUS_OF_CONNECTION
	{SYSTEM_KEY_EVENT,		SYSTEM_KEY_EVENT_KEY_WHAT_CAN_I_SAY},//KEY_WHAT_CAN_I_SAY
	{AVRCP_KEY_EVENT,		AVRCP_KEY_EVENT_KEY_KEY_LEFT_CHANNEL},//KEY_LEFT_CHANNEL
	{AVRCP_KEY_EVENT,		AVRCP_KEY_EVENT_KEY_KEY_RIGHT_CHANNEL},//KEY_RIGHT_CHANNEL
	{AVRCP_KEY_EVENT,		AVRCP_KEY_EVENT_KEY_KEY_STEREO_CHANNEL},//KEY_STEREO_CHANNEL
	{SYSTEM_KEY_EVENT,		SYSTEM_KEY_EVENT_KEY_VOICE_COMMAND_CANCEL},//KEY_VOICE_COMMAND_CANCEL
	{SYSTEM_KEY_EVENT,		SYSTEM_KEY_EVENT_KEY_VOICE_MAKE_A_CALL},//KEY_VOICE_MAKE_A_CALL
	{SYSTEM_KEY_EVENT,		SYSTEM_KEY_EVENT_KEY_CHECK_STATUS},//KEY_CHECK_STATUS
	{SYSTEM_KEY_EVENT,		SYSTEM_KEY_EVENT_KEY_CHANGE_SOUND_EFFECT},//KEY_CHANGE_SOUND_EFFECT
	{SYSTEM_KEY_EVENT,		SYSTEM_KEY_EVENT_KEY_CONTROL_DBB_ON_OFF},//KEY_CONTROL_DBB_ON_OFF
};

KeyEvtMapType2 CODE keyEventMap2[KEY_SECOND_TABLE_NUM] =
{
	{NOT_KEY_EVENT, 	0}, //KEY_SECOND_TABLE_START,
	{SYSTEM_KEY_EVENT,	SYSTEM_KEY_CONTROL_MIC_A2DP_MODE}, //KEY_RECONNECT_USER_INIT
	{HID_KEY_EVENT,		HID_KEY_EVENT_KEY_SELFIE},//KEY_EVENT_KEY_SELFIE
	{SYSTEM_KEY_EVENT,	SYSTEM_KEY_ENABLE_DUT_MODE_COMMAND}, //KEY_ENABLE_DUT_MODE_COMMAND
	{SYSTEM_KEY_EVENT,	SYSTEM_KEY_EVENT_KEY_MIC_L_ENABLE}, //KEY_MIC_L_ENABLE
	{SYSTEM_KEY_EVENT,	SYSTEM_KEY_EVENT_KEY_MIC_R_ENABLE}, //KEY_MIC_R_ENABLE
	{SYSTEM_KEY_EVENT,	SYSTEM_KEY_EVENT_KEY_MIC_TO_SPK_ENABLE}, //KEY_MIC_TO_SPK_ENABLE
	{SYSTEM_KEY_EVENT,	SYSTEM_KEY_EVENT_KEY_MIC_TO_SPK_DISABLE}, //KEY_MIC_TO_SPK_DISABLE
	{SYSTEM_KEY_EVENT,	SYSTEM_KEY_EVENT_KEY_ENABLE_EC_NR}, //KEY_ENABLE_EC_NR
	{SYSTEM_KEY_EVENT,	SYSTEM_KEY_EVENT_KEY_DISABLE_EC_NR}, //KEY_DISABLE_EC_NR
	{SYSTEM_KEY_EVENT,	SYSTEM_KEY_EVENT_KEY_2K_TONE_ENABLE}, //KEY_2K_TONE_ENABLE
	{SYSTEM_KEY_EVENT,	SYSTEM_KEY_EVENT_KEY_2K_TONE_DISABLE}, //KEY_2K_TONE_DISABLE
	{SYSTEM_KEY_EVENT,	SYSTEM_KEY_EVENT_KEY_SWITCH_STEREO_MONO}, //KEY_SWITCH_STEREO_MONO
	{HID_KEY_EVENT,     HID_KEY_EVENT_SWITCH_SELFIE},//MMI_EVT_KEY_SWITCH_SELFIE
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_AUDIO_TRANSPARENCY}, //KEY_AUDIO_TRANSPARENCY
	{SYSTEM_KEY_EVENT,  SYSTEM_KEY_EVENT_KEY_ROLE_CHANGE}, //KEY_ROLE_CHANGE
};

MMI_KEY_EVT_MAP_TYPE XDATA MMI_KeyEvtMap[KEY_ACTIONTOTALNUMBER];
MMI_KEY_EVT_MAP_TYPE2 XDATA MMI_KeyEvtMap2[KEY_ACTIONTOTALNUMBER];

static MMI_KEY_EVT CODE MMI_DRV_KeyEvtHandler[SYSTEM_KEY_EVENT_NO]=
{
	{MMI_DRV_KeyReconnectUserInit}, //SYSTEM_KEY_EVENT_KEY_RECONNECT_USER_INIT
	{MMI_DRV_KeyDiscoverable}, //SYSTEM_KEY_EVENT_KEY_DISCOVERABLE,
	{MMI_DRV_KeyNonDiscoverable}, //SYSTEM_KEY_EVENT_KEY_NONDISCOVERABLE,
	{MMI_DRV_KeyConnectedToDiscoverable}, //SYSTEM_KEY_EVENT_KEY_CONNECTED_TO_DISCOVERABLE,
	{MMI_DRV_KeyConnectedToConnectable}, //SYSTEM_KEY_EVENT_KEY_CONNECTED_TO_CONNECTABLE,   //0x05
	{MMI_DRV_KeyNFCDiscoverable}, //SYSTEM_KEY_EVENT_KEY_NFC_DISCOVREABLE,
	{MMI_DRV_KeyConfirmationAccept}, //SYSTEM_KEY_EVENT_KEY_CONFIRMATION_ACCEPT,
	{MMI_DRV_KeyConfirmationReject}, //SYSTEM_KEY_EVENT_KEY_CONFIRMATION_REJECT,
	{MMI_DRV_KeyDbgKeyToggle}, //SYSTEM_KEY_EVENT_KEY_DEBUG_KEY_TOGGLE,
	{MMI_DRV_KeyVoiceUp}, //SYSTEM_KEY_EVENT_KEY_VOICEUP,	  //0x0a
	{MMI_DRV_KeyVoiceDown}, //SYSTEM_KEY_EVENT_KEY_VOICEDN,
	{MMI_DRV_KeyCheckBatteryStatus}, //SYSTEM_KEY_EVENT_KEY_CHECK_BATTERY_STATUS,
	{MMI_DRV_KeyBuzzerMuteToggle}, //SYSTEM_KEY_EVENT_KEY_BUZZER_MUTE_TOGGLE,
	{MMI_DRV_KeyToggleVolume}, //SYSTEM_KEY_EVENT_KEY_TOGGLE_VOLUME,
	{MMI_DRV_KeyVolOrientationNormal}, //SYSTEM_KEY_EVENT_KEY_VOLUME_ORIENTATION_NORMAL,    //0x0F
	{MMI_DRV_KeyVolOrientationInvert}, //SYSTEM_KEY_EVENT_KEY_VOLUME_ORIENTATION_INVERT,   //0x10
	{MMI_DRV_KeyToggleLED}, //SYSTEM_KEY_EVENT_KEY_TOGGLE_LED,
	{MMI_DRV_KeyEnableLED}, //SYSTEM_KEY_EVENT_KEY_ENABLE_LED,
	{MMI_DRV_KeyDisableLED}, //SYSTEM_KEY_EVENT_KEY_DISABLE_LED,
	{MMI_DRV_KeyCancelLEDIndication}, //SYSTEM_KEY_EVENT_KEY_CANCEL_LED_INDICATION,
	{MMI_DRV_KeyMediaTrigger}, //SYSTEM_KEY_EVENT_KEY_MEDIA_TRIGGER_1,	//0x15
	{MMI_DRV_KeyMediaTrigger}, //SYSTEM_KEY_EVENT_KEY_MEDIA_TRIGGER_2,
	{MMI_DRV_KeyPowerOnDiscoverable}, //SYSTEM_KEY_EVENT_KEY_POWER_ON_THEN_ENTERDISCOVERABLE, // For NFC
	{MMI_DRV_KeyPowerOn}, //SYSTEM_KEY_EVENT_KEY_POWER_ON,
	{MMI_DRV_KeyPowerOff}, //SYSTEM_KEY_EVENT_KEY_POWER_OFF,
	{MMI_DRV_KeyReset}, //SYSTEM_KEY_EVENT_KEY_RESET,		//0x1a
	{MMI_DRV_KeyResetPairedDevices}, //SYSTEM_KEY_EVENT_KEY_RESET_PAIRED_DEVICES,  //wait ringtone voice prompt
	{MMI_DRV_KeyMaxDeviceAllowUp}, //SYSTEM_KEY_EVENT_KEY_MAX_DEVICE_ALLOWED_UP,
	{MMI_DRV_KeyMaxDeviceAllowDown}, //SYSTEM_KEY_EVENT_KEY_MAX_DEVICE_ALLOWED_DOWN,
	{MMI_DRV_KeyMaxDeviceAllowToggle}, //SYSTEM_KEY_EVENT_KEY_MAX_DEVICE_ALLOWED_TOGGLE,
	{MMI_DRV_KeyReconnectAfterPowerOn}, //SYSTEM_KEY_EVENT_KEY_RECONNECT_AFTER_POWER_ON,		//0x1F
	{MMI_DRV_KeyVoicePromptToggle}, //SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_TOGGLE,		//0x20
	{MMI_DRV_KeyVoicePromptEnable}, //SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_ENABLE,
	{MMI_DRV_KeyVoicePromptDisable}, //SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_DISABLE,
#ifdef SUPPORT_VOICE_PROMPT
	{MMI_DRV_KeyVoicePromptLanChange}, //SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_LANG_CHANGE,
	{MMI_DRV_KeyVoicePromptLanSel}, //SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_LANG_SELECT,
	{MMI_DRV_KeyVoicePromptLanCfm}, //SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_LANG_CONFIRM,		//0x25
#else
	{NULL}, //SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_LANG_CHANGE,		//0x25
	{NULL}, //SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_LANG_SELECT,		//0x25
	{NULL}, //SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_LANG_CONFIRM,		//0x25
#endif
	{NULL}, //SYSTEM_KEY_EVENT_KEY_TEST_VOICE_PROMPT_PLAY,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_TEST_VOICE_PROMPT_NEXT,
	{MMI_DRV_KeyButtonLockOn}, //SYSTEM_KEY_EVENT_KEY_BUTTONLOCKON,
	{MMI_DRV_KeyButtonLockOff}, //SYSTEM_KEY_EVENT_KEY_BUTTONLOCKOFF,
	{MMI_DRV_KeyButtonLockToggle}, //SYSTEM_KEY_EVENT_KEY_BUTTONLOCKTOGGLE,			//0x2a
	{NULL}, //SYSTEM_KEY_EVENT_KEY_VOICE_COMMAND_ENABLE,
	{MMI_DRV_KeyMicUp}, //SYSTEM_KEY_EVENT_KEY_MICUP,		//0x40
	{MMI_DRV_KeyMicDown}, //SYSTEM_KEY_EVENT_KEY_MICDN,		 //0x41
	{MMI_DRV_KeyMicMuteToggle}, //SYSTEM_KEY_EVENT_KEY_MIC_MUTE_TOGGLE,
	{MMI_DRV_KeyMicMuteOn}, //SYSTEM_KEY_EVENT_KEY_MIC_MUTE_ON,
	{MMI_DRV_KeyMicMuteOff}, //SYSTEM_KEY_EVENT_KEY_MIC_MUTE_OFF,
	{MMI_DRV_KeySCOSwitch},	//SYSTEM_KEY_EVENT_KEY_SCO_SWITCH,
	{MMI_DRV_KeyPEQModeChange}, //SYSTEM_KEY_EVENT_KEY_PEQ_MODE_CHANGE
	{MMI_DRV_KeyMultiPlayModeToggle},//SYSTEM_KEY_EVENT_KEY_MULTI_A2DP_PLAY_MODE_TOGGLE
	{MMI_DRV_KeyCheckStatusOfConnection}, //SYSTEM_KEY_EVENT_KEY_CHECK_STATUS_OF_CONNECTION
	{NULL},//SYSTEM_KEY_EVENT_KEY_WHAT_CAN_I_SAY
	{NULL},//SYSTEM_KEY_EVENT_KEY_VOICE_COMMAND_CANCEL
	{NULL},//SYSTEM_KEY_EVENT_KEY_VOICE_MAKE_A_CALL
	{NULL},//SYSTEM_KEY_EVENT_KEY_CHECK_STATUS
	{NULL},//SYSTEM_KEY_EVENT_KEY_CHANGE_SOUND_EFFECT
	{NULL},//SYSTEM_KEY_EVENT_KEY_CONTROL_DBB_ON_OFF
	#ifdef SUPPORT_MIC_IN_A2DP_MODE
	{MMI_DRV_ControlMicInA2DPMode}, //SYSTEM_KEY_CONTROL_MIC_A2DP_MODE
	#else
	{NULL},//SYSTEM_KEY_CONTROL_MIC_A2DP_MODE
	#endif
	{MMI_DRV_EnableDUTModeCMD}, //SYSTEM_KEY_ENABLE_DUT_MODE_COMMAND
	{MMI_DRV_KeyMicEnableL}, //SYSTEM_KEY_EVENT_KEY_MIC_L_ENABLE
	{MMI_DRV_KeyMicEnableR}, //SYSTEM_KEY_EVENT_KEY_MIC_R_ENABLE
	{MMI_DRV_KeyMicToSpkEnable}, //SYSTEM_KEY_EVENT_KEY_MIC_TO_SPK_ENABLE
	{MMI_DRV_KeyMicToSpkDisable}, //SYSTEM_KEY_EVENT_KEY_MIC_TO_SPK_DISABLE
	{MMI_DRV_KeyEnableECNR}, //SYSTEM_KEY_EVENT_KEY_ENABLE_EC_NR
	{MMI_DRV_KeyDisableECNR}, //SYSTEM_KEY_EVENT_KEY_DISABLE_EC_NR
	{MMI_DRV_Key2KToneEnable}, //SYSTEM_KEY_EVENT_KEY_2K_TONE_ENABLE
	{MMI_DRV_Key2KToneDisable}, //SYSTEM_KEY_EVENT_KEY_2K_TONE_DISABLE
	{MMI_DRV_KeySwitchStereoMono}, //SYSTEM_KEY_EVENT_KEY_SWITCH_STEREO_MONO
	#ifdef SUPPORT_MIC_IN_A2DP_MODE
	{MMI_DRV_KeyAudioTransparency}, //SYSTEM_KEY_EVENT_KEY_AUDIO_TRANSPARENCY
	#else
	{NULL},//SYSTEM_KEY_EVENT_KEY_AUDIO_TRANSPARENCY
	#endif
	{MMI_DRV_KeyRoleChange}, //SYSTEM_KEY_EVENT_KEY_ROLE_CHANGE
};

static MMI_KEY_CHECK CODE MMI_DRV_KeyCheckValidHandler[SYSTEM_KEY_EVENT_NO] =
{
	{MMI_DRV_CheckKeyReconnect}, //SYSTEM_KEY_EVENT_KEY_RECONNECT_USER_INIT
	{MMI_DRV_CheckKeyDiscoverable}, //SYSTEM_KEY_EVENT_KEY_DISCOVERABLE,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_NONDISCOVERABLE,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_CONNECTED_TO_DISCOVERABLE,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_CONNECTED_TO_CONNECTABLE,   //0x05
	{NULL}, //SYSTEM_KEY_EVENT_KEY_NFC_DISCOVREABLE,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_CONFIRMATION_ACCEPT,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_CONFIRMATION_REJECT,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_DEBUG_KEY_TOGGLE,
	{MMI_DRV_CheckKeyVoiceDown}, //SYSTEM_KEY_EVENT_KEY_VOICEUP,	  //0x0a
	{MMI_DRV_CheckKeyVoiceDown}, //SYSTEM_KEY_EVENT_KEY_VOICEDN,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_CHECK_BATTERY_STATUS,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_BUZZER_MUTE_TOGGLE,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_TOGGLE_VOLUME,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_VOLUME_ORIENTATION_NORMAL,    //0x0F
	{NULL}, //SYSTEM_KEY_EVENT_KEY_VOLUME_ORIENTATION_INVERT,   //0x10
	{NULL}, //SYSTEM_KEY_EVENT_KEY_TOGGLE_LED,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_ENABLE_LED,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_DISABLE_LED,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_CANCEL_LED_INDICATION,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_MEDIA_TRIGGER_1,	//0x15
	{NULL}, //SYSTEM_KEY_EVENT_KEY_MEDIA_TRIGGER_2,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_POWER_ON_THEN_ENTERDISCOVERABLE, // For NFC
	{NULL}, //SYSTEM_KEY_EVENT_KEY_POWER_ON,
	{MMI_DRV_CheckKeyPowerOff}, //SYSTEM_KEY_EVENT_KEY_POWER_OFF,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_RESET,		//0x1a
	{NULL}, //SYSTEM_KEY_EVENT_KEY_RESET_PAIRED_DEVICES,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_MAX_DEVICE_ALLOWED_UP,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_MAX_DEVICE_ALLOWED_DOWN,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_MAX_DEVICE_ALLOWED_TOGGLE,
	{MMI_DRV_CheckKeyReconnect}, //SYSTEM_KEY_EVENT_KEY_RECONNECT_AFTER_POWER_ON,		//0x1F
	{MMI_DRV_CheckKeyVoicePrompt}, //SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_TOGGLE,		//0x20
	{MMI_DRV_CheckKeyVoicePrompt}, //SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_ENABLE,
	{MMI_DRV_CheckKeyVoicePrompt}, //SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_DISABLE,
	{MMI_DRV_CheckKeyVoicePrompt}, //SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_LANG_CHANGE,
	{MMI_DRV_CheckKeyVoicePrompt}, //SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_LANG_SELECT,
	{MMI_DRV_CheckKeyVoicePrompt}, //SYSTEM_KEY_EVENT_KEY_VOICE_PROMPT_LANG_CONFIRM,		//0x25
	{NULL}, //SYSTEM_KEY_EVENT_KEY_TEST_VOICE_PROMPT_PLAY,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_TEST_VOICE_PROMPT_NEXT,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_BUTTONLOCKON,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_BUTTONLOCKOFF,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_BUTTONLOCKTOGGLE,			//0x2a
	{MMI_DRV_CheckKeyVoiceCommandEnable}, //SYSTEM_KEY_EVENT_KEY_VOICE_COMMAND_ENABLE,
	{NULL}, //SYSTEM_KEY_EVENT_KEY_MICUP,		//0x40
	{NULL}, //SYSTEM_KEY_EVENT_KEY_MICDN,		 //0x41
	{MMI_DRV_CheckKeyMuteOnOff}, //SYSTEM_KEY_EVENT_KEY_MIC_MUTE_TOGGLE,
	{MMI_DRV_CheckKeyMuteOnOff}, //SYSTEM_KEY_EVENT_KEY_MIC_MUTE_ON,
	{MMI_DRV_CheckKeyMuteOnOff}, //SYSTEM_KEY_EVENT_KEY_MIC_MUTE_OFF,
	{MMI_DRV_CheckKeySCOSwitch},	//SYSTEM_KEY_EVENT_KEY_SCO_SWITCH
	{NULL},	//SYSTEM_KEY_EVENT_KEY_PEQ_MODE_CHANGE
	{MMI_DRV_CheckKeyUnderA2DP}, //SYSTEM_KEY_EVENT_KEY_MULTI_A2DP_PLAY_MODE_TOGGLE
	{NULL}, //SYSTEM_KEY_EVENT_KEY_CHECK_STATUS_OF_CONNECTION
	{NULL}, //SYSTEM_KEY_EVENT_KEY_WHAT_CAN_I_SAY
	{NULL},//SYSTEM_KEY_EVENT_KEY_VOICE_COMMAND_CANCEL
	{NULL},//SYSTEM_KEY_EVENT_KEY_VOICE_MAKE_A_CALL
	{NULL},//SYSTEM_KEY_EVENT_KEY_CHECK_STATUS
	{NULL},//SYSTEM_KEY_EVENT_KEY_CHANGE_SOUND_EFFECT
	{NULL},//SYSTEM_KEY_EVENT_KEY_CONTROL_DBB_ON_OFF
	{NULL}, //SYSTEM_KEY_CONTROL_MIC_A2DP_MODE
	{NULL}, //SYSTEM_KEY_ENABLE_DUT_MODE_COMMAND
	{NULL}, //SYSTEM_KEY_EVENT_KEY_MIC_L_ENABLE
	{NULL}, //SYSTEM_KEY_EVENT_KEY_MIC_R_ENABLE
	{NULL}, //SYSTEM_KEY_EVENT_KEY_MIC_TO_SPK_ENABLE
	{NULL}, //SYSTEM_KEY_EVENT_KEY_MIC_TO_SPK_DISABLE
	{NULL}, //SYSTEM_KEY_EVENT_KEY_ENABLE_EC_NR
	{NULL}, //SYSTEM_KEY_EVENT_KEY_DISABLE_EC_NR
	{NULL}, //SYSTEM_KEY_EVENT_KEY_2K_TONE_ENABLE
	{NULL}, //SYSTEM_KEY_EVENT_KEY_2K_TONE_DISABLE
	{NULL}, //SYSTEM_KEY_EVENT_KEY_SWITCH_STEREO_MONO
	{MMI_DRV_CheckKeyAudioTransparency}, //SYSTEM_KEY_EVENT_KEY_AUDIO_TRANSPARENCY
	{NULL}, //SYSTEM_KEY_EVENT_KEY_ROLE_CHANGE
};

PUBLIC void MMI_DRV_Init(void)
{
	U8 pmu;

	DRIVER_Key_Update();
#if !defined AB1520S && !defined AB1525S && !defined AB1520U
	DRIVER_LED_MapGpioSetup();
#endif
	MMI_DRV_KeyEvtMapInit();
	MMI_DRV_ADDAInit();
	MMI_DRV_AudioSettingsInit();
	MMI_DRV_ParaInit();
#ifdef SUPPORT_VOICE_PROMPT
	MMI_DRV_LoadVoiceLangCtl(gMMI_driver_variation_nvram.misc_para.init.vpLangIndex);
#endif
	//Record booting Status: mcu_ctrl_reg2[4] : used to enable GPIO interrupt during S_NORMAL
	OS_ENTER_CRITICAL ();
	pmu = PMU_SYS_GET_BOOT_SW_STATUS_B1 () | SYS_SW1_CTL_ENABLE_GPIO_INT_FOR_S_NORMAL;
	PMU_SYS_SET_BOOT_SW_STATUS_B1(pmu);
	OS_EXIT_CRITICAL ();

	if(MMI_CC_UART_ENABLE || MMI_SPP_DATA_TO_UART_FEAT)
	{
		SetPowerSavingForDevice(FALSE, PWRSAV_BAT);
		gOS_PowerSavingForceMCUPauseOnly  = TRUE;
	}
}

PRIVATE void MMI_DRV_ProcessKeyEvent(U8 linkIndex, U8 index)
{
	if(MMI_DRV_KeyEvtHandler[index].fKeyEvt)
	{
		MMI_DRV_KeyEvtHandler[index].fKeyEvt(linkIndex);
	}
}

PRIVATE U16 MMI_DRV_CheckValidKey(U8 index, U16 keyCode)
{
	if(MMI_DRV_KeyCheckValidHandler[index].fKeyCheckValid)
	{
		keyCode = MMI_DRV_KeyCheckValidHandler[index].fKeyCheckValid(keyCode);
	}
	return keyCode;
}

extern VFUN XDATA api_iosys_evt_func[API_GRP_IOSYS_CB_CNT];
PRIVATE void MMI_DRV_Key_Event(KeyIndex keyIndex, U8 keyAction)
{
	MMI_TIMER_ResetAutoSwitchOffTimer();

	if(api_iosys_evt_func[API_GRP_IOSYS_CB_KEY])
	{
		if(((API_IOSYS_KEY_CB_FUNC)api_iosys_evt_func[API_GRP_IOSYS_CB_KEY])((U8)keyIndex, keyAction, gMMI_ctl.serviceInd))
		{
			goto KEY_PWRSAVING;
		}
	}
	#ifdef AIR_MODULE
	if(MMI_AIR_Key_Event(keyIndex, keyAction))
		goto KEY_PWRSAVING;
	#endif

	if(!MMI_DRV_CheckBtnSequence(keyIndex, keyAction)) // if mapping btnSequence, end this switch
	{
		MMI_DRV_KeyHandler(MMI_DRV_KeyParser(keyIndex, keyAction, MMI_GetTopStateByLink(gMMI_ctl.serviceInd), TRUE)); //parser keyevent code
	}


	KEY_PWRSAVING:
	if(!MMI_DRV_IsButtonLocked())
	{
		SetPowerSavingForDevice(TRUE, PWRSAV_KEY);
	}
}

PRIVATE void MMI_DRV_MuteReminder_Event(void)
{
	if(MMI_AllLinksInCallActiveState())
	{
		MMI_PushMediaEvent(MEDIA_EVT_MUTE_REMINDER);
	}
}

PRIVATE void MMI_DRV_ReadyPowerOff_Event(void)
{
	//1) User powers off complete(User released key, ringtone played finish)
	MMI_SECTOR_SaveData(SAVE_DATA_TYPE_POWER_OFF);

	if(MMI_DRV_IsReset())
	{
		MMI_Reset();
	}
	else
	{
		MMI_SystemOff();
	}
}

PRIVATE void MMI_DRV_FGLedEnd_Event(U16 id)
{
	MMI_PushMediaEvent(MEDIA_EVT_FG_LED_DISPLAY_OVER);
	MMI_DRV_CheckResetPairedDevice(id);
}

PRIVATE void MMI_DRV_RingtoneEnd_Event(U16 id)
{
	UNUSED(id);
}

#ifdef SUPPORT_VOICE_PROMPT
PRIVATE void MMI_DRV_VoicePromptEnd_Event(U16 id)
{
	UNUSED(id);
	/*
	if (id == MEDIA_EVT_KEY_TEST_VOICE_PROMPT_PLAY || id == MEDIA_EVT_KEY_TEST_VOICE_PROMPT_NEXT)
	{
		MMI_PushMediaEvent(MEDIA_EVT_KEY_TEST_VOICE_PROMPT_NEXT);
	}*/
}
#endif

#ifdef SUPPORT_VOICE_COMMAND
PRIVATE void MMI_DRV_VoiceCommand_ResultProcessed(U16 keyEventCode)
{
	#ifdef VC_MULTI_LAYER
	U8 vcMultiLayerEvt0, vcMultiLayerEvt1, vcMultiLayerEvt2;

	vcMultiLayerEvt0=VoiceCommand_MultiLayerRootEvt(VC_MULTI_LAYER_SET_0);
	vcMultiLayerEvt1=VoiceCommand_MultiLayerRootEvt(VC_MULTI_LAYER_SET_1);
	vcMultiLayerEvt2=VoiceCommand_MultiLayerRootEvt(VC_MULTI_LAYER_SET_2);

	if (keyEventCode ==vcMultiLayerEvt1 ||keyEventCode ==  vcMultiLayerEvt2 || keyEventCode == vcMultiLayerEvt0 )
	{
		MMI_PushMediaEvent(keyEventCode);
		MMI_PushMediaEvent(MEDIA_EVT_VOICE_COMMAND_MULTILAYER_TRIGGER);
	}
	else
	{
		MMI_PushMediaEvent(keyEventCode);
		MMI_DRV_KeyEventHandler(gMMI_ctl.serviceInd, (U8)keyEventCode);
	}
	#else

	U8 vcMultiLayerEvt0;
	vcMultiLayerEvt0=VoiceCommand_MultiLayerRootEvt(VC_MULTI_LAYER_SET_0);
	if (keyEventCode == vcMultiLayerEvt0)
	{
		MMI_PushMediaEvent(keyEventCode);
		MMI_PushMediaEvent(MEDIA_EVT_VOICE_COMMAND_MULTILAYER_TRIGGER);
	}
	else
	{
		MMI_PushMediaEvent(keyEventCode);
		MMI_DRV_KeyEventHandler(gMMI_ctl.serviceInd, (U8)keyEventCode);
	}
	#endif
}

PRIVATE BOOL MMI_DRV_IsVoiceCommandCarry(U16 keyEventCode)
{
	if(keyEventCode == KEY_VOICE_MAKE_A_CALL || keyEventCode == KEY_CHECK_STATUS)
	{
		return FALSE;
	}
	else
		return TRUE;
}

PRIVATE void MMI_DRV_VoiceCommandEnd_Event(U8 id, U8 matchedNo, U8 stoppedByUser)
{
	U8 i;
	U16 keyEventCode;
	gMMI_ctl.msgHandled = PROCD_RELEASE;

	LightDbgPrint("MMI - [VCStop]Result:%d,%d", (U8)matchedNo, (U8)stoppedByUser);

	if(!stoppedByUser)
	{
		if(gVC_ctl.vcIdentificationMode == APD_VC_IDENTIFY)
		{
			for(i = 0; i < TOTAL_APD_VOICE_COMMAND_EVENTS; i++)
			{
				if(((DRIVER_VOICE_COMMAND_APD_DATA_TYPE CODE_PTR)GET_SECTOR_BOUNDARY_ADDR(SECTOR_VOICE_COMMAND_APD_DATA))->vcEventTable[i].mediaEvent == id)
				{
					break;
				}
			}
		}
		else
		{
			for(i = 0; i < TOTAL_VOICE_COMMAND_EVENTS; i++)
			{
				if(((DRIVER_VOICE_COMMAND_DATA_TYPE CODE_PTR)GET_SECTOR_VOICE_DATA_ADDR(SECTOR_VOICE_COMMAND_DATA))->vcEventTable[i].mediaEvent == id)
				{
					break;
				}
			}
		}

		if(matchedNo !=  MMI_EOF)
		{
			if(gVC_ctl.vcIdentificationMode == APD_VC_IDENTIFY)
			{
				keyEventCode = MMI_DRV_CheckKeyValid(MMI_DRV_LookUpKeyMapTable((VoiceCommand_GetAPDActionTable(((DRIVER_VOICE_COMMAND_APD_DATA_TYPE CODE_PTR)GET_SECTOR_BOUNDARY_ADDR(SECTOR_VOICE_COMMAND_APD_DATA))->vcEventTable[i].actionIndex))->triggeredAction[matchedNo]));
				if (keyEventCode != KEY_INVALID)
				{
					//pass key event to msg handler of each mmi state. * only top state has the ctrl right of key event
					if(MMI_DRV_IsVoiceCommandCarry(keyEventCode))
					{
						MMI_PushMediaEvent(keyEventCode);
						MMI_DRV_KeyEventHandler(gMMI_ctl.serviceInd, (U8)keyEventCode);
					}
				}
			}
			else
			{
				keyEventCode = MMI_DRV_CheckKeyValid(MMI_DRV_LookUpKeyMapTable((VoiceCommand_GetActionTable(((DRIVER_VOICE_COMMAND_DATA_TYPE CODE_PTR)GET_SECTOR_VOICE_DATA_ADDR(SECTOR_VOICE_COMMAND_DATA))->vcEventTable[i].actionIndex))->triggeredAction[matchedNo]));
				if (keyEventCode != KEY_INVALID)
				{
					//pass key event to msg handler of each mmi state. * only top state has the ctrl right of key event
						if(MMI_DRV_IsVoiceCommandCarry(keyEventCode))
						{
							MMI_DRV_VoiceCommand_ResultProcessed(keyEventCode);
						}
				}
			}
			LightDbgPrint("keyEvent code %d", (U8)keyEventCode);
			return;
		}

		if(!MMI_AllLinksInCallActiveState())
		{
			MMI_PushMediaEvent(MEDIA_EVT_VOICE_COMMAND_FAIL);
		}
		if(((DRIVER_VOICE_COMMAND_DATA_TYPE CODE_PTR)GET_SECTOR_VOICE_DATA_ADDR(SECTOR_VOICE_COMMAND_DATA))->vcEventTable[i].continueTriggered)
		{
			if((0x1L << MMI_GetTopStateByLink(gMMI_ctl.serviceInd))&(((DRIVER_VOICE_COMMAND_DATA_TYPE CODE_PTR)GET_SECTOR_VOICE_DATA_ADDR(SECTOR_VOICE_COMMAND_DATA))->vcEventTable[i].triggeredState))
			{
				//MMI_PushMediaEvent(id);
			}
		}
	}
}
#endif

PRIVATE void MMI_DRV_FakeMedia_Event(MMIMsgType XDATA_PTR msgPtr)
{
	U16 id = msgPtr->msgBodyPtr.driverEvt.fakeMediaEvt.id;

	#ifdef AIRAPP_Profile
	AirApp_FakeMedia_Event(id);
	#endif

	#ifdef AIR_MODULE
	MMI_AIR_FakeMediaEvt(id);
	#endif

	#ifdef HFP_Profile
	MMI_HFP_FakeMediaEvt(id);
	#endif

	gMMI_ctl.msgHandled = PROCD_RELEASE;

	#ifdef SUPPORT_VOICE_COMMAND
	if (id ==MEDIA_EVT_KEY_WHAT_CAN_I_SAY)
	{
		MMI_DRV_SendVoiceCommandCmd(MEDIA_EVT_KEY_VOICE_COMMAND_ENABLE);
	}
	#endif

	MMI_DRV_CheckResetPairedDevice(id);

	if( id == MEDIA_EVT_KEY_MIC_MUTE_ON || id == MEDIA_EVT_KEY_MIC_MUTE_OFF)
	{
		MMI_DRV_MicMuteHandler(gMMI_ctl.serviceInd, (id == MEDIA_EVT_KEY_MIC_MUTE_ON) ? SET_MUTE_ON : SET_MUTE_OFF);
	}
	else if(id == MEDIA_EVT_KEY_CONTROL_DBB_ON_OFF)
	{
		MMI_DRV_KeyControlDBBOnOff(gMMI_ctl.serviceInd);
	}
	else if(id == MEDIA_EVT_KEY_CHANGE_SOUND_EFFECT)
	{
		MMI_DRV_KeyChangeSoundEffect(gMMI_ctl.serviceInd);
	}

	gMMI_ctl.msgHandled = NOTPROCD;
	MMI_STATE_PassThruMsg(gMMI_ctl.serviceInd, msgPtr);

	if (gMMI_ctl.msgHandled != PROCD_TRANSIT)
	{
		OSMEM_Put ((U8 XDATA_PTR)msgPtr);
	}
}

PRIVATE void MMI_DRV_A2DPStartAnchor_Event(void)
{
	#ifdef A2DP_Profile
	//MMI_A2DP_SendDriverVolCmd(CURRENT_A2DP_SOUND_LEVEL(gMMI_ctl.serviceInd), CURRENT_A2DP_SMALL_STEP(gMMI_ctl.serviceInd));
	#endif
}

PRIVATE void MMI_DRV_DSPA2DPEnabled_Event(U8 linkIndex)
{
#ifdef A2DP_Profile
	MMI_A2DP_NotifyDSPStatus(TRUE, linkIndex);
#else
	UNUSED(linkIndex);
#endif
}

PRIVATE void MMI_DRV_DSPA2DPDisabled_Event(U8 linkIndex)
{
#ifdef A2DP_Profile
	MMI_A2DP_NotifyDSPStatus(FALSE, linkIndex);
#else
	UNUSED(linkIndex);
#endif
}

PRIVATE void MMI_DRV_SetAudioSCOLink(BOOL isEnable, U8 linkIndex)
{
	if(isEnable)
	{
		gMMI_ctl.audioableSCOLink = linkIndex;
		MMI_DRV_SetSwitchingSCO(FALSE);
	}
	else
	{
		gMMI_ctl.audioableSCOLink = MMI_EOF;
	}
}

PRIVATE void MMI_DRV_DSPSCOEnabled_Event(U8 linkIndex, BOOL isLightMono)
{
	#ifdef AIR_MODULE
	if(!MMI_AIR_DSPSCOEnabled_Event(linkIndex, isLightMono))
	#else
	UNUSED(isLightMono);
	#endif
	{
		DriverVolumeSetCmd LDATA volPAra;
		MMI_DRV_SetSCODriverVolPara(CURRENT_SCO_SOUND_LEVEL(linkIndex), GET_SCO_MIC_GAIN_BY_LEVEL(CURRENT_SCO_SOUND_LEVEL(linkIndex)), CURRENT_SCO_SMALL_STEP(linkIndex),
									(gMMI_ctl.mmiInfo[linkIndex].linkPara.scoCodecType == SCO_CODEC_MSBC) ? TRUE : FALSE, &volPAra);
		DRIVER_SetNormalVolPara(&volPAra);
	}
	MMI_DRV_SetAudioSCOLink(TRUE, linkIndex);
	#ifdef AUDIO_BIST
	MMI_DRV_AudioBistSetTimer();
	#endif
}

PRIVATE void MMI_DRV_DSPSCODisabled_Event(U8 linkIndex)
{
	MMI_DRV_SetAudioSCOLink(FALSE, linkIndex);
	#ifdef AUDIO_BIST
	MMI_DRV_AudioBistSetResult(ENDIAN_TRANSFORM_U16(gAlignDSP.IC_BIST_SNR_RESULT), ENDIAN_TRANSFORM_U16(gAlignDSP.IC_BIST_SNDR_RESULT));//[bbbist]
	#endif

	#ifdef AIR_MODULE
	MMI_AIR_DSPSCODisabled_Event(linkIndex);
	#endif
}

PRIVATE void MMI_DRV_DSPLineInEnabled_Event(void)
{
	#ifdef LINEIN_ENABLE
	MMI_LineIn_NotifyDSPStatus(TRUE);
	#endif
	#ifdef AIR_MODULE
	MMI_AIR_LineInEnableNotify();
	#endif
	#ifdef AUDIO_BIST
	MMI_DRV_AudioBistSetTimer();
	#endif
	#ifdef A2DP_SRC_Profile
	MMI_A2DP_LineInEnableNotify();
	#endif
}

PRIVATE void MMI_DRV_DSPLineInDisabled_Event(void)
{
	#ifdef LINEIN_ENABLE
	MMI_LineIn_NotifyDSPStatus(FALSE);
	MMI_LineIn_MuteControl(FALSE);
	#endif
	#ifdef AIR_MODULE
	MMI_AIR_LineInDisableNotify();
	#endif
	#ifdef AUDIO_BIST
		#ifndef FT_AUDIO_BIST
		MMI_DRV_AudioBistSetResult(ENDIAN_TRANSFORM_U16(gAlignDSP.IC_BIST_SNR_RESULT), ENDIAN_TRANSFORM_U16(gAlignDSP.IC_BIST_SNDR_RESULT));
		#endif
	#endif
}

PRIVATE void MMI_DRV_RequestCloseFM_Event(void)
{
	#ifdef FM_ENABLE
		MMI_FM_DriverCmd(DRIVER_FM_POWEROFF_CMD);
	#endif
}

PRIVATE void MMI_DRV_ATSwitch_Event(void)
{
	#ifdef AIR_MODULE
	U8 airlink;
	if((airlink = MMI_AIR_GetAirLink(PRODUCT_AIR_TWS)) != MMI_EOF)
	{
		if(A2DP_IsLinkRelayer(airlink))
		{
			MMI_AVRCP_SendVendorUnique(airlink, AVRCP_VENDOR_UNIQ_SYNC_AND_SWITCH_AUDIO_TRANSPARENCY, TRUE);
		}
	}
	#endif
}

PRIVATE void MMI_DRV_AsyncSCOEnabled_Event(U8 linkIndex)
{
	DriverVolumeSetCmd LDATA volPAra;
	MMI_DRV_SetSCODriverVolPara(CURRENT_SCO_SOUND_LEVEL(linkIndex), GET_SCO_MIC_GAIN_BY_LEVEL(CURRENT_SCO_SOUND_LEVEL(linkIndex)), CURRENT_SCO_SMALL_STEP(linkIndex),
								(gMMI_ctl.mmiInfo[linkIndex].linkPara.scoCodecType == SCO_CODEC_MSBC) ? TRUE : FALSE, &volPAra);
	DRIVER_SetNormalVolPara(&volPAra);

	gMMI_ctl.driverCtl.isAsyncSCOOn = TRUE;
}

PRIVATE void MMI_DRV_AsyncSCODisabled_Event(U8 linkIndex)
{
	UNUSED(linkIndex);
	gMMI_ctl.driverCtl.isAsyncSCOOn = FALSE;
}

MMI_DRV_HANDLE_TYPE CODE gMMI_Drv_Handler =
{
	MMI_DRV_Key_Event, 				//fDriverKeyEvent,
	MMI_DRV_MuteReminder_Event, 	//fDriverMuteReminderEvent,
	MMI_DRV_ReadyPowerOff_Event, 	//fDriverReadyPowerOffEvent,
	MMI_DRV_FGLedEnd_Event,			//fDriverFGLedEndEvent,
	MMI_DRV_RingtoneEnd_Event,		//fDriverRingtoneEndEvent,
#ifdef SUPPORT_VOICE_PROMPT
	MMI_DRV_VoicePromptEnd_Event,	//fDriverVoicePromptEndEvent,
#endif
#ifdef SUPPORT_VOICE_COMMAND
	MMI_DRV_VoiceCommandEnd_Event,	//fDriverVoiceCmdEndEvent,
#endif
	MMI_DRV_FakeMedia_Event, 		//fDriverFakeMediaEvent,
	MMI_DRV_A2DPStartAnchor_Event,	//fDriverA2DPStartAnchorEvent,
	MMI_DRV_DSPA2DPEnabled_Event,	//fDriverDSPA2DPEnabledEvent,
	MMI_DRV_DSPA2DPDisabled_Event,	//fDriverDSPA2DPDisabledEvent,
	MMI_DRV_DSPSCOEnabled_Event,	//fDriverDSPSCOEnabledEvent,
	MMI_DRV_DSPSCODisabled_Event,	//fDriverDSPSCODisabledEvent,
	MMI_DRV_DSPLineInEnabled_Event,	//fDriverDSPLineInEnabledEvent,
	MMI_DRV_DSPLineInDisabled_Event,//fDriverDSPLineInDisabledEvent,
	MMI_DRV_RequestCloseFM_Event,	//fDriverReqCloseFMEvent,
	MMI_DRV_ATSwitch_Event,			//fDriverATSwitchEvent,
	MMI_DRV_AsyncSCOEnabled_Event,	//fDriverAsyncSCOEnabledEvent,
	MMI_DRV_AsyncSCODisabled_Event,	//fDriverAsyncSCODisabledEvent,
};

PUBLIC void MMI_DRV_EventHandler(void)
{
	MMIMsgType XDATA_PTR msgPtr;

	if ((msgPtr = (MMIMsgType XDATA_PTR)OSMQ_Get (OSMQ_MMI_Internal_ptr)) != (MMIMsgType XDATA_PTR)NULL)
	{
		gMMI_ctl.msgHandled = NOTPROCD;

		if(msgPtr->eventCode == MMI_RESET_PAIRED_DEVICE_CMD)
		{
			if(CURRENT_ACTIVE_LINK_CNT)
			{
				gMMI_ctl.msgHandled = PROCD_TRANSIT;
				OSMQ_Put(OSMQ_MMI_Internal_ptr, (U8 XDATA_PTR)msgPtr);
			}
			else
			{
				if(!gMMI_ctl.driverCtl.resetPairedDeviceMediaCount)
				{
					MMI_SECTOR_ResetPairedDevices();
				}
			}
		}
		else
		{
			MMI_STATE_PassThruMsg(gMMI_ctl.serviceInd, msgPtr);
		}

		if (gMMI_ctl.msgHandled != PROCD_TRANSIT)
		{
			OSMEM_Put ((U8 XDATA_PTR)msgPtr);
		}
	}

#ifdef AUDIO_BIST
	MMI_DRV_AudioBistCheckTimer();
	#ifdef FT_AUDIO_BIST
	MMI_DRV_AudioFTBIST();
	#endif
#endif
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////  KEY  /////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
PUBLIC U8 MMI_DRV_GetKeyEventGroup(U16 keyCode)
{
	if(keyCode < KEY_SECOND_TABLE_START_INDEX)
		return keyEventMap[keyCode].group;
	else
		return keyEventMap2[keyCode-KEY_SECOND_TABLE_START_INDEX].group;
}

PUBLIC U8 MMI_DRV_GetKeyEventIndex(U16 keyCode)
{
	if(keyCode < KEY_SECOND_TABLE_START_INDEX)
		return keyEventMap[keyCode].index;
	else
		return keyEventMap2[keyCode-KEY_SECOND_TABLE_START_INDEX].index;
}

PUBLIC void MMI_DRV_KeyEventHandler(U8 linkIndex, U16 keyCode)
{
	U8 index;

	if(keyCode < KEY_SECOND_TABLE_START_INDEX)
		LightDbgPrintWithOpcode((U8)HCI_VEVT_OCF_MMI_DBGPRINT_KEYCODE_NEW, (U8)HCI_VENDOR_OGF_UART_MMI_DBGPRINT, (U8)OCF_DBGPRINT_U8, (U8)keyCode);
	else
		LightDbgPrintWithOpcode((U8)HCI_VEVT_OCF_MMI_DBGPRINT_KEYCODE_NEW, (U8)HCI_VENDOR_OGF_UART_MMI_DBGPRINT, (U8)OCF_DBFPRINT_U16, (U16)keyCode);


	index = MMI_DRV_GetKeyEventIndex(keyCode);
	switch(MMI_DRV_GetKeyEventGroup(keyCode))
	{
		case SYSTEM_KEY_EVENT:
			MMI_DRV_ProcessKeyEvent(linkIndex, index);
			break;
		case AIR_KEY_EVENT:
			#ifdef AIR_MODULE
			MMI_AIR_ProcessKeyEvent(linkIndex, index);
			#endif
			break;
		case HFP_KEY_EVENT:
			#ifdef HFP_Profile
			MMI_HFP_ProcessKeyEvent(linkIndex, index);
			#endif
			break;
		case AVRCP_KEY_EVENT:
			#ifdef AVRCP_Profile
			MMI_AVRCP_ProcessKeyEvent(linkIndex, index);
			#endif
			break;
		case FM_KEY_EVENT:
			#ifdef FM_ENABLE
			MMI_FM_ProcessKeyEvent(linkIndex, index);
			#endif
			break;
		case LINE_IN_KEY_EVENT:
			#ifdef LINEIN_ENABLE
			MMI_LineIn_ProcessKeyEvent(linkIndex, index);
			#endif
			break;
		case TESTMODE_KEY_EVENT:
			MMI_TestMode_ProcessKeyEvent(linkIndex, index);
			break;
		#ifdef HID_Profile
		case HID_KEY_EVENT:
			MMI_HID_ProcessKeyEvent(linkIndex, index);
			break;
		#endif
	}
}


PUBLIC void MMI_DRV_KeyHandler(U16 keyEventCode)
{
	if ( keyEventCode >= KEY_TOTAL_NO && keyEventCode < KEY_SECOND_TABLE_START_INDEX )
	{
		return;
	}

	if (((keyEventCode != KEY_BUTTONLOCKTOGGLE) && MMI_DRV_IsButtonLocked())
		 || !MMI_DRV_IsButtonLocked() && MMI_IGNORE_KEYEVENT_JUST_ENABLE_LED_FEAT)
	{
		LightDbgPrint("key handler lock %X", (U32)keyEventCode);
		return;
	}

	keyEventCode = MMI_DRV_CheckKeyValid(keyEventCode);

	if (keyEventCode != KEY_INVALID)
	{
		if(keyEventCode != KEY_CNLOUTGOING)
			MMI_PushMediaEvent(keyEventCode);

		MMI_DRV_KeyEventHandler(gMMI_ctl.serviceInd, keyEventCode);
	}
}

//////////////////////////////////////////////////////////////////////////////
//////////////////// Voice Prompt ////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

PUBLIC void MMI_DRV_LoadVoiceLangCtl(U8 vpLangIndex)
{
#ifdef SUPPORT_VOICE_PROMPT
	DRIVER_LoadLanguageCtlFromROM(vpLangIndex);
#else
	UNUSED(vpLangIndex);
#endif
}

#ifdef SUPPORT_VOICE_PROMPT
PUBLIC void MMI_DRV_ChangeVoicePromptLangCandidate(void)
{
	SYS_SetTimer(&gMMI_ctl.vpRuntime.vpSelectTimerPtr, gMMI_nvram.vpConfig.LangSelectTime * 320L);

	MMI_DRV_LoadVoiceLangCtl(gMMI_ctl.vpRuntime.vpSelectIndex);
	MMI_PushMediaEvent(MEDIA_EVT_VOICE_PROMPT_LANG_SELECT);
}

PRIVATE void MMI_TestVoicePrompt_CallNumber(void)
{
	MMIMsgType XDATA_PTR msgPtr;
	U8 i;

	if ((msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_VOICEPROMPT_CMD)) == (MMIMsgType XDATA_PTR)NULL)
		return;

	msgPtr->msgBodyPtr.driverCmd.voicePromptCmd.id = MEDIA_EVT_ENTER_INCOMING;
	msgPtr->msgBodyPtr.driverCmd.voicePromptCmd.vpIndex = VP_EVT_CALLER_ID;

	msgPtr->msgBodyPtr.driverCmd.voicePromptCmd.vpData.callerIDData.callerIdLength = 10;

	for (i = 0; i < 10; i++)
	{
		msgPtr->msgBodyPtr.driverCmd.voicePromptCmd.vpData.callerIDData.callerID[i] = i;
	}

	OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
}
#endif

PUBLIC void MMI_DRV_SendVoicepromptStopCmd(void)
{
	MMIMsgType XDATA_PTR msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_STOP_VP_CMD);

	if(msgPtr != (MMIMsgType XDATA_PTR)NULL)
	{
		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
	}
}

PUBLIC void MMI_DRV_SpecificEventVPStopCmd(U16 id)
{
	DRIVER_SendStopSpecificVPCmd(id);
}

PUBLIC void MMI_DRV_SendVoicePromptCmd(U16 mediaEventIndex, U8 voicePromptIndex)
{
	MMIMsgType XDATA_PTR msgPtr;

	if (!MMI_PlayVoicePromptIsAvailable(mediaEventIndex))
		return;

	msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_VOICEPROMPT_CMD);

	if (msgPtr == (MMIMsgType XDATA_PTR)NULL)
		return;

	msgPtr->msgBodyPtr.driverCmd.voicePromptCmd.id = mediaEventIndex;
	msgPtr->msgBodyPtr.driverCmd.voicePromptCmd.vpIndex = voicePromptIndex;
	OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
}


//////////////////////////////////////////////////////////////////////////////
//////////////////// Ring tone ////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
PUBLIC void MMI_DRV_SendRingtoneCmd(U16 mediaEventIndex, U8 beepPattern)
{
	MMIMsgType XDATA_PTR msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_RINGTONE_CMD);

	if(msgPtr != (MMIMsgType XDATA_PTR)NULL)
	{
		msgPtr->msgBodyPtr.driverCmd.ringtoneCmd.beepIndex = beepPattern;
		msgPtr->msgBodyPtr.driverCmd.ringtoneCmd.id	= mediaEventIndex;
		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
	}
}

PUBLIC void MMI_DRV_SendRingtoneStopCmd()
{
	MMIMsgType XDATA_PTR msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_STOP_RINGTONE_CMD);

	if(msgPtr != (MMIMsgType XDATA_PTR)NULL)
	{
		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
	}
}

PUBLIC void MMI_DRV_SpecificEventRingtoneStopCmd(U16 id)
{
	DRIVER_SendStopSpecificRTCmd(id);
}

PUBLIC void MMI_DRV_SendFakeMediaCmd(U16 mediaEventIndex)
{

	MMIMsgType XDATA_PTR msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_FAKE_MEDIA_VP_RINGTONE_CMD);

	if(msgPtr != (MMIMsgType XDATA_PTR)NULL)
	{
		msgPtr->msgBodyPtr.driverCmd.fakeMediaCmd.id = mediaEventIndex;
		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
	}
}

PRIVATE void MMI_DRV_SetVprtVolBySoundLevel(U8 soundLevel)
{
	MMIMsgType XDATA_PTR msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_VPRT_VOLUME_SET_CMD);

	if(msgPtr != (MMIMsgType XDATA_PTR)NULL)
	{
		msgPtr->msgBodyPtr.driverCmd.volSetCmd.soundLevel = soundLevel;
		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);

		LightDbgPrint("VPRT SoundLevel:%d", (U8)soundLevel);
	}
}

PUBLIC void MMI_DRV_SendDriverVolCmd(U8 linkIndex, U8 soundLevel, U8 smallStep, U8 micGainSetIndex)
{
	MMIMsgType XDATA_PTR msgPtr;
	BOOL isWideBand = FALSE;

	if(linkIndex != MMI_EOF && gMMI_ctl.mmiInfo[linkIndex].linkPara.scoCodecType == SCO_CODEC_MSBC)
		isWideBand = TRUE;

	if(micGainSetIndex == VOLUME_MIC_FOLLOW_SPK)
	{
		if(soundLevel == VOLUME_DONT_CARE)
			return;

		micGainSetIndex = (MMI_ADJUST_MIC_LEVEL_AUTOMATICALLY_FEAT) ? GET_SCO_MIC_GAIN_BY_LEVEL(soundLevel) : VOLUME_DONT_CARE;
	}

	if((msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_VOLUME_SET_CMD)) != (MMIMsgType XDATA_PTR)NULL)
	{
		MMI_DRV_SetSCODriverVolPara(soundLevel, micGainSetIndex, smallStep, isWideBand, &msgPtr->msgBodyPtr.driverCmd.volSetCmd);
		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
		#ifdef AIR_MODULE
		MMI_AIR_SendDriverVolCmd(soundLevel, smallStep);
		#endif
		LightDbgPrint("SCO SoundLevel:%d,%d", (U8)soundLevel,(U8)smallStep);
	}
}

PUBLIC void MMI_DRV_SetSCODriverVolPara(U8 soundLevel, U8 micGainSetIndex, U8 smallStep, U8 isWideBand, DriverVolumeSetCmd XDATA_PTR volPtr)
{
	U8 deltaDigitalGainL, deltaAnalogGainL;
	U8 spkGainSetIndex;

	spkGainSetIndex = (soundLevel != VOLUME_DONT_CARE)? GET_SCO_SPK_GAIN_BY_LEVEL(soundLevel) : VOLUME_DONT_CARE;

	volPtr->soundLevel= soundLevel;

	// SPEAKER
	if(spkGainSetIndex != VOLUME_DONT_CARE)
	{
		if(isWideBand)
		{
			volPtr->spkVols = MMI_SPK_GAINSET_SCOWB[spkGainSetIndex].digitalGainWB;
			volPtr->analogDaGain = MMI_SPK_GAINSET_SCOWB[spkGainSetIndex].analogGainWB;
			volPtr->smallStepLevel = smallStep;
		}
		else
		{
			volPtr->spkVols = MMI_SPK_GAINSET[spkGainSetIndex].digitalGain;
			volPtr->analogDaGain = MMI_SPK_GAINSET[spkGainSetIndex].analogGain;
			volPtr->smallStepLevel = smallStep;
		}

		if(smallStep)
		{
			if(isWideBand)
			{
				deltaDigitalGainL = (U16)(MMI_SPK_GAINSET_SCOWB[GET_SCO_SPK_GAIN_BY_LEVEL(soundLevel+1)].digitalGainWB - MMI_SPK_GAINSET_SCOWB[spkGainSetIndex].digitalGainWB)*smallStep/(gMMI_nvram.smallStepVolume.scoVolumeSmallStep+1);
				deltaAnalogGainL = (U16)(MMI_SPK_GAINSET_SCOWB[GET_SCO_SPK_GAIN_BY_LEVEL(soundLevel+1)].analogGainWB - MMI_SPK_GAINSET_SCOWB[spkGainSetIndex].analogGainWB)*smallStep/(gMMI_nvram.smallStepVolume.scoVolumeSmallStep+1);
			}
			else
			{
				deltaDigitalGainL = (U16)(MMI_SPK_GAINSET[GET_SCO_SPK_GAIN_BY_LEVEL(soundLevel+1)].digitalGain - MMI_SPK_GAINSET[spkGainSetIndex].digitalGain)*smallStep/(gMMI_nvram.smallStepVolume.scoVolumeSmallStep+1);
				deltaAnalogGainL = (U16)(MMI_SPK_GAINSET[GET_SCO_SPK_GAIN_BY_LEVEL(soundLevel+1)].analogGain - MMI_SPK_GAINSET[spkGainSetIndex].analogGain)*smallStep/(gMMI_nvram.smallStepVolume.scoVolumeSmallStep+1);
			}
			volPtr->spkVols += deltaDigitalGainL;
			volPtr->analogDaGain += deltaAnalogGainL;
		}
	}
	else
	{
		volPtr->spkVols = VOLUME_DONT_CARE;
		volPtr->analogDaGain = VOLUME_DONT_CARE;
	}

	//MIC
	if(micGainSetIndex != VOLUME_DONT_CARE)
	{
		if(isWideBand)
		{
			volPtr->micVols = MMI_MIC_GAINSET_SCOWB[micGainSetIndex].digitalGainWB;
			volPtr->analogAdGain_R = MMI_MIC_GAINSET_SCOWB[micGainSetIndex].analogGainWB_R;
			volPtr->analogAdGain_L = MMI_MIC_GAINSET_SCOWB[micGainSetIndex].analogGainWB_L;
		}
		else
		{
			volPtr->micVols = MMI_MIC_GAINSET[micGainSetIndex].digitalGain;
			volPtr->analogAdGain_R = MMI_MIC_GAINSET[micGainSetIndex].analogGain_R;
			volPtr->analogAdGain_L = MMI_MIC_GAINSET[micGainSetIndex].analogGain_L;
		}
	}
	else
	{
		volPtr->micVols = VOLUME_DONT_CARE;
		volPtr->analogAdGain_R = VOLUME_DONT_CARE;
		volPtr->analogAdGain_L = VOLUME_DONT_CARE;
	}
}

PUBLIC void MMI_DRV_SetSCOVolValue(U8 linkIndex, U8 soundLevel, U8 smallStep)
{
	CURRENT_SCO_SOUND_LEVEL(linkIndex) = soundLevel;
	CURRENT_SCO_SMALL_STEP(linkIndex) = smallStep;
	#ifdef AVRCP_Profile
	gMMI_ctl.mmiInfo[linkIndex].linkPara.absVolume = MMI_AVRCP_SoundLevelToAbsoluteVol(soundLevel, (U8)MMI_MAX_SCO_SOUND_LEVEL(), smallStep, MMI_SCO_SMALL_STEP_LEVELS());;
	#endif
}

PUBLIC void MMI_DRV_SCOAbsVolToSoundLevel(U8 linkIndex, U8 absVol)
{
	U8 i;

	gMMI_ctl.mmiInfo[linkIndex].linkPara.absVolume = absVol;

	if(absVol == 0)
		i = 0;
	else if(absVol == AVRCP_ABSOLUTE_VOLUME_MAX)
		i = MMI_MAX_MUSIC_SOUND_LEVEL();
	else
		i = ((U16)absVol * MMI_MAX_MUSIC_SOUND_LEVEL() + (AVRCP_ABSOLUTE_VOLUME_FULL_RANGE / 2))
			/AVRCP_ABSOLUTE_VOLUME_FULL_RANGE;

	if(i != CURRENT_SCO_SOUND_LEVEL(linkIndex))
	{
		CURRENT_SCO_SOUND_LEVEL(linkIndex) = i;
		CURRENT_SCO_SMALL_STEP(linkIndex) = 0;
	}
}

////////////////////////////////////////////////////////////////////////
///////////////////////  PRIVATE FUNCTIONS /////////////////////////////
////////////////////////////////////////////////////////////////////////
PRIVATE void MMI_DRV_KeyEvtMapInit(void)
{
	U8 mainKeyActionInd, keyEventAccNo;
	keyEventAccNo=0;
	for( mainKeyActionInd=KEY_TAP;  mainKeyActionInd < KEY_ACTIONTOTALNUMBER;  mainKeyActionInd++)
	{
		MMI_KeyEvtMap[mainKeyActionInd].keyEventStartIndex = keyEventAccNo;
		MMI_KeyEvtMap[mainKeyActionInd].keyEventNo = gMMI_nvram_keymap.mmiKeyMapPairNo[mainKeyActionInd];
		keyEventAccNo += gMMI_nvram_keymap.mmiKeyMapPairNo[mainKeyActionInd];
	}
}

PRIVATE void MMI_DRV_ADDAInit(void)
{
	MMIMsgType XDATA_PTR msgPtr;
	if(MMI_CheckBootFlag(SYS_SW1_BOOT_FLAG_POWER_ON_READY))
	{
		msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_POWER_ON_CLOSE_ADDA_CMD);
		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
	}
}

PRIVATE void MMI_DRV_AudioSettingsInit(void)
{
	MMI_DRV_SendDriverVolCmd(MMI_EOF, DEFAULT_SCO_SOUND_LEVEL, DEFAULT_IDLE_SMALL_STEP, GET_SCO_MIC_GAIN_BY_LEVEL(DEFAULT_SCO_SOUND_LEVEL));
	gMMI_ctl.idleStateSoundLevel = DEFAULT_SCO_SOUND_LEVEL;
	gMMI_ctl.idleStateSmallStep = DEFAULT_IDLE_SMALL_STEP;
	MMI_DRV_SetVprtVolBySoundLevel(gMMI_ctl.idleStateSoundLevel);

	gMMI_ctl.audioableSCOLink = MMI_EOF;
	gMMI_ctl.audioableA2DPLink = MMI_EOF;
	gMMI_ctl.driverCtl.audioSwitchHandler = MMI_EOF_HANDLER;
	#ifdef DEMOSOUND
	gMMI_A2DP_ctl.demoSoundCtl.soundLevel = DEFAULT_A2DP_SOUND_LEVEL;
	gMMI_A2DP_ctl.demoSoundCtl.smallStep = DEFAULT_IDLE_SMALL_STEP;
	#endif
}

PRIVATE void MMI_DRV_ParaInit(void)
{
	gMMI_DRV_ctl.isMiscEnabled = gMMI_driver_variation_nvram.misc_para.init.isMiscEnabled;
}

PRIVATE BOOL MMI_DRV_CheckBtnSequence(KeyIndex keyIndex, U8 keyAction)
{
	U8 i;
	U8 unmappedBtnSeqNo;
	BOOL isMatchBtnSeq;

	isMatchBtnSeq = FALSE;

	if (keyAction == KEY_TAP || keyAction == KEY_PRESS_RELEASE || keyAction == KEY_LONGPRESS_RELEASE ||
		keyAction == KEY_DOUBLE || keyAction == KEY_TRIPLE || keyAction == KEY_LONGLONGPRESS_RELEASE ||
		keyAction == KEY_EXTREMELY_LONGPRESS_RELEASE)
	{
		//i from 0 to MAX_BTN_SEQ_NO
		for(i = 0 , unmappedBtnSeqNo =0 ; i < MAX_BTN_SEQ_NO; i++)
		{
			if(	keyIndex ==gMMI_nvram.mmiBtnSeqInfo[i].keyEvent[gMMI_ctl.driverCtl.btnSeqRecord[i]].keyIndex  &&
				keyAction == gMMI_nvram.mmiBtnSeqInfo[i].keyEvent[gMMI_ctl.driverCtl.btnSeqRecord[i]].keyAction )
			{
				gMMI_ctl.driverCtl.btnSeqRecord[i]++;

				if(gMMI_ctl.driverCtl.btnSeqRecord[i] == MAX_KEY_MATCH_SEQ_NO ||gMMI_nvram.mmiBtnSeqInfo[i].keyEvent[gMMI_ctl.driverCtl.btnSeqRecord[i]+1].keyIndex == KEYNONE ) // Match case --> trigger keyevent
				{
					gMMI_ctl.driverCtl.btnSeqRecord[i] = MMI_BEGINNING_BTN_SEQ_INDEX;
					MMI_PushMediaEvent(gMMI_nvram.mmiBtnSeqInfo[i].mmiKeyCode);
					MMI_DRV_KeyEventHandler(gMMI_ctl.serviceInd, gMMI_nvram.mmiBtnSeqInfo[i].mmiKeyCode);
					isMatchBtnSeq = TRUE;
					SYS_SetTimer(&gMMI_ctl.mmiTimerInfo.sysTimer.btnSequenceTimer, 10); // T.O. to clear the ctl data
				}
				else
				{
					SYS_SetTimer(&gMMI_ctl.mmiTimerInfo.sysTimer.btnSequenceTimer, 7* ONE_SEC);
				}

			}
			else
			{
				gMMI_ctl.driverCtl.btnSeqRecord[i] = MMI_BEGINNING_BTN_SEQ_INDEX;
				unmappedBtnSeqNo++;
			}
		}

		if(unmappedBtnSeqNo == MAX_BTN_SEQ_NO)
			SYS_ReleaseTimer(&gMMI_ctl.mmiTimerInfo.sysTimer.btnSequenceTimer);
	}

	return isMatchBtnSeq;
}

PUBLIC U16 MMI_DRV_KeyParser(KeyIndex keyIndex, U8 keyAction, U8 state, BOOL isLocalParser)
{
	U8 keyEventInd;
	U32 stateBitMask;

	if(isLocalParser)
	{
		if(MMI_KEY_MAP_MAPPING_BY_KEY_DOWN_STATE_FEAT)
		{
			if(keyAction == KEY_DOWN)
				gMMI_ctl.driverCtl.keyDownState = state;
		}
		else
		{
			gMMI_ctl.driverCtl.keyDownState = state;
		}
		stateBitMask = 1L << (gMMI_ctl.driverCtl.keyDownState);
	}
	else
	{
		if(MMI_KEY_MAP_MAPPING_BY_KEY_DOWN_STATE_FEAT)
		{
			if(keyAction != KEY_DOWN)
				state = gMMI_ctl.driverCtl.keyDownState;
		}
		stateBitMask = 1L << state;
	}

	//REMARK: ONLY TOP handler can handle KEY_EVENT
	for (keyEventInd = MMI_KeyEvtMap[keyAction].keyEventStartIndex; keyEventInd < (MMI_KeyEvtMap[keyAction].keyEventNo+MMI_KeyEvtMap[keyAction].keyEventStartIndex); keyEventInd++)
	{
		if (((keyIndex == gMMI_nvram_keymap.mmiKeyMapTbl[keyEventInd].keyCode) ||
			(gMMI_nvram_keymap.mmiKeyMapTbl[keyEventInd].keyCode == KEYALL))&&
			((stateBitMask & gMMI_nvram_keymap.mmiKeyMapTbl[keyEventInd].keySuppotedState)))
		{
			return gMMI_nvram_keymap.mmiKeyMapTbl[keyEventInd].mmiKeyEvent;
		}
	}
	return KEY_INVALID;
}

PUBLIC U16 MMI_DRV_CheckKeyValid(U16 keyCode)
{
	U8 index;

	if(MMI_DRV_IsKeyInvalidPwOnLowBat())
	{
		if(keyCode != KEY_POWER_OFF && keyCode != KEY_RESET)
			return KEY_INVALID;
	}

	switch(keyCode)
	{
		case KEY_POWER_ON_THEN_ENTERDISCOVERABLE:
		case KEY_POWER_ON:
		case KEY_RESET_PAIRED_DEVICES:
		case KEY_CHECK_BATTERY_STATUS:
		case KEY_RESET:
		case KEY_VOICE_PROMPT_TOGGLE:
		case KEY_VOICE_PROMPT_DISABLE:
		case KEY_VOICE_PROMPT_ENABLE:
		case KEY_VOICE_PROMPT_LANG_CHANGE:
		case KEY_VOICE_PROMPT_LANG_SELECT:
		case KEY_VOICE_PROMPT_LANG_CONFIRM:
		case KEY_TOGGLE_LED:
		case KEY_ENABLE_LED:
		case KEY_DISABLE_LED:
		case KEY_CANCEL_LED_INDICATION:
		case KEY_TOGGLE_VOLUME:
		case KEY_VOLUME_ORIENTATION_NORMAL:
		case KEY_VOLUME_ORIENTATION_INVERT:
		case KEY_BUZZER_MUTE_TOGGLE:
		case KEY_ENTER_TESTMODE:
		case KEY_MAX_DEVICE_ALLOWED_UP:
		case KEY_MAX_DEVICE_ALLOWED_DOWN:
		case KEY_MAX_DEVICE_ALLOWED_TOGGLE:
		case KEY_DEBUG_KEY_TOGGLE:
		case KEY_BUTTONLOCKTOGGLE:
		case KEY_POWER_OFF:
			break;

		default:
			if(MMI_KEY_STATE_POWER_OFF == MMI_GetKeyState())
				keyCode = KEY_INVALID;
			break;
	}

	if(keyCode == KEY_INVALID)
		return keyCode;

	index = MMI_DRV_GetKeyEventIndex(keyCode);
	switch(MMI_DRV_GetKeyEventGroup(keyCode))
	{
		case SYSTEM_KEY_EVENT:
			keyCode = MMI_DRV_CheckValidKey(index, keyCode);
			break;
		#ifdef AIR_MODULE
		case AIR_KEY_EVENT:
			keyCode = MMI_AIR_CheckValidKey(index, keyCode);
			break;
		#endif
		case HFP_KEY_EVENT:
			#ifdef AIR_MODULE
			if(!MMI_AIR_CheckHFPKeyValid())
				return KEY_INVALID;
			#endif
			#ifdef HFP_Profile
			keyCode = MMI_HFP_CheckValidKey(index, keyCode);
			#else
			keyCode = KEY_INVALID;
			#endif
			break;
		case AVRCP_KEY_EVENT:
			#ifdef AIR_MODULE
			if(!MMI_AIR_CheckAVRCPKeyValid(keyCode))
				return KEY_INVALID;
			#endif
			#ifdef AVRCP_Profile

			#else
			keyCode = KEY_INVALID;
			#endif
			break;
		case FM_KEY_EVENT:
			#ifdef FM_ENABLE
			keyCode = MMI_FM_CheckValidKey(index, keyCode);
			#else
			keyCode = KEY_INVALID;
			#endif
			break;
		case LINE_IN_KEY_EVENT:
			#ifdef LINEIN_ENABLE
			keyCode = MMI_LineIn_CheckValidKey(index, keyCode);
			#else
			keyCode = KEY_INVALID;
			#endif
			break;
		case TESTMODE_KEY_EVENT:

			break;
	}
	return keyCode;
}


PRIVATE void MMI_DRV_CheckResetPairedDevice(U16 eventCode)
{
	if(eventCode != MEDIA_EVT_KEY_RESET_PAIRED_DEVICES)
		return;

	gMMI_ctl.driverCtl.resetPairedDeviceMediaCount --;
	if(!gMMI_ctl.driverCtl.resetPairedDeviceMediaCount && CURRENT_ACTIVE_LINK_CNT == 0)
	{
		U8 i;
		MMI_SECTOR_ResetPairedDevices();
		i = OSMQ_Entries(OSMQ_MMI_Internal_ptr);
		while(i--)
		{
			MMIMsgType XDATA_PTR msgPtr = (MMIMsgType XDATA_PTR)OSMQ_Get (OSMQ_MMI_Internal_ptr);
			if(msgPtr->eventCode == MMI_RESET_PAIRED_DEVICE_CMD)
				OSMEM_Put((U8 XDATA_PTR)msgPtr);
			else
				OSMQ_Put(OSMQ_MMI_Internal_ptr, (U8 XDATA_PTR)msgPtr);
		}
	}
}

PRIVATE void _SetMicMuteByLink(U8 muteCmd)//Mantis 8599 - avoid Warning C183 : Dead Assignment Eliminated
{
	U8 i;
	for(i = 0; i < MAX_MULTI_POINT_NO; i++)
	{
		MMI_DRV_SetMicMuteByLink(muteCmd, i);
	}
}

PUBLIC void MMI_DRV_MicMuteHandler(U8 linkIndex, U8 muteCmd)
{
	MMI_DRV_SetMicMuteByLink(muteCmd, linkIndex);

	if (MMI_ENABLE_SYNC_MUTE_MIC_TO_ALL_LINK_FEAT)
	{
		_SetMicMuteByLink(muteCmd);
	}

	if(muteCmd == TOGGLE_MUTE_ON_OFF)
	{
		if (gMMI_ctl.mmiInfo[linkIndex].linkPara.isMicMute)
		{
			MMI_PushMediaEvent(MEDIA_EVT_KEY_MIC_MUTE_ON);
		}
		else
		{
			MMI_PushMediaEvent(MEDIA_EVT_KEY_MIC_MUTE_OFF);
		}
	}
}

#ifdef A2DP_Profile
PRIVATE void MMI_DRV_MicVolA2DPHandler(U8 linkIndex, U16 keyCode)
{

	BOOL isVolumeUp;
	U8 vgm;

	if (keyCode == KEY_MICUP)
		isVolumeUp = TRUE;
	else
		isVolumeUp = FALSE;

	gMMI_ctl.isMicAdjsutInA2DP = TRUE;
	gMMI_ctl.linkIndexMicCtlInA2DP = linkIndex;
	vgm=CURRENT_MIC_SOUND_LEVEL_IN_A2DP(linkIndex);

	if (isVolumeUp)
	{
		if (vgm < (MMI_MAX_MUSIC_SOUND_LEVEL()))
		{
			vgm++;
		}
		else if(MMI_CYCLIC_VOLUME_ENABLED_FEAT)
		{
			vgm = 0;
		}
	}
	else
	{
		if (vgm > 1)
		{
			vgm--;
		}
		else if(MMI_CYCLIC_VOLUME_ENABLED_FEAT)
		{
			vgm = (MMI_MAX_MUSIC_SOUND_LEVEL());
		}
	}

	CURRENT_MIC_SOUND_LEVEL_IN_A2DP(linkIndex) = vgm;
	MMI_A2DP_SendDriverVolCmd( vgm, 0/*CURRENT_A2DP_SMALL_STEP(linkIndex)*/);

}
#endif

PRIVATE void MMI_DRV_MicVolSCOHandler(U8 linkIndex, U16 keyCode)
{
	BOOL isVolumeUp;
	U8 vgm;
	#ifdef HFP_Profile
	U8 tempGainIndex;
	#endif

	if( keyCode == KEY_MICUP )
		isVolumeUp = TRUE;
	else
		isVolumeUp = FALSE;

	//Reversed Volume Control
	isVolumeUp = (gMMI_driver_variation_nvram.misc_para.init.isMiscEnabled & IS_VOLUME_ORIENTATION_REVERSED) ? !isVolumeUp : isVolumeUp;

	#ifdef HFP_Profile
	if(gMMI_HFP_ctl.HfpCtl[linkIndex].sendingVGSVGM)
		return;
	#endif

	vgm = CURRENT_SCO_VGM(linkIndex);
	#ifdef HFP_Profile
	tempGainIndex = vgm;
	#endif

	if (isVolumeUp)
	{
		if (vgm < (SOUND_LEVEL_NO-1))
		{
			vgm++;
		}
		else if(MMI_CYCLIC_VOLUME_ENABLED_FEAT)
		{
			vgm = 0;
		}
	}
	else
	{
	 	if (vgm > 0)
		{
			vgm--;
		}
		else if(MMI_CYCLIC_VOLUME_ENABLED_FEAT)
		{
			vgm = (SOUND_LEVEL_NO-1);
		}
	}
	CURRENT_SCO_VGM(linkIndex) = vgm;
	#ifdef HFP_Profile
	if(MMI_SendATCmdUnderConnection(linkIndex, HFP_ATCMD_ADJUST_MIC_GAIN))
	{
		//Send VGM
		CURRENT_SCO_VGM(linkIndex) = tempGainIndex;
	}
	else
	#endif
	{
		//Notify driver
		MMI_DRV_SendDriverVolCmd(linkIndex, VOLUME_DONT_CARE, VOLUME_DONT_CARE, GET_SCO_MIC_GAIN_BY_VGM(vgm));
	}
}

#ifdef LINEIN_ENABLE
extern MmiLineInInfoCtrl XDATA gMMI_LineIn_ctl;
#endif

PUBLIC void MMI_DRV_SetMicSoundLevelInA2DP(U8 soundLevel)
{
	U8 linkIndex;
	for(linkIndex = 0; linkIndex < MAX_MULTI_POINT_NO; linkIndex++)
	{
		CURRENT_MIC_SOUND_LEVEL_IN_A2DP(linkIndex) = soundLevel;
	}
}

PUBLIC void MMI_DRV_MicVolHandler(U8 linkIndex, U16 keyCode)
{
	#ifdef A2DP_Profile
	if(MUSIC_EXISTS(linkIndex))
	{
		MMI_DRV_MicVolA2DPHandler(linkIndex, keyCode);

		#ifdef LINEIN_ENABLE
		if(gMMI_ctl.isAudioTransparencyEnable)
		{
			gMMI_LineIn_ctl.currentsoundLevel = CURRENT_MIC_SOUND_LEVEL_IN_A2DP(linkIndex);
			LightDbgPrint("line-in[%d]",gMMI_LineIn_ctl.currentsoundLevel);
			LightDbgPrint("A2DP[%d]",CURRENT_MIC_SOUND_LEVEL_IN_A2DP(linkIndex));
		}
		#endif
	}
	else
	#endif
	{
		if(MMI_DRV_IsActiveAudioDevInCall())
		{
			MMI_DRV_MicVolSCOHandler(linkIndex, keyCode);
			MMI_PushMediaEvent(MEDIA_EVT_MIC_UPDN);
		}
		else
		{
			#ifdef LINEIN_ENABLE
			if(gMMI_ctl.isAudioTransparencyEnable)
			{
				BOOL isVolumeUp;
				if(keyCode==KEY_MICUP)
				{
					isVolumeUp=TRUE;
				}
				else
				{
					isVolumeUp=FALSE;
				}

				MMI_LineIn_VolumeControl(isVolumeUp);

				MMI_DRV_SetMicSoundLevelInA2DP(gMMI_LineIn_ctl.currentsoundLevel);
				LightDbgPrint("line-in[%d]",gMMI_LineIn_ctl.currentsoundLevel);
				LightDbgPrint("A2DP[%d]",CURRENT_MIC_SOUND_LEVEL_IN_A2DP(linkIndex));
			}
			#endif
		}
	}
	//MMI_PushMediaEvent(MEDIA_EVT_MIC_UPDN);
}

extern PUBLIC void DRIVER_SetMicMuteUnMute(BOOL isMute);
PUBLIC void MMI_DRV_SetMicMuteByLink(U8 muteCmd, U8 linkIndex)
{
	if(muteCmd == SET_MUTE_ON)
	{
		gMMI_ctl.mmiInfo[linkIndex].linkPara.isMicMute = TRUE;
	}
	else if(muteCmd== SET_MUTE_OFF )
	{
		gMMI_ctl.mmiInfo[linkIndex].linkPara.isMicMute = FALSE;
	}
	else if(muteCmd== TOGGLE_MUTE_ON_OFF )
	{
		gMMI_ctl.mmiInfo[linkIndex].linkPara.isMicMute = !gMMI_ctl.mmiInfo[linkIndex].linkPara.isMicMute;
	}

	if(MMI_MUTE_SPEAKER_AS_MICROPHONE_FEAT)
		gMMI_ctl.mmiInfo[linkIndex].linkPara.isSpkMuteForMicMute = gMMI_ctl.mmiInfo[linkIndex].linkPara.isMicMute;

	DRIVER_SetMicMuteUnMute(gMMI_ctl.mmiInfo[linkIndex].linkPara.isMicMute);
}

PUBLIC void MMI_DRV_AutoMICMuteOff(U8 linkIndex)
{
	if(gMMI_ctl.mmiInfo[linkIndex].linkPara.isMicMute)
	{
		MMI_PushMediaEvent(MEDIA_EVT_KEY_MIC_MUTE_OFF);
		MMI_DRV_MicMuteHandler(linkIndex, SET_MUTE_OFF);
	}
}

extern PUBLIC void DRIVER_SetInbandSCOMuteUnMute(BOOL isMute);
PUBLIC void MMI_DRV_SetSpkMuteByLink(U8 muteCmd, U8 linkIndex)
{
	if(muteCmd == SET_MUTE_ON)
	{
		gMMI_ctl.mmiInfo[linkIndex].linkPara.isSpkMuteForSCO = TRUE;
	}
	else if(muteCmd== SET_MUTE_OFF )
	{
		gMMI_ctl.mmiInfo[linkIndex].linkPara.isSpkMuteForSCO = FALSE;
	}
	else if(muteCmd== TOGGLE_MUTE_ON_OFF )
	{
		gMMI_ctl.mmiInfo[linkIndex].linkPara.isSpkMuteForSCO = !gMMI_ctl.mmiInfo[linkIndex].linkPara.isSpkMuteForSCO;
	}
	DRIVER_SetInbandSCOMuteUnMute(gMMI_ctl.mmiInfo[linkIndex].linkPara.isSpkMuteForSCO);
}

PUBLIC BOOL MMI_DRV_IsMicMute(U8 linkIndex)
{
	return (linkIndex < MAX_MULTI_POINT_NO) ? gMMI_ctl.mmiInfo[linkIndex].linkPara.isMicMute : FALSE;
}

PUBLIC BOOL MMI_DRV_IsSpeakerMuteByLink(U8 linkIndex)
{
	return (linkIndex < MAX_MULTI_POINT_NO) ? (gMMI_ctl.mmiInfo[linkIndex].linkPara.isSpkMuteForMicMute || gMMI_ctl.mmiInfo[linkIndex].linkPara.isSpkMuteForSCO) : FALSE;
}

PUBLIC BOOL MMI_DRV_IsSpeakerMute(void)
{
	U8 linkIndex;
	for(linkIndex = 0; linkIndex < MAX_MULTI_POINT_NO; linkIndex++)
	{
		if(MMI_DRV_IsSpeakerMuteByLink(linkIndex))
			return TRUE;
	}
	return FALSE;
}

PUBLIC BOOL MMI_DRV_A2DPDSPEnable(void)
{
	return (gMMI_ctl.audioableA2DPLink == MMI_EOF)? FALSE: TRUE;
}

PUBLIC U8 MMI_DRV_GetA2DPEnabledLinkIndex(void)
{
	return gMMI_ctl.audioableA2DPLink;
}

#ifdef SUPPORT_VOICE_COMMAND
PUBLIC void MMI_DRV_SendVoiceCommandCmd(U16 mediaEvent)
{
	U8 i, actionIndex;
	MMIMsgType XDATA_PTR msgPtr;

	if(APD_VC_IDENTIFY != (((DRIVER_VOICE_COMMAND_APD_DATA_TYPE CODE_PTR)GET_SECTOR_BOUNDARY_ADDR(SECTOR_VOICE_COMMAND_APD_DATA))->vcMode))
	{

		for(i = 0; i < TOTAL_VOICE_COMMAND_EVENTS; i++)
		{
			if(((DRIVER_VOICE_COMMAND_DATA_TYPE CODE_PTR)GET_SECTOR_VOICE_DATA_ADDR(SECTOR_VOICE_COMMAND_DATA))->vcEventTable[i].mediaEvent == mediaEvent)
			{
				break;
			}
		}
		if(i == TOTAL_VOICE_COMMAND_EVENTS)
			return;

		if(!((0x1L << MMI_GetTopStateByLink(gMMI_ctl.serviceInd)) &
		((DRIVER_VOICE_COMMAND_DATA_TYPE CODE_PTR)GET_SECTOR_VOICE_DATA_ADDR(SECTOR_VOICE_COMMAND_DATA))->vcEventTable[i].triggeredState))
		{
			return;
		}

		actionIndex = ((DRIVER_VOICE_COMMAND_DATA_TYPE CODE_PTR)GET_SECTOR_VOICE_DATA_ADDR(SECTOR_VOICE_COMMAND_DATA))->vcEventTable[i].actionIndex;
		if(actionIndex >= ((DRIVER_VOICE_COMMAND_DATA_TYPE CODE_PTR)GET_SECTOR_VOICE_DATA_ADDR(SECTOR_VOICE_COMMAND_DATA))->actionPatternNo)
			return;
	}
	else
	{
		LightDbgPrint("VC APD mode %d", (U8) (((DRIVER_VOICE_COMMAND_APD_DATA_TYPE CODE_PTR)GET_SECTOR_BOUNDARY_ADDR(SECTOR_VOICE_COMMAND_APD_DATA))->vcMode));

		for(i = 0; i < TOTAL_APD_VOICE_COMMAND_EVENTS; i++)
		{
			if(((DRIVER_VOICE_COMMAND_APD_DATA_TYPE CODE_PTR)GET_SECTOR_BOUNDARY_ADDR(SECTOR_VOICE_COMMAND_APD_DATA))->vcEventTable[i].mediaEvent == mediaEvent)
			{
				break;
			}
		}
		if(i == TOTAL_APD_VOICE_COMMAND_EVENTS)
			return;

		if(!((0x1L << MMI_GetTopStateByLink(gMMI_ctl.serviceInd)) &
		((DRIVER_VOICE_COMMAND_APD_DATA_TYPE CODE_PTR)GET_SECTOR_BOUNDARY_ADDR(SECTOR_VOICE_COMMAND_APD_DATA))->vcEventTable[i].triggeredState))
		{
			return;
		}

		actionIndex = ((DRIVER_VOICE_COMMAND_APD_DATA_TYPE CODE_PTR)GET_SECTOR_BOUNDARY_ADDR(SECTOR_VOICE_COMMAND_APD_DATA))->vcEventTable[i].actionIndex;

		LightDbgPrint("action index %d", (U8)actionIndex);


		if(actionIndex >= ((DRIVER_VOICE_COMMAND_APD_DATA_TYPE CODE_PTR)GET_SECTOR_BOUNDARY_ADDR(SECTOR_VOICE_COMMAND_APD_DATA))->actionPatternNo)
			return;
	}

	MMI_SetVoiceCommandVol();
	MMI_DRV_SetVoiceCommandTimer(mediaEvent);

	msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_VOICE_COMMAND_CMD);
	if(msgPtr)
	{
		msgPtr->msgBodyPtr.driverCmd.vcCmd.id = mediaEvent;
		msgPtr->msgBodyPtr.driverCmd.vcCmd.actionIndex = actionIndex;
		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
	}
}

PUBLIC void MMI_DRV_SendStopVoiceCommandCmd(void)
{
	DRIVER_SendStopVoiceCommandCmd();
}

PRIVATE U16 MMI_DRV_LookUpKeyMapTable(U16 keyEvent)
{
	U8 i;

	for(i = 0; i < MAX_KEY_ACTION_NUM; i++)
	{
		if(gMMI_nvram_keymap.mmiKeyMapTbl[i].mmiKeyEvent == keyEvent)
		{
			if((1L << MMI_GetTopStateByLink(gMMI_ctl.serviceInd)) & gMMI_nvram_keymap.mmiKeyMapTbl[i].keySuppotedState)
				return keyEvent;
			else
				return KEY_INVALID;
		}
	}
	return keyEvent; //this key event is not found on key map table
}
#endif

PRIVATE void MMI_DRV_KeyReconnectUserInit(U8 linkIndex)
{
	UNUSED(linkIndex);
	MMI_Reconnect(RECONNECT_USER_INIT);
}

PUBLIC void MMI_DRV_RejectCallMuteSCOCmd(BOOL value)
{
	DRIVER_RejectCallMuteSCOCmd(value);
}

PRIVATE void MMI_DRV_KeyDiscoverable(U8 linkIndex)
{
	UNUSED(linkIndex);

	// Assume that user doesnt want to recoonect to phone
	MMI_CancelCreateAcl();
	MMI_Reconnect_ClearCtl();

	MMI_InsertState(MMI_EOF, MMI_CONDISCABLE, MMI_CONNECTABLE);
}

PRIVATE void MMI_DRV_KeyNonDiscoverable(U8 linkIndex)
{
	UNUSED(linkIndex);
	MMI_SetEnterDiscoverable(FALSE);
	if(MMI_CheckNestState(MMI_EOF, MMI_CONDISCABLE))
	{
		MMI_RmvState(MMI_EOF, MMI_CONDISCABLE);
	}
}

PRIVATE void MMI_DRV_KeyConnectedToDiscoverable(U8 linkIndex)
{
	UNUSED(linkIndex);
	MMI_CancelCreateAcl();
	MMI_Reconnect_ClearCtl();
	MMI_ReleaseMultiLink();
	if(!gMMI_ctl.activeLinkRecord)
	{
		MMI_SetEnterDiscoverable(TRUE);
	}
	else
	{
		MMI_SetEnterDiscoverableAfterDisc(TRUE);
	}
}

PRIVATE void MMI_DRV_KeyConnectedToConnectable(U8 linkIndex)
{
	UNUSED(linkIndex);
	MMI_CancelCreateAcl();
	MMI_Reconnect_ClearCtl();
	MMI_ReleaseMultiLink();
}

PRIVATE void _NFCDetachSetTimer(void)//Mantis 8599 - avoid Warning C183 : Dead Assignment Eliminated
{
	U8 i;
	for(i = 0; i < MAX_MULTI_POINT_NO; i++)
	{
		if(MMI_IsActiveLink(i))
		{
			SYS_SetTimer(&gMMI_ctl.mmiTimerInfo.connTimer[i].nfcDetachIfNoProfileTimer,3*ONE_SEC);
		}
	}
}

PRIVATE void MMI_DRV_KeyNFCDiscoverable(U8 linkIndex)
{
	UNUSED(linkIndex);
	if(gMMI_ctl.activeLinkRecord)
	{
		_NFCDetachSetTimer();
	}
	MMI_InsertState(MMI_EOF, MMI_CONDISCABLE, MMI_CONNECTABLE);
}

PRIVATE void MMI_DRV_KeyConfirmationAccept(U8 linkIndex)
{
	MMI_HCI_SendConfirmationReply(TRUE, &gMMI_ctl.mmiInfo[linkIndex].bdAddr[0]);
}

PRIVATE void MMI_DRV_KeyConfirmationReject(U8 linkIndex)
{
	MMI_HCI_SendConfirmationReply(FALSE, &gMMI_ctl.mmiInfo[linkIndex].bdAddr[0]);
}

PRIVATE void MMI_DRV_KeyDbgKeyToggle(U8 linkIndex)
{
	UNUSED(linkIndex);
	gMMI_ctl.driverCtl.dbgPrivateKey = ~gMMI_ctl.driverCtl.dbgPrivateKey;
	MMI_HCI_SendWriteSimplePairingDebugMode(gMMI_ctl.driverCtl.dbgPrivateKey);
}

PRIVATE void MMI_DRV_KeyVoiceUp(U8 linkIndex)
{
	MMI_DRV_VoiceAdjustment(linkIndex, KEY_VOICEUP, FALSE);
}

PRIVATE void MMI_DRV_KeyVoiceDown(U8 linkIndex)
{
	MMI_DRV_VoiceAdjustment(linkIndex, KEY_VOICEDN, FALSE);
}

PRIVATE void MMI_DRV_KeyCheckBatteryStatus(U8 linkIndex)
{
	UNUSED(linkIndex);
	MMI_CHGBAT_BatteryCheckPoint();
}

PRIVATE void MMI_DRV_KeyBuzzerMuteToggle(U8 linkIndex)
{
	UNUSED(linkIndex);
}

PRIVATE void MMI_DRV_KeyToggleVolume(U8 linkIndex)
{
	UNUSED(linkIndex);
	gMMI_driver_variation_nvram.misc_para.init.isMiscEnabled ^= IS_VOLUME_ORIENTATION_REVERSED;
	MMI_SECTOR_SetUpdateFlag(TRUE);
}

PRIVATE void MMI_DRV_KeyVolOrientationNormal(U8 linkIndex)
{
	UNUSED(linkIndex);
	gMMI_driver_variation_nvram.misc_para.init.isMiscEnabled &= ~(IS_VOLUME_ORIENTATION_REVERSED);
	MMI_SECTOR_SetUpdateFlag(TRUE);
}

PRIVATE void MMI_DRV_KeyVolOrientationInvert(U8 linkIndex)
{
	UNUSED(linkIndex);
	gMMI_driver_variation_nvram.misc_para.init.isMiscEnabled |= IS_VOLUME_ORIENTATION_REVERSED;
	MMI_SECTOR_SetUpdateFlag(TRUE);
}


PRIVATE void MMI_DRV_KeyToggleLED(U8 linkIndex)
{
	UNUSED(linkIndex);
	MMI_LED_KeyOnOffHandler(TOGGLE_LED);
}

PRIVATE void MMI_DRV_KeyEnableLED(U8 linkIndex)
{
	UNUSED(linkIndex);
	MMI_LED_KeyOnOffHandler(ENABLE_LED);
}

PRIVATE void MMI_DRV_KeyDisableLED(U8 linkIndex)
{
	UNUSED(linkIndex);
	MMI_LED_KeyOnOffHandler(DISABLE_LED);
}

PRIVATE void MMI_DRV_KeyCancelLEDIndication(U8 linkIndex)
{
	UNUSED(linkIndex);
	DRIVER_Cmd_LED_Restart(DRIVER_CMD_LED_RESTART_PARA_ONLY_FG);
}

PRIVATE void MMI_DRV_KeyMediaTrigger(U8 linkIndex)
{
	#ifdef SUPPORT_VOICE_PROMPT
	if (MMI_HFP_INCOMMING == MMI_GetTopStateByLink(linkIndex))
		MMI_DRV_SpecificEventVPStopCmd(MEDIA_EVT_ENTER_INCOMING);
	#else
	UNUSED(linkIndex);
	#endif
}

PRIVATE void MMI_DRV_KeyPowerOnDiscoverable(U8 linkIndex)
{
	UNUSED(linkIndex);
	MMI_SetEnterDiscoverable(TRUE);
	if(MMI_GetKeyState() == MMI_KEY_STATE_NONE)
	{
		MMI_PowerOnLoader();
	}
}

PRIVATE void MMI_DRV_KeyPowerOn(U8 linkIndex)
{
	UNUSED(linkIndex);
	if(MMI_GetKeyState() == MMI_KEY_STATE_NONE)
	{
		MMI_PowerOnLoader();
		#ifdef OLED_ENABLE
		OLED_DisplayOn(OLED_SHOW_START);
		#endif

		if(gMMI_driver_variation_nvram.misc_para.init.isMiscEnabled & IS_MP_TEST_MODE_ENABLE)
		{
			MMI_AddTopState(gMMI_ctl.serviceInd,MMI_MP_STATE);
			gMMI_ctl.currentSupportDeviceNo = 1;
			gMMI_nvram.timerCtl.PairModeTimeout = 0;
			gMMI_nvram.timerCtl.PairModeTimeoutIfPDLIsEmpty = 0;
			MMI_HCI_SendEnableDeviceUnderTestMode();
			MMI_SetEnterDiscoverable(TRUE);
		}
	}
}

PRIVATE void MMI_DRV_KeyPowerOff(U8 linkIndex)
{
	UNUSED(linkIndex);
	MMI_PowerOffHandler(POWEROFF_REASON_KEY);
	#ifdef OLED_ENABLE
	OLED_DisplayOff();
	#endif
}

PRIVATE void MMI_DRV_KeyReset(U8 linkIndex)
{
	U8 i;

	UNUSED(linkIndex);
	for(i = 0; i < MAX_MULTI_POINT_NO; i++)
	{
		MMI_ReleaseProfileLinkAndDetach(i);
	}
	PMU_SYS_SET_BOOT_SW_STATUS_B1 (0);
	MMI_LinkKey_ClearConnectedFlag();
	MMI_DRV_SetReset(TRUE);
}

PRIVATE void MMI_DRV_KeyResetPairedDevices(U8 linkIndex)
{
	UNUSED(linkIndex);
	MMI_CancelCreateAcl();
	MMI_Reconnect_ClearCtl();
	MMI_ReleaseMultiLink();

	if(gMMI_driver_variation_nvram.misc_para.init.isMiscEnabled & IS_MP_TEST_MODE_ENABLE)
	{
		gMMI_driver_variation_nvram.misc_para.init.isMiscEnabled &= ~IS_MP_TEST_MODE_ENABLE;
		gMMI_ctl.driverCtl.resetLinkType = 0x3;
	}
	else if(!gMMI_ctl.driverCtl.resetLinkType)
		gMMI_ctl.driverCtl.resetLinkType = 0xFF;

	MMI_SendInternalCmdToMMI(MMI_RESET_PAIRED_DEVICE_CMD);
}

PRIVATE void MMI_DRV_KeyMaxDeviceAllowUp(U8 linkIndex)
{
	UNUSED(linkIndex);
	if (gMMI_ctl.currentSupportDeviceNo < MMI_MAX_PAGE_DEVICE)
	{
		gMMI_ctl.currentSupportDeviceNo++;
		gMMI_driver_variation_nvram.misc_para.init.isMiscEnabled |= IS_MULTIPOINTS_ENABLE;
		MMI_SECTOR_SetUpdateFlag(TRUE);
	}
}

PRIVATE void MMI_DRV_KeyMaxDeviceAllowDown(U8 linkIndex)
{
	UNUSED(linkIndex);
	if (gMMI_ctl.currentSupportDeviceNo > 1)
	{
		gMMI_ctl.currentSupportDeviceNo--;
		gMMI_driver_variation_nvram.misc_para.init.isMiscEnabled &= (~IS_MULTIPOINTS_ENABLE);
		MMI_SECTOR_SetUpdateFlag(TRUE);
	}
}

PRIVATE void MMI_DRV_KeyMaxDeviceAllowToggle(U8 linkIndex)
{
	UNUSED(linkIndex);
	if (gMMI_ctl.currentSupportDeviceNo < MMI_MAX_PAGE_DEVICE)
	{
		gMMI_ctl.currentSupportDeviceNo ++;
		gMMI_driver_variation_nvram.misc_para.init.isMiscEnabled |= IS_MULTIPOINTS_ENABLE;
		MMI_SECTOR_SetUpdateFlag(TRUE);
		MMI_PushMediaEvent(MEDIA_EVT_KEY_MAX_DEVICE_ALLOWED_UP);
	}
	else
	{
		gMMI_ctl.currentSupportDeviceNo = 1;
		gMMI_driver_variation_nvram.misc_para.init.isMiscEnabled &= (~IS_MULTIPOINTS_ENABLE);
		MMI_SECTOR_SetUpdateFlag(TRUE);
		MMI_PushMediaEvent(MEDIA_EVT_KEY_MAX_DEVICE_ALLOWED_DOWN);
	}
}

PRIVATE void MMI_DRV_KeyReconnectAfterPowerOn(U8 linkIndex)
{
	UNUSED(linkIndex);
	MMI_Reconnect(RECONNECT_PWR_ON);
}

PRIVATE void MMI_DRV_KeyVoicePromptToggle(U8 linkIndex)
{
	if(MMI_DRV_IsVoicePromptEnabled())
	{
		MMI_DRV_DisableVoicePrompt();
		MMI_PushMediaEvent(MEDIA_EVT_KEY_VOICE_PROMPT_DISABLE);
	}
	else
	{
		MMI_DRV_EnableVoicePrompt();
		MMI_PushMediaEvent(MEDIA_EVT_KEY_VOICE_PROMPT_ENABLE);
	}
	UNUSED(linkIndex);
}

PRIVATE void MMI_DRV_KeyVoicePromptEnable(U8 linkIndex)
{
	UNUSED(linkIndex);
	MMI_DRV_EnableVoicePrompt();
}

PRIVATE void MMI_DRV_KeyVoicePromptDisable(U8 linkIndex)
{
	UNUSED(linkIndex);
	MMI_DRV_DisableVoicePrompt();
}

#ifdef SUPPORT_VOICE_PROMPT
PRIVATE void MMI_DRV_KeyVoicePromptLanChange(U8 linkIndex)
{
	#ifdef TWS_SETTINGS
	U8 vplangIndex;
	#endif

	UNUSED(linkIndex);
	gMMI_driver_variation_nvram.misc_para.init.vpLangIndex++;
	if(gMMI_driver_variation_nvram.misc_para.init.vpLangIndex >= gMMI_nvram.vpConfig.LangCount)
		gMMI_driver_variation_nvram.misc_para.init.vpLangIndex = 0;

	#ifdef TWS_SETTINGS
	vplangIndex = gMMI_driver_variation_nvram.misc_para.init.vpLangIndex;
	#endif

	MMI_DRV_LoadVoiceLangCtl(gMMI_driver_variation_nvram.misc_para.init.vpLangIndex);
	MMI_PushMediaEvent(MEDIA_EVT_VOICE_PROMPT_LANG_CHANGE);
	MMI_SECTOR_SetUpdateFlag(TRUE);

	#ifdef TWS_SETTINGS
		MMI_AIR_AiroStereo_Sync(AIR_APP_SYNC_SHARE_VP_LANG_INDEX_AND_CHANG_NEXT,vplangIndex);
	#endif
}

PRIVATE void MMI_DRV_KeyVoicePromptLanSel(U8 linkIndex)
{
	if(MMI_CONDISCABLE == MMI_GetTopStateByLink(linkIndex))
	{
		MMI_AddTopState(MMI_EOF, MMI_VOICE_PROMPT_LANG_SELECT);
	}
}

PRIVATE void MMI_DRV_KeyVoicePromptLanCfm(U8 linkIndex)
{
	if(MMI_VOICE_PROMPT_LANG_SELECT == MMI_GetTopStateByLink(linkIndex))
	{
		gMMI_ctl.vpRuntime.vpLangStatus |= VP_STATUS_LANG_CONFIRM;
		MMI_RmvState(MMI_EOF, MMI_VOICE_PROMPT_LANG_SELECT);
	}
}
#endif

PRIVATE void MMI_DRV_KeyButtonLockOn(U8 linkIndex)
{
	UNUSED(linkIndex);
	MMI_DRV_SetButtonLock(TRUE);
}

PRIVATE void MMI_DRV_KeyButtonLockOff(U8 linkIndex)
{
	UNUSED(linkIndex);
	MMI_DRV_SetButtonLock(FALSE);
}

PRIVATE void MMI_DRV_KeyButtonLockToggle(U8 linkIndex)
{
	UNUSED(linkIndex);
	if (MMI_DRV_IsButtonLocked())
	{
		MMI_DRV_SetButtonLock(FALSE);
		MMI_PushMediaEvent(MEDIA_EVT_KEY_BUTTONLOCKOFF);
	}
	else
	{
		MMI_DRV_SetButtonLock(TRUE);
		MMI_PushMediaEvent(MEDIA_EVT_KEY_BUTTONLOCKON);
	}
}

PRIVATE void MMI_DRV_KeyMicUp(U8 linkIndex)
{
	#ifdef AIR_MODULE
	if(gMMI_ctl.isAudioTransparencyEnable)
	{
		U8 airlink;
		if((airlink = MMI_AIR_GetAirLink(PRODUCT_AIR_TWS)) != MMI_EOF && (A2DP_IsLinkFollower(airlink) || A2DP_IsLinkRelayer(airlink)))
		{
			if(MMI_DRV_IsActiveAudioDevInMusic())
			{
				MMI_AVRCP_SendVendorUnique(airlink, AVRCP_VENDOR_UNIQ_SYNC_MIC_VOL_AND_UP, CURRENT_MIC_SOUND_LEVEL_IN_A2DP(linkIndex));
			}
			else
			{
				MMI_AVRCP_SendVendorUnique(airlink, AVRCP_VENDOR_UNIQ_SYNC_MIC_VOL_AND_UP, gMMI_LineIn_ctl.currentsoundLevel);
			}
		}
	}
	#endif

	MMI_DRV_MicVolHandler(linkIndex, KEY_MICUP);
}

PRIVATE void MMI_DRV_KeyMicDown(U8 linkIndex)
{
	#ifdef AIR_MODULE
	if(gMMI_ctl.isAudioTransparencyEnable && !MMI_DRV_IsActiveAudioDevInCall())
	{
		U8 airlink;
		if((airlink = MMI_AIR_GetAirLink(PRODUCT_AIR_TWS)) != MMI_EOF && (A2DP_IsLinkFollower(airlink) || A2DP_IsLinkRelayer(airlink)))
		{
			if(MMI_DRV_IsActiveAudioDevInMusic())
			{
				MMI_AVRCP_SendVendorUnique(airlink, AVRCP_VENDOR_UNIQ_SYNC_MIC_VOL_AND_DN, CURRENT_MIC_SOUND_LEVEL_IN_A2DP(linkIndex));
			}
			else
			{
				MMI_AVRCP_SendVendorUnique(airlink, AVRCP_VENDOR_UNIQ_SYNC_MIC_VOL_AND_DN, gMMI_LineIn_ctl.currentsoundLevel);
			}
		}
	}
	#endif
	MMI_DRV_MicVolHandler(linkIndex, KEY_MICDN);
}

PRIVATE void MMI_DRV_KeyMicMuteToggle(U8 linkIndex)
{
	MMI_DRV_MicMuteHandler(linkIndex, TOGGLE_MUTE_ON_OFF);
}

PRIVATE void MMI_DRV_KeyMicMuteOn(U8 linkIndex)
{
	UNUSED(linkIndex);
}

PRIVATE void MMI_DRV_KeyMicMuteOff(U8 linkIndex)
{
	UNUSED(linkIndex);
}

PRIVATE void MMI_DRV_KeySCOSwitch(U8 linkIndex)
{
	U8 i;

	for(i = 0; i < MAX_MULTI_POINT_NO; i++)
	{
		linkIndex = (linkIndex+i)&MAX_MULTI_POINT_NO;
		if(gMMI_ctl.audioDevCtl.registedDev[linkIndex] & ((1<<AUDIO_DEVICE_SCO)|(1<<AUDIO_DEVICE_SCO_HSP)|(1<<AUDIO_DEVICE_SCO_IDLE)))
		{
			MMI_DRV_SetSwitchingSCO(TRUE);
			MMI_SendDSPCmd(linkIndex, DSP_ENABLE_BY_SCO);
			return;
		}
	}
}

#ifdef TWS_SETTINGS
extern PUBLIC void MMI_Share_KeyChangePEQCmd(U8 linkIndex);
#endif
PRIVATE void MMI_DRV_KeyPEQModeChange(U8 linkIndex)
{
	UNUSED(linkIndex);
#ifdef PEQ_ENABLE
	#ifdef TWS_SETTINGS
	if(A2DP_IsLinkFollower(linkIndex))
	{
		MMI_Share_KeyChangePEQCmd(linkIndex);
	}
	else
	#endif
	{
		MMI_DRV_PEQModeChange();
	}
#endif
}

PRIVATE void MMI_DRV_KeyMultiPlayModeToggle(U8 linkIndex)
{
	UNUSED(linkIndex);
	MMI_FEATURE_CTL_A2DP ^= 0x0202;
	LightDbgPrint("USR - A2DP Feature:%X",(U32)MMI_FEATURE_CTL_A2DP);
}

PRIVATE void MMI_DRV_KeyCheckStatusOfConnection(U8 linkIndex)
{
	UNUSED(linkIndex);
	for(linkIndex = 0; linkIndex < MAX_MULTI_POINT_NO; linkIndex++)
	{
		if(MMI_GetConnectedProfileCount(linkIndex, TRUE))
		{
			MMI_PushMediaEvent(MEDIA_EVT_SLC_CONNECTED);
			return;
		}
	}
	MMI_PushMediaEvent(MEDIA_EVT_SLC_DISCONNECTED);
}

PRIVATE void MMI_DRV_KeyChangeSoundEffect(U8 linkIndex)
{
	MMIMsgType XDATA_PTR msgPtr;

	msgPtr = (MMIMsgType XDATA_PTR)OSMEM_Get(OSMEM_ptr1);

	if(msgPtr != (MMIMsgType XDATA_PTR)NULL)
	{
		msgPtr->msgOpcode  = DRIVER_CHANGE_SOUND_EFFECT_CMD;
		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
	}

	UNUSED(linkIndex);
}

PRIVATE void MMI_DRV_KeyControlDBBOnOff(U8 linkIndex)
{

	MMIMsgType XDATA_PTR msgPtr;

	msgPtr = (MMIMsgType XDATA_PTR)OSMEM_Get(OSMEM_ptr1);

	if(msgPtr != (MMIMsgType XDATA_PTR)NULL)
	{
		msgPtr->msgOpcode  = DRIVER_CONTROL_DBB_ON_OFF;
		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
	}

	UNUSED(linkIndex);
}

PRIVATE void MMI_DRV_EnableDUTModeCMD(U8 linkIndex)
{
	U8 i;
	UNUSED(linkIndex);
	OS_ENTER_CRITICAL ();
	i = PMU_SYS_GET_BOOT_SW_STATUS_B1 ();
	i |= SYS_SW1_BOOT_FLAG_ENTER_MP_TEST_MODE;
	PMU_SYS_SET_BOOT_SW_STATUS_B1 (i);
	OS_EXIT_CRITICAL ();

	for(i = 0; i < MAX_MULTI_POINT_NO; i++)
	{
		MMI_ReleaseProfileLinkAndDetach(i);
	}

	MMI_LinkKey_ClearConnectedFlag();
	MMI_DRV_SetReset(TRUE);
}

PRIVATE void MMI_DRV_KeyMicEnableL(U8 linkIndex)
{
	MMIMsgType XDATA_PTR msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_MIC_TEST_CMD);

	if(msgPtr != (MMIMsgType XDATA_PTR)NULL)
	{
		msgPtr->msgBodyPtr.driverCmd.micTestCmd.micEnableSet = DRIVER_MIC_ENABLE_L;
		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
	}
	UNUSED(linkIndex);
}
PRIVATE void MMI_DRV_KeyMicEnableR(U8 linkIndex)
{
	MMIMsgType XDATA_PTR msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_MIC_TEST_CMD);

	if(msgPtr != (MMIMsgType XDATA_PTR)NULL)
	{
		msgPtr->msgBodyPtr.driverCmd.micTestCmd.micEnableSet = DRIVER_MIC_ENABLE_R;
		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
	}
	UNUSED(linkIndex);
}

PRIVATE void MMI_DRV_KeyMicToSpkEnable(U8 linkIndex)
{
	MMIMsgType XDATA_PTR msgPtr;

	msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_LINE_IN_CMD);

	gAlignDSP.IC_BIST_MODE = 0;

	msgPtr->msgBodyPtr.driverCmd.auxCmd.m2d_ctl.para.linein_start_para.input_fs = 0x10;
	OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
	UNUSED(linkIndex);
}
PRIVATE void MMI_DRV_KeyMicToSpkDisable(U8 linkIndex)
{
#ifdef LINEIN_ENABLE
	MMI_LineIn_DriverCmd(DRIVER_STOP_LINE_IN_CMD);
#endif
	UNUSED(linkIndex);
}

PRIVATE void MMI_DRV_KeyEnableECNR(U8 linkIndex)
{
	MMIMsgType XDATA_PTR msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_MIC_TEST_CMD);

	if(msgPtr != (MMIMsgType XDATA_PTR)NULL)
	{
		msgPtr->msgBodyPtr.driverCmd.micTestCmd.controlECNR = DRIVER_CONTROL_ECNR_ENABLE;
		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
	}
	UNUSED(linkIndex);
}
PRIVATE void MMI_DRV_KeyDisableECNR(U8 linkIndex)
{
	MMIMsgType XDATA_PTR msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_MIC_TEST_CMD);

	if(msgPtr != (MMIMsgType XDATA_PTR)NULL)
	{
		msgPtr->msgBodyPtr.driverCmd.micTestCmd.controlECNR = DRIVER_CONTROL_ECNR_DISABLE;
		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
	}
	UNUSED(linkIndex);
}

PRIVATE void MMI_DRV_KeySwitchStereoMono(U8 linkIndex)
{
	MMIMsgType XDATA_PTR msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_DSP_SWITCH_STEREO_MONO_CMD);

	OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);

	UNUSED(linkIndex);
}

PRIVATE U16 MMI_DRV_CheckKeyReconnect(U16 keyCode)
{
	if(gMMI_ctl.reconnectCtl.disableReconnect || CURRENT_ACTIVE_LINK_CNT == gMMI_ctl.currentSupportDeviceNo)
		keyCode = KEY_INVALID;

	return keyCode;
}

PRIVATE U16 MMI_DRV_CheckKeyVoicePrompt(U16 keyCode)
{
	if(MMI_VOICE_PROMPT_FUNC_OFF_FEAT)
		keyCode = KEY_INVALID;

	return keyCode;
}

#ifdef PRODUCT_TYPE_K
extern PUBLIC BOOL MMI_Share_IsDeviceToPhone(void);
#endif

PRIVATE U16 MMI_DRV_CheckKeyDiscoverable(U16 keyCode)
{
#if defined(AIR_MODULE) && defined(A2DP_Profile)
	keyCode = MMI_AIR_CheckKeyDiscoverable(keyCode);
#endif
	if(CURRENT_ACTIVE_LINK_CNT == gMMI_ctl.currentSupportDeviceNo)
	{
		keyCode = KEY_INVALID;
	}
	return keyCode;
}

PRIVATE U16 MMI_DRV_CheckKeyVoiceDown(U16 keyCode)
{
	#ifdef FM_ENABLE
	if(MMI_CheckInFMState()  && gMMI_FM_ctl.isDriverFMBusy)
		keyCode = KEY_INVALID;
	#endif
	return keyCode;
}

PRIVATE U16 MMI_DRV_CheckKeyPowerOff(U16 keyCode)
{
	if (gMMI_ctl.mmiTimerInfo.sysTimer.disPowerOffAfterPowerOnTime)
		keyCode = KEY_INVALID;
	else
	{
		#ifdef AIR_MODULE
		keyCode = MMI_AIR_CheckKeyPowerOff(keyCode);
		#endif
	}
	return keyCode;
}

PRIVATE U16 MMI_DRV_CheckKeyVoiceCommandEnable(U16 keyCode)
{
#ifdef TWS_SETTINGS
	U8 airLink = MMI_AIR_GetAirLink(PRODUCT_AIR_TWS);
#endif
#ifdef A2DP_Profile
	U8 linkIndex;
	for(linkIndex = 0; linkIndex < MAX_MULTI_POINT_NO; linkIndex++)
	{
		if(MUSIC_EXISTS(linkIndex))
			return KEY_INVALID;
	}
#endif
#ifdef SUPPORT_VOICE_COMMAND
	if(VoiceCommand_IsEnabled())
		return KEY_INVALID;
#endif
#ifdef TWS_SETTINGS
	if(airLink != MMI_EOF && A2DP_IsLinkFollower(airLink))
		return KEY_INVALID;
#endif
	return keyCode;
}

PRIVATE U16 MMI_DRV_CheckKeyMuteOnOff(U16 keyCode)
{
	switch(DRIVER_CurrentPlayingMediaID())
	{
		case MEDIA_EVT_KEY_MIC_MUTE_ON:
		case MEDIA_EVT_KEY_MIC_MUTE_OFF:
			return KEY_INVALID;
		default:
			return keyCode;
	}
}

PRIVATE U16 MMI_DRV_CheckKeySCOSwitch(U16 keyCode)
{
	if(gMMI_ctl.scoCnt != MAX_MULTI_POINT_NO || MMI_DRV_IsSwitchingSCO())
	{
		return KEY_INVALID;
	}
	return keyCode;
}

PRIVATE U16 MMI_DRV_CheckKeyUnderA2DP(U16 keyCode)
{
	if(gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_MUSIC || gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_AVRCP_PLAY)
	{
		return KEY_INVALID;
	}
	return keyCode;
}

PRIVATE U16 MMI_DRV_CheckKeyAudioTransparency(U16 keyCode)
{
	if(!DRIVER_CheckAudioTransparencyReady())
		keyCode =(U16) KEY_INVALID;
	return keyCode;
}

PRIVATE void MMI_StopA2DPOrSCOCmd(U8 linkIndex, U8 isPowerOff)
{
	MMIMsgType XDATA_PTR msgPtr;

	if(isPowerOff)
		msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_STOP_DSP_POWER_OFF_CMD);
	else
		msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_STOP_DSP_CMD);

	if(msgPtr != (MMIMsgType XDATA_PTR)NULL)
	{
		DRIVER_ClearEnableSCODSPCmd(linkIndex);
		DRIVER_ClearEnableA2DPDSPCmd(linkIndex);

		msgPtr->msgBodyPtr.driverCmd.stopDSPCmd.linkInd = linkIndex;
		if(isPowerOff)
			OSMQ_PutFront(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
		else
			OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);

		#ifdef AIR_MODULE
		MMI_AIR_DriverSendA2DPDSPDisableCmd(linkIndex);
		#endif
		// To accelerate the speed of open DSP
		SYS_InsertOSTask(DRIVER_TASK);
		SYS_InsertOSTask(MMI_TASK);

		if(!isPowerOff)
			MMI_HCI_SendVCmdAudioQosSetup(linkIndex, SERVICE_TYPE_BEST_EFFORT, FALSE, FALSE);

		#ifdef DBG_UART_ENABLE_MMI
		LightDbgPrint("MMI - Send STOPDSP:%d", (U8)linkIndex);
		#endif
	}
}

PRIVATE void MMI_DRV_SetSCOPara(U8 linkIndex, MMIMsgType XDATA_PTR msgPtr)
{
	msgPtr->msgBodyPtr.driverCmd.scoCmd.linkInd = linkIndex;
	msgPtr->msgBodyPtr.driverCmd.scoCmd.m2d_ctl.para.mono_para.sco_type = gMMI_ctl.mmiInfo[linkIndex].linkPara.scoType;
	msgPtr->msgBodyPtr.driverCmd.scoCmd.m2d_ctl.para.mono_para.pkt_type = gMMI_ctl.mmiInfo[linkIndex].linkPara.scoPktType;
	msgPtr->msgBodyPtr.driverCmd.scoCmd.m2d_ctl.para.mono_para.sco_interval = gMMI_ctl.mmiInfo[linkIndex].linkPara.txInterval;
	msgPtr->msgBodyPtr.driverCmd.scoCmd.m2d_ctl.para.mono_para.codec_type = gMMI_ctl.mmiInfo[linkIndex].linkPara.scoCodecType;
	msgPtr->msgBodyPtr.driverCmd.scoCmd.m2d_ctl.para.mono_para.pkt_length = gMMI_ctl.mmiInfo[linkIndex].linkPara.rxPacketLen;
	#ifdef AIR_MODULE
	msgPtr->msgBodyPtr.driverCmd.scoCmd.m2d_ctl.para.mono_para.feature_sel.WOOFER_LPF_ENABLE = MMI_AIR_IsEnableLPFUnderSCO(linkIndex);
	if(msgPtr->msgBodyPtr.driverCmd.scoCmd.m2d_ctl.para.mono_para.feature_sel.WOOFER_LPF_ENABLE)
	{
		msgPtr->msgBodyPtr.driverCmd.scoCmd.m2d_ctl.para.mono_para.feature_sel.LPF_CUTOFF_FREQ_SEL = (U16)gMMI_nvram.airPara.LPFCutFreq;
		msgPtr->msgBodyPtr.driverCmd.scoCmd.m2d_ctl.para.mono_para.feature_sel.PCM_FS_SEL = gMMI_Air_ctl.SCOAudioFSSel;
	}

	msgPtr->msgBodyPtr.driverCmd.scoCmd.m2d_ctl.para.mono_para.feature_sel.PAYLOAD_ENCODE = MMI_AIR_IsSCOEncodePayload(linkIndex);
	#else
	msgPtr->msgBodyPtr.driverCmd.scoCmd.m2d_ctl.para.mono_para.feature_sel.WOOFER_LPF_ENABLE = 0;
	#endif
}

PRIVATE void MMI_SendSCOEnableCmd(U8 linkIndex)
{
	MMIMsgType XDATA_PTR msgPtr;

	#ifdef AIR_MODULE
	if(gMMI_Air_ctl.SCOAudioFSSel == 0xFF)
		return;
	#endif

	if((msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_SCO_CMD)) != (MMIMsgType XDATA_PTR)NULL)
	{
		MMI_DRV_SetSCOPara(linkIndex, msgPtr);

		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
		#ifdef DBG_UART_ENABLE_MMI
		LightDbgPrint("USR - Send SCOEnable:%d", (U8)linkIndex);
		#endif
	}
}

PUBLIC void MMI_SendDSPCmd(U8 linkIndex, U8 dspEnableType)
{
	switch(dspEnableType)
	{
		case DSP_DISABLED:
			MMI_StopA2DPOrSCOCmd(linkIndex, FALSE);
			break;
		case DSP_ENABLE_BY_SCO:
			MMI_SendSCOEnableCmd(linkIndex);
			break;
		case DSP_DISABLE_BY_POWER_OFF:
			MMI_StopA2DPOrSCOCmd(linkIndex, TRUE);
			break;
	}
}

PUBLIC MMIMsgType XDATA_PTR MMI_GetMMIMsgTypeCmdMemory(U8 opCode)
{
	MMIMsgType XDATA_PTR msgPtr;

	msgPtr = (MMIMsgType XDATA_PTR)OSMEM_Get(OSMEM_ptr1);

	if(msgPtr != (MMIMsgType XDATA_PTR)NULL)
	{
		OSMEM_memset_xdata((U8 XDATA_PTR)msgPtr, 0, OSMEM1_BLKSIZE);

		msgPtr->msgOpcode = opCode;
	}
	return msgPtr;
}

PUBLIC void MMI_DRV_Beep(U8 soundLevel, U8 device)
{
	//Modified by Eric Chou, 2010.7.23
	//If beepTone is 0xFF, do not play.
	U8 beepTone;

	if(device == AUDIO_DEVICE_MUSIC)
	{
		if(soundLevel)
			soundLevel--;

		beepTone = gMMI_nvram.musicSoundLevels[soundLevel].beepTone;
	}
	else if(device == AUDIO_DEVICE_LINE_IN)
	{
		if(soundLevel)
			soundLevel--;

		beepTone = gMMI_nvram.lineInSoundLevels[soundLevel].beepTone;
	}
	else
	{
		beepTone = gMMI_nvram.soundLevels[soundLevel].beepTone;
	}

	if (beepTone != INVALID_BEEP_PATTERN)
	{
	 	MMI_DRV_SendRingtoneCmd( MEDIA_EVT_KEY_VOICEUP , beepTone);
	}
}

PUBLIC void MMI_DRV_MaxMinVolumeLog(U16 mediaID)
{
	switch(mediaID)
	{
		case MEDIA_EVT_VOLUME_REACH_MAX:
			LightDbgPrint("SCO volume max media event playing");
				break;
		case MEDIA_EVT_VOLUME_REACH_MIN:
			LightDbgPrint("SCO volume min media event playing");
				break;
		case MEDIA_EVT_A2DP_VOLUME_REACH_MAX:
			LightDbgPrint("A2DP volume max media event playing");
				break;
		case MEDIA_EVT_A2DP_VOLUME_REACH_MIN:
			LightDbgPrint("A2DP volume min media event playing");
				break;
		case MEDIA_EVT_LINEIN_VOLUME_REACH_MAX:
			LightDbgPrint("Line-in volume max media event playing");
				break;
		case MEDIA_EVT_LINEIN_VOLUME_REACH_MIN:
			LightDbgPrint("Line-in volume min media event playing");
				break;
		case MEDIA_EVT_FM_VOLUME_REACH_MAX:
			LightDbgPrint("FM volume max media event playing");
				break;
		case MEDIA_EVT_FM_VOLUME_REACH_MIN:
			LightDbgPrint("FM volume min media event playing");
				break;
		default:
			break;
	}
}

PUBLIC BOOL MMI_DRV_IsVolMaxMinMediaPlaying(void)
{
	U16 mediaID;

	mediaID = DRIVER_CurrentPlayingMediaID();
	MMI_DRV_MaxMinVolumeLog(mediaID);

	switch(mediaID)
	{
		case MEDIA_EVT_VOLUME_REACH_MAX:
		case MEDIA_EVT_VOLUME_REACH_MIN:
		case MEDIA_EVT_A2DP_VOLUME_REACH_MAX:
		case MEDIA_EVT_A2DP_VOLUME_REACH_MIN:
		case MEDIA_EVT_LINEIN_VOLUME_REACH_MAX:
		case MEDIA_EVT_LINEIN_VOLUME_REACH_MIN:
		case MEDIA_EVT_FM_VOLUME_REACH_MAX:
		case MEDIA_EVT_FM_VOLUME_REACH_MIN:
			return TRUE;
		default:
			return FALSE;
	}
}

PUBLIC void MMI_DRV_MediaEventSendFakeCmd(U16 mediaEventIndex)
{
	#ifdef SUPPORT_VOICE_COMMAND
	U8 i;
	#endif
	if( 	MMI_CheckValidPowerOffMediaEvt(mediaEventIndex) ||
		mediaEventIndex == MEDIA_EVT_KEY_FM_POWERON || mediaEventIndex == MEDIA_EVT_KEY_ENTER_LINEIN_MODE ||mediaEventIndex == MEDIA_EVT_FM_ENABLE||
		mediaEventIndex == MEDIA_EVT_KEY_RDIAL ||mediaEventIndex == MEDIA_EVT_KEY_RDIAL_SECONDARY ||
		mediaEventIndex == MEDIA_EVT_KEY_SET_VOICE_RECOGNITION ||mediaEventIndex == MEDIA_EVT_KEY_SET_VOICE_RECOGNITION_SECONDARY ||
		mediaEventIndex == MEDIA_EVT_KEY_SET_VOICE_RECOGNITION_CANCEL||mediaEventIndex == MEDIA_EVT_KEY_SET_VOICE_RECOGNITION_SECONDARY_CANCEL||
		mediaEventIndex == MEDIA_EVT_KEY_SEEKUP ||mediaEventIndex == MEDIA_EVT_KEY_SEEKDOWN || mediaEventIndex == MEDIA_EVT_KEY_TUNEUP || mediaEventIndex == MEDIA_EVT_KEY_TUNEDN||
		mediaEventIndex == MEDIA_EVT_FM_MUTE_OFF ||mediaEventIndex == MEDIA_EVT_FM_MUTE_ON |
		mediaEventIndex == MEDIA_EVT_MUTE_ON || mediaEventIndex == MEDIA_EVT_MUTE_OFF || mediaEventIndex == MEDIA_EVT_ENTER_LINE_IN_MODE ||
		mediaEventIndex == MEDIA_EVT_KEY_SIRI_START_OR_CONTINUE || mediaEventIndex == MEDIA_EVT_KEY_SIRI_END ||
		mediaEventIndex == MEDIA_EVT_KEY_SIRI_START_OR_CONTINUE_SECONDARY|| mediaEventIndex == MEDIA_EVT_KEY_SIRI_END_SECONDARY ||
		mediaEventIndex == MEDIA_EVT_TWS_RIGHT_CHANNEL || mediaEventIndex == MEDIA_EVT_TWS_LEFT_CHANNEL ||
		mediaEventIndex == MEDIA_EVT_KEY_VOICE_PROMPT_ENABLE || mediaEventIndex == MEDIA_EVT_KEY_VOICE_PROMPT_DISABLE || mediaEventIndex == MEDIA_EVT_VOICE_PROMPT_LANG_CHANGE||
		mediaEventIndex == MEDIA_EVT_KEY_FIND_MY_ACCESSORY ||
		mediaEventIndex == MEDIA_EVT_KEY_MIC_MUTE_ON || mediaEventIndex == MEDIA_EVT_KEY_MIC_MUTE_OFF ||
		mediaEventIndex == MEDIA_EVT_KEY_WHAT_CAN_I_SAY ||
		mediaEventIndex == MEDIA_EVT_ENTER_INCOMING || mediaEventIndex == MEDIA_EVT_RINGTONE_IN_CALL || mediaEventIndex == MEDIA_EVT_RINGTONE || mediaEventIndex == MEDIA_EVT_RINGTONE2_IN_CALL ||
		mediaEventIndex == MEDIA_EVT_RINGTONE_2 || mediaEventIndex == MEDIA_EVT_KEY_CONTROL_DBB_ON_OFF || mediaEventIndex == MEDIA_EVT_KEY_CHANGE_SOUND_EFFECT)
	{
		MMI_DRV_SendFakeMediaCmd(mediaEventIndex);
	}
	else if(mediaEventIndex == MEDIA_EVT_KEY_RESET_PAIRED_DEVICES)
	{
		gMMI_ctl.driverCtl.resetPairedDeviceMediaCount++;
		MMI_DRV_SendFakeMediaCmd(mediaEventIndex);
	}
	#ifdef SUPPORT_VOICE_COMMAND
	else
	{

		for(i = 0; i < TOTAL_VOICE_COMMAND_EVENTS; i++)
		{
			if(mediaEventIndex == ((DRIVER_VOICE_COMMAND_DATA_TYPE CODE_PTR)GET_SECTOR_VOICE_DATA_ADDR(SECTOR_VOICE_COMMAND_DATA))->vcEventTable[i].mediaEvent)
			{
				if(!MMI_AllLinksInCallActiveState())	//voice command is invalid under callactive
				{
					MMI_DRV_SendFakeMediaCmd(mediaEventIndex);
				}
				break;
			}
		}
	}
	#endif
}

PUBLIC void MMI_RingtoneVoicePromptScheduler(U16 mediaEventIndex, U8 beepPattern, U8 voicePromptIndex, U8 is_voice_prompt_before_ringtone)
{
	#ifdef SUPPORT_VOICE_PROMPT
	if (!MMI_PlayVoicePromptIsAvailable(mediaEventIndex))
		voicePromptIndex = VOICE_PROMPT_INVALID;

	if(MMI_VP_RINGTONE_1OF2_FEAT)
	{
		if(voicePromptIndex != VOICE_PROMPT_INVALID)
			beepPattern = INVALID_BEEP_PATTERN;
	}
	else if(gMMI_driver_variation_nvram.misc_para.init.isMiscEnabled&IS_RINGTONE_DISABLED)
		beepPattern = INVALID_BEEP_PATTERN;

	if(voicePromptIndex == VOICE_PROMPT_INVALID  && beepPattern == INVALID_BEEP_PATTERN)
		goto MASK_SETTING_PROCESS;

	if(voicePromptIndex & RINGTONE_OVERRIDE_BIT)
	{
		voicePromptIndex &= 0x7F;
		MMI_DRV_SendRingtoneStopCmd();
		MMI_DRV_SendVoicepromptStopCmd();
	}

	if(is_voice_prompt_before_ringtone  && voicePromptIndex != VOICE_PROMPT_INVALID)
	{
		MMI_DRV_SendVoicePromptCmd(mediaEventIndex, voicePromptIndex);
	}
	#else
	UNUSED(voicePromptIndex);
	UNUSED(is_voice_prompt_before_ringtone);
	if(gMMI_driver_variation_nvram.misc_para.init.isMiscEnabled&IS_RINGTONE_DISABLED || beepPattern == INVALID_BEEP_PATTERN)
		goto MASK_SETTING_PROCESS;
	#endif

	if (beepPattern != INVALID_BEEP_PATTERN)
	{
		MMI_DRV_SendRingtoneCmd(mediaEventIndex, beepPattern);
	}
	#ifdef SUPPORT_VOICE_PROMPT
	if(!is_voice_prompt_before_ringtone  && voicePromptIndex != VOICE_PROMPT_INVALID)
	{
		MMI_DRV_SendVoicePromptCmd(mediaEventIndex, voicePromptIndex);
	}
	#endif

	MASK_SETTING_PROCESS:

	if(mediaEventIndex == MEDIA_EVT_EXIT_DISCOVERABLE)
	{
		MMI_DRV_SpecificEventRingtoneStopCmd(MEDIA_EVT_ENTER_DISCOVERABLE);
		MMI_DRV_SpecificEventVPStopCmd(MEDIA_EVT_ENTER_DISCOVERABLE);
	}
	else if(mediaEventIndex == MEDIA_EVT_EXIT_LINE_IN_MODE)
	{
		MMI_DRV_SpecificEventRingtoneStopCmd(MEDIA_EVT_ENTER_LINE_IN_MODE);
		MMI_DRV_SpecificEventVPStopCmd(MEDIA_EVT_ENTER_LINE_IN_MODE);
	}
	#ifdef SUPPORT_VOICE_PROMPT
	else if(mediaEventIndex == MEDIA_EVT_KEY_TEST_VOICE_PROMPT_PLAY)
	{
		if(voicePromptIndex == VP_EVT_CALLER_ID)
		{
			MMI_TestVoicePrompt_CallNumber();
		}
		else if(voicePromptIndex == VP_EVT_FM_CHANNEL_NUMBER)
		{
			#ifdef FM_ENABLE
			MMI_FM_SendChannelVoicePromptCmd(1023);
			#endif
		}
		else
			;
	}
	#endif


}

PUBLIC BOOL MMI_CheckValidPowerOffMediaEvt(U16 mediaEventIndex)
{
	if(	mediaEventIndex == MEDIA_EVT_KEY_POWER_OFF  ||  mediaEventIndex == MEDIA_EVT_POWER_OFF ||
		mediaEventIndex == MEDIA_EVT_POWER_OFF_IN_SHUTDOWN_LOW_BAT ||mediaEventIndex == MEDIA_EVT_OFF_STATE ||
		mediaEventIndex == MEDIA_EVT_POWER_OFF_UNDER_CHECKPOINT1 ||mediaEventIndex == MEDIA_EVT_POWER_OFF_UNDER_CHECKPOINT2 ||
		mediaEventIndex == MEDIA_EVT_POWER_OFF_UNDER_CHECKPOINT3)
		return TRUE;

	return FALSE;
}

PUBLIC BOOL MMI_PlayVoicePromptIsAvailable(U16 mediaEventIndex)
{
	if(	!MMI_DRV_IsVoicePromptEnabled() &&
		mediaEventIndex != MEDIA_EVT_KEY_VOICE_PROMPT_DISABLE &&
		mediaEventIndex != MEDIA_EVT_KEY_VOICE_PROMPT_ENABLE &&
		mediaEventIndex != MEDIA_EVT_VOICE_PROMPT_LANG_CHANGE &&
		mediaEventIndex != MEDIA_EVT_VOICE_PROMPT_LANG_SELECT &&
		mediaEventIndex != MEDIA_EVT_VOICE_PROMPT_LANG_CONFIRM)
		return FALSE;

	if(	!MMI_CheckValidPowerOffMediaEvt(mediaEventIndex))
	{
		if(MMI_DISCARD_VP_WHEN_IN_CALLWITHSCO_FEAT)
		{
			if(gMMI_ctl.scoCnt && MMI_AllLinksInCallRelatedState())
			{
				return FALSE;
			}
		}

		if(MMI_DISCARD_VP_WHEN_IN_MUSIC_FEAT)
		{
			#ifdef A2DP_Profile
			if(MMI_CheckAllLinksInA2DPState())
				return FALSE;
			#endif
		}
	}
	return TRUE;
}

//----------------------------------------------------
//---------------- Volume Control ----------------------
//----------------------------------------------------

PRIVATE void MMI_IdleStateVoiceControl(BOOL isVolumeUp, BOOL isFollowerCmd)
{
	U8 XDATA_PTR spkSoundLevelPtr;

	#ifdef AIR_MODULE
	if(MMI_AIR_IdleKeyVolUpDnFirst(isVolumeUp))
		return;
	#endif

	spkSoundLevelPtr  = &gMMI_ctl.idleStateSoundLevel;
	if(!gMMI_ctl.isAudioTransparencyEnable)
	{
		if (isVolumeUp)
		{
			gMMI_ctl.idleStateSmallStep = MMI_DRV_IncreaseSmallStepVolume(	gMMI_ctl.idleStateSoundLevel,
																			gMMI_nvram.totalSoundLevel,
																			MMI_SCO_SMALL_STEP_LEVELS(),
																			gMMI_ctl.idleStateSmallStep);

			if(gMMI_ctl.idleStateSmallStep == 0)
			{
				if (*spkSoundLevelPtr < gMMI_nvram.totalSoundLevel - 1)
				{
					(*spkSoundLevelPtr)++;
				}
				else if(MMI_CYCLIC_VOLUME_ENABLED_FEAT)
				{
					(*spkSoundLevelPtr) = 0;
				}
				else
				{
					MMI_PushMediaEvent(MEDIA_EVT_VOLUME_REACH_MAX);
					return;
				}
			}
		}
		else
		{
			if(gMMI_ctl.idleStateSmallStep == 0)
			{
				if (*spkSoundLevelPtr > 0)
				{
					(*spkSoundLevelPtr)--;
				}
				else if(MMI_CYCLIC_VOLUME_ENABLED_FEAT)
				{
					*spkSoundLevelPtr = gMMI_nvram.totalSoundLevel - 1;
					goto MMI_SEND_IDLE_VOL;
				}
				else
				{
					MMI_PushMediaEvent(MEDIA_EVT_VOLUME_REACH_MIN);
					return;
				}
			}
			gMMI_ctl.idleStateSmallStep = MMI_DRV_DecreaseSmallStepVolume(MMI_SCO_SMALL_STEP_LEVELS(), gMMI_ctl.idleStateSmallStep);
		}
		MMI_SEND_IDLE_VOL:
		//Notify driver
		MMI_DRV_SendDriverVolCmd(MMI_EOF, *spkSoundLevelPtr, gMMI_ctl.idleStateSmallStep, VOLUME_MIC_FOLLOW_SPK);

		//Adjust ringtone volume as well
		//Beep!
		if(!isFollowerCmd)
			MMI_DRV_Beep(*spkSoundLevelPtr, AUDIO_DEVICE_SCO);

		#ifdef AIR_MODULE
		MMI_AIR_IdleKeyVolUpDnLast(isVolumeUp);
		#endif
	}
	else
	{
		#if defined LINEIN_ENABLE && defined SUPPORT_MIC_IN_A2DP_MODE
		MMI_LineIn_VolumeControl(isVolumeUp);
		return;
		#endif
	}
}

PUBLIC void MMI_DRV_VoiceAdjustment(U8 linkIndex, U16 keyCode, BOOL isFollowerCmd)
{
	BOOL isVolumeUp;

	#if !defined(HFP_Profile) && !defined(A2DP_Profile)
	UNUSED(linkIndex);
	#endif
	if(MMI_DRV_IsVolMaxMinMediaPlaying())
		return;
	isVolumeUp = (keyCode == KEY_VOICEUP) ? TRUE : FALSE;

	isVolumeUp	= (gMMI_driver_variation_nvram.misc_para.init.isMiscEnabled & IS_VOLUME_ORIENTATION_REVERSED) ? !isVolumeUp : isVolumeUp;

	//1. record new audio device
	switch(gMMI_ctl.audioDevCtl.currentActiveDev)
	{
		case AUDIO_DEVICE_SCO:
		case AUDIO_DEVICE_SCO_HSP:
		case AUDIO_DEVICE_SCO_IDLE:
		case AUDIO_DEVICE_KEY_AT_CMD:
			if(isFollowerCmd)
				linkIndex = MMI_GetNextNormalLink(linkIndex);
			#ifdef HFP_Profile
			if(MMI_HFP_IsConnected(linkIndex))
			{
				if (!gMMI_ctl.mmiInfo[linkIndex].linkPara.isMicMute)
				{
					MMI_HFP_VoiceControl(linkIndex, isVolumeUp, isFollowerCmd);
				}
				else if (MMI_MUTE_CANCEL_WHEN_VOL_CHANGE_FEAT)
				{
					MMI_DRV_AutoMICMuteOff(linkIndex);
					MMI_HFP_VoiceControl(linkIndex, isVolumeUp, isFollowerCmd);
				}
				else if (MMI_ALLOW_VOL_ADJUST_WHEN_MUTED_FEAT )
				{
					MMI_HFP_VoiceControl(linkIndex, isVolumeUp, isFollowerCmd);
				}
			}
			else
			#endif
			{
				MMI_IdleStateVoiceControl(isVolumeUp, isFollowerCmd);
			}
			#ifndef HFP_Profile
			UNUSED(linkIndex);
			#endif
			break;
		case AUDIO_DEVICE_MUSIC:
		case AUDIO_DEVICE_MUSIC_CALL_NOTIFY:
		case AUDIO_DEVICE_AVRCP_PLAY:
			#ifdef A2DP_Profile
			if(isFollowerCmd)
				linkIndex = MMI_GetNextNormalLink(linkIndex);
			MMI_A2DP_VolumeControl(linkIndex, isVolumeUp, isFollowerCmd);
			#endif
			#ifdef LINEIN_ENABLE
			if(gMMI_ctl.isAudioTransparencyEnable)
			{
				MMI_LineIn_VolumeControl(isVolumeUp);
			}
			#endif
			break;
		case AUDIO_DEVICE_LINE_IN:
		case AUDIO_DEVICE_MIC_TO_SPK:
			#ifdef LINEIN_ENABLE
			MMI_LineIn_VolumeControl(isVolumeUp);
			#endif
			break;
		case AUDIO_DEVICE_FM:
			#ifdef FM_ENABLE
			MMI_FM_VolumeControl(isVolumeUp);
			#endif
			break;
		#ifdef DEMOSOUND
		case AUDIO_DEVICE_DEMO_SOUND:
			MMI_A2DP_DemoSoundVolumeControl(isVolumeUp);
			break;
		#endif
		default:
			MMI_IdleStateVoiceControl(isVolumeUp, isFollowerCmd);
			break;
	}
}

PUBLIC U8 MMI_DRV_IncreaseSmallStepVolume(U8 spkSoundLevel, U8 spkSoundLevelTotalNo, U8 smallStepAnchorCnt, U8 smallStep)
{
	if(smallStepAnchorCnt)
	{
		if(spkSoundLevel < (spkSoundLevelTotalNo -1))
		{
			smallStep++;
			if(smallStep == (smallStepAnchorCnt+1))
				smallStep = 0;
		}
		else
			smallStep = 0;
	}
	return smallStep;
}

PUBLIC U8 MMI_DRV_DecreaseSmallStepVolume(U8 smallStepAnchorCnt, U8 smallStep)
{
	if(smallStepAnchorCnt)
	{
		if(smallStep == 0)
			smallStep = smallStepAnchorCnt;
		else
			smallStep--;
	}
	return smallStep;
}

PUBLIC BOOL MMI_CheckSCOInAudioService(U8 linkIndex)
{
	if(MMI_CheckInFMState() ||MMI_CheckInLineInState() || linkIndex != gMMI_ctl.audioableSCOLink || !SCO_EXISTS(linkIndex))
		return FALSE;
	else
		return TRUE;
}


PUBLIC U8 MMI_SearchSoundLevelByVgs(U8 vgsValue)
{
	U8 ind;
	U8 soundLevel = gMMI_nvram.totalSoundLevel - 1;

	for (ind = 0; ind < gMMI_nvram.totalSoundLevel; ind++)
	{
		if (GET_SCO_VGS_BY_LEVEL(ind) >= vgsValue)
		{
			soundLevel = ind;
			break;
		}
	}

	return soundLevel;
}

PUBLIC U8 MMI_GetSCOGainByLevel(U8 level, BOOL isSpk)
{
	if(isSpk)
		return gMMI_nvram.vgsTable[gMMI_nvram.soundLevels[level].vgs].spkGainSetIndex;
	else
		return gMMI_nvram.vgsTable[gMMI_nvram.soundLevels[level].vgs].micGainSetIndex;
}

PUBLIC U8 MMI_GetA2DPGainByLevel(U8 level, BOOL isSpk)
{
	if(isSpk)
		return gMMI_nvram.vgsTable[gMMI_nvram.musicSoundLevels[level].vgs].spkGainSetIndex;
	else
		return gMMI_nvram.vgsTable[gMMI_nvram.musicSoundLevels[level].vgs].micGainSetIndex;
}

PUBLIC U8 MMI_GetLineInGainByLevel(U8 level, BOOL isSpk)
{
	if(isSpk)
		return gMMI_nvram.vgsTable[gMMI_nvram.lineInSoundLevels[level].vgs].spkGainSetIndex;
	else
		return gMMI_nvram.vgsTable[gMMI_nvram.lineInSoundLevels[level].vgs].micGainSetIndex;
}

PUBLIC void MMI_NotifyDriverBatteryStatus( U8 batStatus)
{
	MMIMsgType XDATA_PTR msgPtr;

	msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_BATTERY_STATUS_CMD);

	if(msgPtr)
	{
		msgPtr->msgBodyPtr.driverCmd.batStatusCmd.isLowBat = (U8)((batStatus==MMI_BAT_LOW)? TRUE: FALSE);
		msgPtr->msgBodyPtr.driverCmd.batStatusCmd.isCharging= (U8)((batStatus >=MMI_BAT_CHARGER_IN)? TRUE: FALSE);
		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
	}
}

PUBLIC void MMI_UartVolumeSet(HCI_VEVT_PARA_VOL_SET XDATA_PTR dataPtr)
{
	U8 linkIndex = dataPtr->linkIndex;

	if(dataPtr->scoSoundLevel != VOLUME_DONT_CARE)
	{
		MMI_DRV_SetSCOVolValue(linkIndex, dataPtr->scoSoundLevel, dataPtr->scoSmallStep);
	}
	if(dataPtr->scoVgm != VOLUME_DONT_CARE)
		CURRENT_SCO_VGM(linkIndex) = dataPtr->scoVgm;
	#ifdef A2DP_Profile
	if(dataPtr->a2dpSoundLevel != VOLUME_DONT_CARE)
	{
		MMI_A2DP_SetVolByLevel(linkIndex, dataPtr->a2dpSoundLevel, dataPtr->a2dpSmallStep);
		#ifdef AVRCP_Profile
		MMI_AVRCP_CmdGenerator(linkIndex, AVRCP_VOLUME_CHANGED, MMI_AVRCP_GetAbsVolByMusic(linkIndex));
		#endif
	}
	#endif
	if(dataPtr->lineInSoundLevel != VOLUME_DONT_CARE)
	{
		#ifdef LINEIN_ENABLE
		MMI_LineIn_SetVolByLevel(dataPtr->lineInSoundLevel, dataPtr->lineInSmallStep);
		#endif
	}
	#ifdef LINEIN_ENABLE
	if(MMI_CheckInLineInState() && MMI_DRV_IsAudioActiveDev(MMI_EOF, AUDIO_DEVICE_LINE_IN))
	{
		MMI_LineIn_SendDriverVolCmd();
		#ifdef AIR_MODULE
		MMI_AIR_LineInUartSetVol();
		#endif
		return;
	}
	#endif

	#ifdef A2DP_Profile
	if(A2DP_STREAMING == A2DP_GetState(linkIndex) && !A2DP_IsResume(linkIndex) && AUDIO_COMPONENT_IS_ACTIVE (AUDIO_A2DP))
	{
		MMI_A2DP_SendDriverVolCmd( CURRENT_A2DP_SOUND_LEVEL(linkIndex), CURRENT_A2DP_SMALL_STEP(linkIndex));
	}
	else
	#endif
	{
		MMI_DRV_SendDriverVolCmd(linkIndex, CURRENT_SCO_SOUND_LEVEL(linkIndex), CURRENT_SCO_SMALL_STEP(linkIndex), GET_SCO_MIC_GAIN_BY_LEVEL(CURRENT_SCO_SOUND_LEVEL(linkIndex)));
	}
}

PUBLIC void MMI_DRV_AudioSelCmd(DriverAudioSelCmd XDATA_PTR audioSelPtr)
{
	MMIMsgType XDATA_PTR msgPtr;

	if(msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_SET_AUDIO_SEL_CMD))
	{
		OSMEM_memcpy_xdata_xdata(  (U8 XDATA_PTR)&msgPtr->msgBodyPtr.driverCmd.audioSelectCmd, (U8 XDATA_PTR)audioSelPtr, sizeof(DriverAudioSelCmd));
		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
	}
}

#ifdef SUPPORT_VOICE_COMMAND

PRIVATE void MMI_DRV_SetVoiceCommandTimer(U16 mediaEvent)
{
	if (mediaEvent == MEDIA_EVT_KEY_VOICE_COMMAND_ENABLE)
	{
		SYS_SetTimer(&gMMI_ctl.mmiTimerInfo.sysTimer.voiceCommandTriggerTimer, 80* 320L);
	}
}

PUBLIC void MMI_SetVoiceCommandVol(void)
{

	MMIMsgType XDATA_PTR msgPtr;

	msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_SET_VOICE_COMMAND_VOL_CMD);

	if(msgPtr)
	{
		msgPtr->msgBodyPtr.driverCmd.vcVolCmd.micVols = MMI_MIC_GAINSET[gMMI_nvram.defaultVCLevel].digitalGainVC;
		msgPtr->msgBodyPtr.driverCmd.vcVolCmd.analogAdGain_R = MMI_MIC_GAINSET[gMMI_nvram.defaultVCLevel].analogGainVC_R;
		msgPtr->msgBodyPtr.driverCmd.vcVolCmd.analogAdGain_L = MMI_MIC_GAINSET[gMMI_nvram.defaultVCLevel].analogGainVC_L;
		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
	}
}
#endif

#ifdef PEQ_ENABLE
PUBLIC BOOL MMI_DRV_PEQModeChange(void)
{
	MMIMsgType XDATA_PTR msgPtr;

	msgPtr = (MMIMsgType XDATA_PTR)OSMEM_Get(OSMEM_ptr1);

	if(msgPtr != (MMIMsgType XDATA_PTR)NULL)
	{
		msgPtr->msgOpcode  = DRIVER_CHANGE_PEQ_CMD;
		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
		return TRUE;
	}
	return FALSE;

}

PUBLIC void MMI_DRV_RealTimeSetPeqHpf(MMIMsgType XDATA_PTR msgPtr)
{
	msgPtr->msgOpcode = DRIVER_REALTIME_SET_PEQ_HPF_CMD;
	OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
}

	#ifdef TWS_SETTINGS
	PUBLIC void MMI_DRV_SyncPEQRelayerToFollower(U8 peqMode, U8 peqModeIndex, U8 sectorMode)
	{
		U8 airLinkIndex;
		if((airLinkIndex = MMI_AIR_GetAirLink(PRODUCT_AIR_TWS)) != MMI_EOF && A2DP_IsLinkRelayer(airLinkIndex))
		{
			MMI_AIR_SetPEQParaCmd(airLinkIndex, peqMode, peqModeIndex, sectorMode);
		}
	}

	PUBLIC void MMI_DRV_SetFollowerPEQParameter(U8 peqMode, U8 peqModeIndex, U8 sectorMode)
	{
		MMIMsgType XDATA_PTR msgPtr;

		msgPtr = (MMIMsgType XDATA_PTR)OSMEM_Get(OSMEM_ptr1);

		if(msgPtr != (MMIMsgType XDATA_PTR)NULL)
		{
			msgPtr->msgOpcode = DRIVER_SET_PEQ_PARA_CMD;
			msgPtr->msgBodyPtr.hciVCmd.VPara.setPEQParaCmd.peqMode = peqMode;
			msgPtr->msgBodyPtr.hciVCmd.VPara.setPEQParaCmd.peqModeIndex = peqModeIndex;
			msgPtr->msgBodyPtr.hciVCmd.VPara.setPEQParaCmd.sectorMode = sectorMode;
			OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
		}
	}

	PUBLIC void MMI_DRV_FollowerPEQModeReload(void)
	{
		MMIMsgType XDATA_PTR msgPtr;

		msgPtr = (MMIMsgType XDATA_PTR)OSMEM_Get(OSMEM_ptr1);

		if(msgPtr != (MMIMsgType XDATA_PTR)NULL)
		{
			msgPtr->msgOpcode = DRIVER_PEQ_RELOAD_CMD;
			OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
		}
	}

	PUBLIC void MMI_DRV_SyncRealTimePEQFollowerToRelayer(U8 XDATA_PTR para, U8 enable_mode)
	{
		U8 airLinkIndex;
		if((airLinkIndex = MMI_AIR_GetAirLink(PRODUCT_AIR_TWS)) != MMI_EOF && A2DP_IsLinkRelayer(airLinkIndex))
		{
			MMI_AIR_RealtimePEQCmd(airLinkIndex, para, enable_mode);
		}
	}
	#endif
#endif

PUBLIC U8 MMI_DRV_SysDevBitMask(U8 audioDev)
{
	U8 i;
	for(i=0 ; i< sizeof(audioDevSysMappingTable)/sizeof(U8) ; i++)
	{
		if (audioDevSysMappingTable[i] == audioDev)
			break;
	}

	if(i == sizeof(audioDevSysMappingTable)/sizeof(U8))
	{
		ASSERT(FALSE);
	}

	return (0x01 << i);
}

PUBLIC U16 MMI_DRV_LinkDevBitMask(U8 audioDev)
{
	U8 i;
	for( i=0 ; i< sizeof(audioDevLinkGrpMappingTable)/sizeof(U8) ; i++)
	{
		if(audioDevLinkGrpMappingTable[i] == audioDev)
			break;
	}

	if(i == sizeof(audioDevLinkGrpMappingTable)/sizeof(U8))
	{
		ASSERT(FALSE);
	}

	return (U16)(0x1L << i);
}

PUBLIC BOOL MMI_DRV_IsLinkAudioDev(U8 audioDev)
{
	switch(audioDev)
	{
		case AUDIO_DEVICE_SCO:
		case AUDIO_DEVICE_SCO_HSP:
		case AUDIO_DEVICE_SCO_IDLE:
		case AUDIO_DEVICE_MUSIC:
		case AUDIO_DEVICE_MUSIC_CALL_NOTIFY:
		case AUDIO_DEVICE_KEY_AT_CMD:
		case AUDIO_DEVICE_CALL_STATE:
		case AUDIO_DEVICE_AVRCP_PLAY:
			return TRUE;
		case AUDIO_DEVICE_LINE_IN:
		case AUDIO_DEVICE_FM:
		case AUDIO_DEVICE_DEMO_SOUND:
		case AUDIO_DEVICE_MIC_TO_SPK:
			return FALSE;
		default:
			ASSERT(FALSE);
			return FALSE;
	}
}

PUBLIC U32 MMI_DRV_ResumeTimer(U8 audioDev)
{
	switch(audioDev)
	{
		case AUDIO_DEVICE_MUSIC:
		case AUDIO_DEVICE_AVRCP_PLAY:
		case AUDIO_DEVICE_FM:
		case AUDIO_DEVICE_LINE_IN:
		#ifdef DEMOSOUND
		case AUDIO_DEVICE_DEMO_SOUND:
		#endif
			return ((U32)(gMMI_nvram.timerCtl.waitForResumeTimer-5)*320L);
		case AUDIO_DEVICE_MUSIC_CALL_NOTIFY:
		case AUDIO_DEVICE_CALL_STATE:
			return (320L);
		case AUDIO_DEVICE_SCO:
		case AUDIO_DEVICE_SCO_IDLE:
		case AUDIO_DEVICE_SCO_HSP:
		case AUDIO_DEVICE_MIC_TO_SPK:
			return (0L);
		case AUDIO_DEVICE_KEY_AT_CMD:
			return (10L);
		default:
			ASSERT(FALSE);
			return 0L;
	}
}

PUBLIC U8 MMI_DRV_GetAudioDevByPriority(U8 i)
{
	return (i >= AUDIO_DEVICE_NUM) ? gMMI_nvram.audioPriorityExtra[i-AUDIO_DEVICE_NUM] : MMI_AUDIO_PRIORITY[i];
}

PUBLIC U8 MMI_DRV_SearchAudioPriority(U8 audioDev)
{
	U8 i;
	for(i = 0; i < AUDIO_DEVICE_NUM; i++)
	{
		if(MMI_AUDIO_PRIORITY[i] == audioDev)
			return i;
	}
	for(i = 0; i < 4; i++)
	{
		if(gMMI_nvram.audioPriorityExtra[i] == audioDev)
			return (i+AUDIO_DEVICE_NUM);
	}
	ASSERT(FALSE);
	return 0xFF;
}

PUBLIC BOOL MMI_DRV_IsAudioDeviceRegistered(U8 linkIndex, U8 audioDev)
{
	if(MMI_DRV_IsLinkAudioDev(audioDev))
	{
		if(linkIndex < MAX_MULTI_POINT_NO && (gMMI_ctl.audioDevCtl.registedDev[linkIndex] & MMI_DRV_LinkDevBitMask(audioDev)))
			return TRUE;
	}
	else
	{
		if(gMMI_ctl.audioDevCtl.sysAudioDev & MMI_DRV_SysDevBitMask(audioDev))
			return TRUE;
	}
	return FALSE;
}

PUBLIC BOOL MMI_DRV_IsHighPriAudioDeviceRegistered(U8 audioDev)
{
	U8 priIn, priCurr;
	if(gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_NONE)
		return FALSE;
	priIn = MMI_DRV_SearchAudioPriority(audioDev);
	priCurr = MMI_DRV_SearchAudioPriority(gMMI_ctl.audioDevCtl.currentActiveDev);
	if(priCurr > priIn)
		return TRUE;
	else
		return FALSE;
}

PUBLIC BOOL MMI_DRV_IsOtherAudioDeviceEnabled(U8 linkIndex, U8 audioDev)
{
	U8 i;
	if(MMI_DRV_IsLinkAudioDev(audioDev))
	{
		if(gMMI_ctl.audioDevCtl.sysAudioDev)
			return TRUE;

		for(i = 0; i < MAX_MULTI_POINT_NO; i++)
		{
			if(i == linkIndex)
			{
				if(gMMI_ctl.audioDevCtl.registedDev[i] & ~(MMI_DRV_LinkDevBitMask(audioDev)))
					return TRUE;
			}
			else
			{
				if(gMMI_ctl.audioDevCtl.registedDev[i])
					return TRUE;
			}
		}
	}
	else
	{
		for(i = 0; i < MAX_MULTI_POINT_NO; i++)
		{
			if(gMMI_ctl.audioDevCtl.registedDev[i])
				return TRUE;
		}
		if(gMMI_ctl.audioDevCtl.sysAudioDev & ~(MMI_DRV_SysDevBitMask(audioDev)))
			return TRUE;
	}
	return FALSE;
}

#if defined(A2DP_Profile) && defined(SUPPORT_MULTI_POINT)
PRIVATE void MMI_A2DP_SendAnotherLinkPauseMusic(U8 linkIndex)//Mantis 8599 - avoid Warning C183 : Dead Assignment Eliminated
{
	U8 i;
	for(i = 0; i < MAX_MULTI_POINT_NO; i++)
	{
		if(i != linkIndex)
		{
			MMI_A2DP_SendPauseMusic(i,TRUE);
		}
	}
}
#endif

PUBLIC BOOL MMI_DRV_AudioDeviceRegister(U8 linkIndex, U8 audioDev)
{
	U8 priIn, priCurr;
	BOOL isPause = FALSE;
	//1. record new audio device
	switch(audioDev)
	{
		case AUDIO_DEVICE_SCO:
		case AUDIO_DEVICE_SCO_HSP:
		case AUDIO_DEVICE_SCO_IDLE:
		case AUDIO_DEVICE_MUSIC:
		case AUDIO_DEVICE_MUSIC_CALL_NOTIFY:
		case AUDIO_DEVICE_CALL_STATE:
		case AUDIO_DEVICE_KEY_AT_CMD:
		case AUDIO_DEVICE_AVRCP_PLAY:
			if(linkIndex >= MAX_MULTI_POINT_NO)
				ASSERT(FALSE);

			gMMI_ctl.audioDevCtl.registedDev[linkIndex] |= MMI_DRV_LinkDevBitMask(audioDev);
			//#ifdef DBG_UART_ENABLE_MMI
			LightDbgPrint("USR - RegAudioDev2:%x, %X", (U8)linkIndex, (U32)gMMI_ctl.audioDevCtl.registedDev[linkIndex]);
			//#endif
			break;
		case AUDIO_DEVICE_MIC_TO_SPK:
		case AUDIO_DEVICE_LINE_IN:
		case AUDIO_DEVICE_FM:
		#ifdef DEMOSOUND
		case AUDIO_DEVICE_DEMO_SOUND:
		#endif
			gMMI_ctl.audioDevCtl.sysAudioDev |= MMI_DRV_SysDevBitMask(audioDev);
			//#ifdef DBG_UART_ENABLE_MMI
			LightDbgPrint("USR - RegAudioDev3:%x, %X", (U8)linkIndex, (U32)gMMI_ctl.audioDevCtl.sysAudioDev);
			//#endif
			break;
		default:
			ASSERT(FALSE);
	}

	LightDbgPrint("AudioDevReg[%d]:%d", (U8)linkIndex, (U8)audioDev);

	//2. check if audio device is active
	if(gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_NONE)
		goto SET_AUDIO_DEV_ACTIVE;


	//3. Get priority of current audio
	priIn = MMI_DRV_SearchAudioPriority(audioDev);
	priCurr = MMI_DRV_SearchAudioPriority(gMMI_ctl.audioDevCtl.currentActiveDev);

	if(priCurr > priIn)
	{
		// high priority is active now
		if((audioDev == AUDIO_DEVICE_MUSIC || audioDev == AUDIO_DEVICE_AVRCP_PLAY) && (gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_MUSIC || gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_AVRCP_PLAY))
		{
			if(gMMI_ctl.audioDevCtl.currentActiveLinkIndex != linkIndex)
			{
				goto DECIDE_MUSIC_PRIORITY;
			}
		}
		return FALSE;
	}
	else if(priCurr < priIn)
	{
		// disable low priority audio device
		switch(gMMI_ctl.audioDevCtl.currentActiveDev)
		{
			case AUDIO_DEVICE_SCO_IDLE:
			case AUDIO_DEVICE_SCO_HSP:
			case AUDIO_DEVICE_SCO:
				if(audioDev == AUDIO_DEVICE_SCO || audioDev == AUDIO_DEVICE_SCO_HSP || audioDev == AUDIO_DEVICE_SCO_IDLE || audioDev == AUDIO_DEVICE_KEY_AT_CMD)
				{
					if(gMMI_ctl.audioDevCtl.currentActiveLinkIndex == linkIndex)
						goto SET_AUDIO_DEV_ACTIVE;
					else
						MMI_SendDSPCmd(gMMI_ctl.audioDevCtl.currentActiveLinkIndex, DSP_DISABLED);
				}
				else
					MMI_SendDSPCmd(gMMI_ctl.audioDevCtl.currentActiveLinkIndex, DSP_DISABLED);
				break;

			case AUDIO_DEVICE_MUSIC:
			case AUDIO_DEVICE_MUSIC_CALL_NOTIFY:
			case AUDIO_DEVICE_AVRCP_PLAY:
				switch(audioDev)
				{
					case AUDIO_DEVICE_MUSIC_CALL_NOTIFY:
					case AUDIO_DEVICE_CALL_STATE:
						if(gMMI_ctl.audioDevCtl.currentActiveLinkIndex == linkIndex)
							goto SET_AUDIO_DEV_ACTIVE;
						else
						{
							MMI_A2DP_StopDSP(gMMI_ctl.audioDevCtl.currentActiveLinkIndex);
							#ifdef A2DP_Profile
							if(!MMI_A2DP_MEMPUT_WHEN_CALLACTIVE_FEAT)
							{
								#ifdef SUPPORT_MULTI_POINT
								MMI_A2DP_SendAnotherLinkPauseMusic(linkIndex);
								#endif
							}
							#endif

						}
						break;
					case AUDIO_DEVICE_MUSIC:
					case AUDIO_DEVICE_AVRCP_PLAY:
						if(gMMI_ctl.audioDevCtl.currentActiveLinkIndex == linkIndex)
							goto SET_AUDIO_DEV_ACTIVE;
						else
						{
							goto DECIDE_MUSIC_PRIORITY;
						}
						break;
					case AUDIO_DEVICE_LINE_IN:
						isPause = (!MMI_A2DP_MEMPUT_WHEN_LINE_IN_FEAT)?TRUE:FALSE;
						goto DRV_PAUSE_MUSIC;
					case AUDIO_DEVICE_FM:
						isPause = (!MMI_A2DP_MEMPUT_WHEN_FM_ON_FEAT)?TRUE:FALSE;
						DRV_PAUSE_MUSIC:
						MMI_A2DP_StopDSP(gMMI_ctl.audioDevCtl.currentActiveLinkIndex);
						if(isPause && (gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_MUSIC || gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_AVRCP_PLAY))
						{
							#ifdef A2DP_Profile
							MMI_A2DP_SendPauseMusic(gMMI_ctl.audioDevCtl.currentActiveLinkIndex, FALSE);
							#endif
						}
						break;
					#ifdef DEMOSOUND
					case AUDIO_DEVICE_DEMO_SOUND:
						isPause = FALSE;
						goto DRV_PAUSE_MUSIC;
					#endif

					case AUDIO_DEVICE_SCO:
					case AUDIO_DEVICE_SCO_HSP:
					case AUDIO_DEVICE_SCO_IDLE:
					case AUDIO_DEVICE_KEY_AT_CMD:
						MMI_A2DP_StopDSP(gMMI_ctl.audioDevCtl.currentActiveLinkIndex);
						#ifdef A2DP_Profile
						{
							#ifdef SUPPORT_MULTI_POINT
							MMI_A2DP_SendAnotherLinkPauseMusic(linkIndex);
							#endif
						}
						#endif
						break;
					case AUDIO_DEVICE_MIC_TO_SPK:
						break;
					default:
						ASSERT(FALSE);
						break;
				}
				break;
			case AUDIO_DEVICE_LINE_IN:
				MMI_RmvState(MMI_EOF, MMI_LINE_IN);
				break;
			case AUDIO_DEVICE_FM:
				MMI_RmvState(MMI_EOF, MMI_FM);
				if(audioDev == AUDIO_DEVICE_LINE_IN)
				{
					if(!MMI_LINE_IN_DETECT_BY_GPIO)
					{
						MMI_DRV_AudioDeviceDeRegister(MMI_EOF, AUDIO_DEVICE_FM);
						//De-registered
					}
				}
				break;
			#ifdef DEMOSOUND
			case AUDIO_DEVICE_DEMO_SOUND:
				MMI_A2DP_DemoSoundStopCmd();
				break;
			#endif
			case AUDIO_DEVICE_MIC_TO_SPK:
			#ifdef LINEIN_ENABLE
				MMI_DRV_SetMicSoundLevelInA2DP(gMMI_LineIn_ctl.currentsoundLevel);
				MMI_DRV_KeyEventHandler(linkIndex, KEY_MIC_TO_SPK_DISABLE);
			#endif
				break;
		}
	}
	else // same priority
	{
		switch(audioDev)
		{
			case AUDIO_DEVICE_LINE_IN:
			case AUDIO_DEVICE_FM:
			#ifdef DEMOSOUND
			case AUDIO_DEVICE_DEMO_SOUND:
			#endif
				ASSERT(FALSE);
				break;
			case AUDIO_DEVICE_MUSIC:
			case AUDIO_DEVICE_AVRCP_PLAY:
				if(gMMI_ctl.audioDevCtl.currentActiveLinkIndex != linkIndex)
				{
					DECIDE_MUSIC_PRIORITY:
					if(MMI_MUSIC_LAST_IN_FIRST_PLAYED_NO_PAUSE_OTHERS_FEAT)
					{
						MMI_A2DP_StopDSP(gMMI_ctl.audioDevCtl.currentActiveLinkIndex);
						goto SET_AUDIO_DEV_ACTIVE;
					}
					else if(MMI_MUSIC_LAST_IN_FIRST_PLAYED_AND_PAUSE_OTHERS_FEAT)
					{
						#ifdef A2DP_Profile
						MMI_A2DP_SendPauseMusic(gMMI_ctl.audioDevCtl.currentActiveLinkIndex, FALSE);
						#endif
						goto SET_AUDIO_DEV_ACTIVE;
					}
					#ifdef AVRCP_Profile
					else if(MMI_A2DP_MEMPUT_WHEN_OTHER_IN_MUSIC_FEAT)
					{
						//Mantis 10306 cover some phone can't change AVRCP Play status
						#if 0
						U8 playStatus = MMI_AVRCP_GetPlayStatus(gMMI_ctl.audioDevCtl.currentActiveLinkIndex);
						if(playStatus == AVRCP_PLAYBACK_STATUS_PAUSED || playStatus == AVRCP_PLAYBACK_STATUS_STOPPED)
						{
							MMI_A2DP_StopDSP(gMMI_ctl.audioDevCtl.currentActiveLinkIndex);
							goto SET_AUDIO_DEV_ACTIVE;
						}
						#endif
					}
					#endif
				}
				return FALSE;
				break;
			case AUDIO_DEVICE_MUSIC_CALL_NOTIFY:
			case AUDIO_DEVICE_CALL_STATE:
				if(gMMI_ctl.audioDevCtl.currentActiveLinkIndex != linkIndex)
					return FALSE;
				else
				{
					ASSERT(FALSE);
				}
				break;
			case AUDIO_DEVICE_SCO:
			case AUDIO_DEVICE_SCO_HSP:
				if(gMMI_ctl.audioDevCtl.currentActiveLinkIndex != linkIndex)
				{
					if(	MMI_CheckLinkInCallActiveState(gMMI_ctl.audioDevCtl.currentActiveLinkIndex))
					{
						#ifdef HFP_Profile
						if(MMI_MAX_ONGOING_CALL_NO ==MMI_HFP_SearchCallStatusInd(gMMI_ctl.audioDevCtl.currentActiveLinkIndex,MMI_CALL_HELD))
							return FALSE;
						else
						#endif
						{
							if(MMI_CheckLinkInCallActiveState(linkIndex))
							{
								goto SET_AUDIO_DEV_ACTIVE;
							}
							else
							{
								return FALSE;
							}
						}
					}
					else if(MMI_CheckLinkInCallActiveState(linkIndex))
					{
						goto SET_AUDIO_DEV_ACTIVE;
					}
					else if (MMI_CheckLinkInCallNotifyState(gMMI_ctl.audioDevCtl.currentActiveLinkIndex))
					{
						if(MMI_CheckLinkInCallNotifyState(linkIndex))
						{
							if(gMMI_ctl.mmiInfo[gMMI_ctl.audioDevCtl.currentActiveLinkIndex].nestStatePtr->nestState == MMI_HFP_OUTGOING)
								return FALSE;
							else if(linkIndex < MAX_MULTI_POINT_NO && gMMI_ctl.mmiInfo[linkIndex].nestStatePtr->nestState == MMI_HFP_OUTGOING)
								goto SET_AUDIO_DEV_ACTIVE;
							else
								return FALSE;
						}
						else
						{
							return FALSE;
						}
					}
					else if(MMI_CheckLinkInCallNotifyState(linkIndex))
					{
						goto SET_AUDIO_DEV_ACTIVE;
					}
				}
				else
				{
					goto SET_AUDIO_DEV_ACTIVE;
				}
				break;
			case AUDIO_DEVICE_SCO_IDLE:
				break;
			case AUDIO_DEVICE_MIC_TO_SPK:
				break;
			case AUDIO_DEVICE_KEY_AT_CMD:
				return FALSE;
				break;
		}

	}

	SET_AUDIO_DEV_ACTIVE:
	gMMI_ctl.audioDevCtl.currentActiveDev = audioDev;
	gMMI_ctl.audioDevCtl.currentActiveLinkIndex = linkIndex;
	LightDbgPrint("SetAudioDev[%d]:%d", (U8)gMMI_ctl.audioDevCtl.currentActiveLinkIndex, (U8)gMMI_ctl.audioDevCtl.currentActiveDev);
	SYS_ReleaseTimer(&gMMI_ctl.audioDevCtl.resumeTimer);

	if(linkIndex != MMI_EOF)
		gMMI_ctl.serviceInd = linkIndex;

	return TRUE;
}

PUBLIC BOOL MMI_DRV_SetAudioDeviceByLink(U8 linkIndex, U8 audioDev)
{
	if(MMI_KEY_STATE_POWER_OFF == MMI_GetKeyState())
		return FALSE;

	if(MMI_DRV_IsAudioDeviceRegistered(linkIndex, audioDev))
	{
		LightDbgPrint("SetAudioDeviceByLink[%d]:%d",(U8)linkIndex, (U8)audioDev);
		SYS_SetTimer(&gMMI_ctl.audioDevCtl.resumeTimer, MMI_DRV_ResumeTimer(audioDev));
		gMMI_ctl.audioDevCtl.currentActiveDev = audioDev;
		gMMI_ctl.audioDevCtl.currentActiveLinkIndex = linkIndex;
		gMMI_ctl.serviceInd = linkIndex;
		return TRUE;
	}
	return FALSE;
}

PUBLIC void MMI_DRV_RemoveServiceLink(U8 linkIndex)
{
	U8 nextLink;
	if(MMI_KEY_STATE_POWER_OFF == MMI_GetKeyState())
		return;

	if(gMMI_ctl.serviceInd == linkIndex)
	{
		switch(gMMI_ctl.audioDevCtl.currentActiveDev)
		{
			case AUDIO_DEVICE_SCO:
			case AUDIO_DEVICE_SCO_HSP:
			case AUDIO_DEVICE_SCO_IDLE:
			case AUDIO_DEVICE_MUSIC:
			case AUDIO_DEVICE_MUSIC_CALL_NOTIFY:
			case AUDIO_DEVICE_CALL_STATE:
			case AUDIO_DEVICE_AVRCP_PLAY:
			case AUDIO_DEVICE_KEY_AT_CMD:
				LightDbgPrint("ASSERT - Zombie Audio Device");
				/* fallthrough */
			case AUDIO_DEVICE_LINE_IN:
			case AUDIO_DEVICE_FM:
			#ifdef DEMOSOUND
			case AUDIO_DEVICE_DEMO_SOUND:
			#endif
			case AUDIO_DEVICE_MIC_TO_SPK:
			case AUDIO_DEVICE_NONE:
				if((nextLink = MMI_GetNextNormalLink(linkIndex)) == MMI_EOF)
				{
					#ifdef AIR_MODULE
					if((nextLink = MMI_AIR_GetNextAirLink(linkIndex)) == MMI_EOF)
					#endif
					{
						if((nextLink = MMI_GetNextActiveLink(linkIndex)) == MMI_EOF)
						{
							nextLink = DEFAULT_LINK_IND;
						}
					}
				}
				gMMI_ctl.serviceInd = nextLink;
				break;
			default:
				ASSERT(FALSE);
		}
	}
}

PUBLIC void MMI_DRV_AddServiceLink(U8 linkIndex)
{
	if(MMI_KEY_STATE_POWER_OFF == MMI_GetKeyState())
		return;
	if(	gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_NONE ||
		gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_LINE_IN ||
		gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_FM
		#ifdef DEMOSOUND
		|| gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_DEMO_SOUND
		#endif
		#ifdef AIR_MODULE
		|| gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_SCO_IDLE
		#endif
		)
	{
		U8 nextLink = MMI_GetNextNormalLink(linkIndex);
		if(nextLink != MMI_EOF && MMI_CheckNestStateByLink(nextLink, MMI_CONNECTED))
			return;

		gMMI_ctl.serviceInd = linkIndex;
	}
}

PUBLIC BOOL MMI_DRV_SetAudioDeviceToAnotherLink(U8 linkIndex, U8 audioDev)
{
	U8 nextLink;
	if(MMI_KEY_STATE_POWER_OFF == MMI_GetKeyState())
		return FALSE;

	for(nextLink = 0; nextLink < MAX_MULTI_POINT_NO; nextLink++)
	{
		if(nextLink != linkIndex && MMI_DRV_SetAudioDeviceByLink(nextLink, audioDev))
		{
			return TRUE;
		}
	}
	return FALSE;
}



PUBLIC BOOL MMI_DRV_SetAudioDeviceSys(U8 audioDev, U32 timer)
{
	if(MMI_KEY_STATE_POWER_OFF == MMI_GetKeyState())
		return FALSE;

	if(MMI_DRV_IsAudioDeviceRegistered(MMI_EOF, audioDev))
	{
		LightDbgPrint("SetAudioDeviceSys[%d]:%d",(U8)MMI_EOF, (U8)audioDev);
		SYS_SetTimer(&gMMI_ctl.audioDevCtl.resumeTimer, timer);
		gMMI_ctl.audioDevCtl.currentActiveDev = audioDev;
		gMMI_ctl.audioDevCtl.currentActiveLinkIndex = MMI_EOF;
		return TRUE;
	}
	return FALSE;
}

PUBLIC void MMI_DRV_AudioDeviceDeRegister(U8 linkIndex, U8 audioDev)
{
	//delete audio device

	switch(audioDev)
	{
		case AUDIO_DEVICE_SCO:
		case AUDIO_DEVICE_SCO_HSP:
		case AUDIO_DEVICE_SCO_IDLE:
		case AUDIO_DEVICE_MUSIC:
		case AUDIO_DEVICE_MUSIC_CALL_NOTIFY:
		case AUDIO_DEVICE_CALL_STATE:
		case AUDIO_DEVICE_KEY_AT_CMD:
		case AUDIO_DEVICE_AVRCP_PLAY:
			if(linkIndex < MAX_MULTI_POINT_NO)
			{
				gMMI_ctl.audioDevCtl.registedDev[linkIndex] &= ~(MMI_DRV_LinkDevBitMask(audioDev));
				//#ifdef DBG_UART_ENABLE_MMI
				LightDbgPrint("USR - DeRegAudioDev2:%x, %X", (U8)linkIndex, (U32)gMMI_ctl.audioDevCtl.registedDev[linkIndex]);
				//#endif
			}
			break;
		case AUDIO_DEVICE_MIC_TO_SPK:
		case AUDIO_DEVICE_LINE_IN:
		case AUDIO_DEVICE_FM:
		#ifdef DEMOSOUND
		case AUDIO_DEVICE_DEMO_SOUND:
		#endif
			gMMI_ctl.audioDevCtl.sysAudioDev &= ~(MMI_DRV_SysDevBitMask(audioDev));
			//#ifdef DBG_UART_ENABLE_MMI
			LightDbgPrint("USR - DeRegAudioDev3:%x, %X", (U8)linkIndex, (U32)gMMI_ctl.audioDevCtl.sysAudioDev);
			//#endif
			break;
		default:
			ASSERT(FALSE);
	}
}

PUBLIC BOOL MMI_DRV_SetAudioDeviceMusicResume(U8 linkIndex, U8 audioDev)
{
	U8 nextActiveLink;

	if(MMI_DRV_IsAudioDeviceRegistered(linkIndex, audioDev))
	{
		nextActiveLink = MMI_GetNextActiveLink(linkIndex);
		if(nextActiveLink == MMI_EOF || !MMI_DRV_IsAudioDeviceRegistered(nextActiveLink, audioDev))
		{
			if(MMI_DRV_SetAudioDeviceByLink(linkIndex, audioDev))
				return TRUE;
		}
		#ifdef A2DP_Profile
		else
		{
			if(A2DP_STREAMING == A2DP_GetState(linkIndex) && !A2DP_IsResume(linkIndex))
			{
				if(MMI_DRV_SetAudioDeviceByLink(linkIndex, audioDev))
					return TRUE;
			}
			else if(A2DP_STREAMING == A2DP_GetState(nextActiveLink) && !A2DP_IsResume(nextActiveLink))
			{
				if(MMI_DRV_SetAudioDeviceByLink(nextActiveLink, audioDev))
					return TRUE;
			}
			else  if(A2DP_STREAMING == A2DP_GetState(linkIndex) && A2DP_IsResume(linkIndex))
			{
				if(MMI_DRV_SetAudioDeviceByLink(linkIndex, audioDev))
					return TRUE;
			}
			else if(A2DP_IsResume(linkIndex))
			{
				if(MMI_DRV_SetAudioDeviceByLink(linkIndex, audioDev))
					return TRUE;
			}
			else if(A2DP_STREAMING == A2DP_GetState(nextActiveLink) && A2DP_IsResume(nextActiveLink))
			{
				if(MMI_DRV_SetAudioDeviceByLink(nextActiveLink, audioDev))
					return TRUE;
			}
			else if(A2DP_IsResume(nextActiveLink))
			{
				if(MMI_DRV_SetAudioDeviceByLink(nextActiveLink, audioDev))
					return TRUE;
			}
			else if(A2DP_STREAMING == A2DP_GetState(linkIndex))
			{
				if(MMI_DRV_SetAudioDeviceByLink(linkIndex, audioDev))
					return TRUE;
			}
			else if(A2DP_STREAMING == A2DP_GetState(nextActiveLink))
			{
				if(MMI_DRV_SetAudioDeviceByLink(nextActiveLink, audioDev))
					return TRUE;
			}
		}
		#endif
	}
	return FALSE;
}

PUBLIC void MMI_DRV_ResumeOtherAudioDevice(U8 linkIndex, U8 audioDev)
{
	U8 priIn, i, startLinkInd, linkCnt;

	//2. check if audio device is active
	LightDbgPrint("ResumeOtherAudio[%d]:%x,[%d]:%x",(U8)linkIndex, (U8)audioDev, (U8)gMMI_ctl.audioDevCtl.currentActiveLinkIndex, (U8)gMMI_ctl.audioDevCtl.currentActiveDev);

	if(gMMI_ctl.audioDevCtl.currentActiveDev != audioDev || gMMI_ctl.audioDevCtl.currentActiveLinkIndex != linkIndex)
		return;

	switch(audioDev)
	{
		case AUDIO_DEVICE_SCO:
		case AUDIO_DEVICE_SCO_IDLE:
		case AUDIO_DEVICE_SCO_HSP:
		case AUDIO_DEVICE_KEY_AT_CMD:
		case AUDIO_DEVICE_CALL_STATE:
		case AUDIO_DEVICE_MUSIC_CALL_NOTIFY:
		case AUDIO_DEVICE_MUSIC:
		case AUDIO_DEVICE_AVRCP_PLAY:
			if(MMI_DRV_SetAudioDeviceToAnotherLink(linkIndex, audioDev))
				goto NEW_ACTIVE_AUDIO_DEV;
			break;
	}

	if(priIn = MMI_DRV_SearchAudioPriority(audioDev))
	{
		i = priIn;
		while(i--)
		{
			linkCnt = 0;
			switch(MMI_DRV_GetAudioDevByPriority(i))
			{
				case AUDIO_DEVICE_SCO:
				case AUDIO_DEVICE_SCO_HSP:
				case AUDIO_DEVICE_SCO_IDLE:
				case AUDIO_DEVICE_CALL_STATE:
				case AUDIO_DEVICE_KEY_AT_CMD:
					if(linkIndex == MMI_EOF)
					{
						startLinkInd = 0;
					}
					else
					{
						startLinkInd = linkIndex;
					}
					do
					{
						if(MMI_DRV_SetAudioDeviceByLink((U8)(startLinkInd%MAX_MULTI_POINT_NO), MMI_DRV_GetAudioDevByPriority(i)))
							goto NEW_ACTIVE_AUDIO_DEV;

						linkCnt++;
						startLinkInd++;
					}while(linkCnt < MAX_MULTI_POINT_NO);
					break;

				case AUDIO_DEVICE_MUSIC:
				case AUDIO_DEVICE_MUSIC_CALL_NOTIFY:
				case AUDIO_DEVICE_AVRCP_PLAY:
					if(linkIndex == MMI_EOF)
					{
						startLinkInd = 0;
					}
					else
					{
						startLinkInd = linkIndex;
					}
					do
					{
						if(MMI_DRV_SetAudioDeviceMusicResume((U8)(startLinkInd%MAX_MULTI_POINT_NO), MMI_DRV_GetAudioDevByPriority(i)))
							goto NEW_ACTIVE_AUDIO_DEV;
						linkCnt++;
						startLinkInd++;
					}while(linkCnt < MAX_MULTI_POINT_NO);
					break;
				case AUDIO_DEVICE_LINE_IN:
					if(MMI_DRV_SetAudioDeviceSys(AUDIO_DEVICE_LINE_IN, MMI_DRV_ResumeTimer(AUDIO_DEVICE_LINE_IN)))
						goto NEW_ACTIVE_AUDIO_DEV;
					break;
				case AUDIO_DEVICE_FM:
					if(MMI_DRV_SetAudioDeviceSys(AUDIO_DEVICE_FM, MMI_DRV_ResumeTimer(AUDIO_DEVICE_FM)))
						goto NEW_ACTIVE_AUDIO_DEV;
					break;
				case AUDIO_DEVICE_MIC_TO_SPK:
					if(MMI_DRV_SetAudioDeviceSys(AUDIO_DEVICE_MIC_TO_SPK, MMI_DRV_ResumeTimer(AUDIO_DEVICE_MIC_TO_SPK)))
						goto NEW_ACTIVE_AUDIO_DEV;
					break;
				#ifdef DEMOSOUND
				case AUDIO_DEVICE_DEMO_SOUND:
					if(MMI_DRV_SetAudioDeviceSys(AUDIO_DEVICE_DEMO_SOUND, MMI_DRV_ResumeTimer(AUDIO_DEVICE_DEMO_SOUND)))
						goto NEW_ACTIVE_AUDIO_DEV;
					break;
				#endif
			}
		};
	}
	LightDbgPrint("ResumeOtherAudioDevice[%d]:%d",(U8)MMI_EOF, (U8)AUDIO_DEVICE_NONE);
	gMMI_ctl.audioDevCtl.currentActiveDev = AUDIO_DEVICE_NONE;
	gMMI_ctl.audioDevCtl.currentActiveLinkIndex = MMI_EOF;
	SYS_ReleaseTimer(&gMMI_ctl.audioDevCtl.resumeTimer);


	NEW_ACTIVE_AUDIO_DEV:
	switch(audioDev)
	{
		case AUDIO_DEVICE_SCO:
		case AUDIO_DEVICE_SCO_IDLE:
		case AUDIO_DEVICE_SCO_HSP:
			if((gMMI_ctl.audioDevCtl.currentActiveLinkIndex == linkIndex) &&
			(gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_SCO || gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_SCO_IDLE || gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_SCO_HSP))
			{
				SYS_ReleaseTimer(&gMMI_ctl.audioDevCtl.resumeTimer);
				//same type of device--> set active directly
			}
			else
			{
				if(MMI_KEY_STATE_POWER_OFF == MMI_GetKeyState())
					MMI_SendDSPCmd(linkIndex, DSP_DISABLE_BY_POWER_OFF);
				else
					MMI_SendDSPCmd(linkIndex, DSP_DISABLED);
			}
			break;
		case AUDIO_DEVICE_KEY_AT_CMD:
		case AUDIO_DEVICE_CALL_STATE:
			break;

		case AUDIO_DEVICE_MUSIC_CALL_NOTIFY:
		case AUDIO_DEVICE_MUSIC:
		case AUDIO_DEVICE_AVRCP_PLAY:
			if((gMMI_ctl.audioDevCtl.currentActiveLinkIndex == linkIndex) &&
			(gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_MUSIC_CALL_NOTIFY || gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_MUSIC || gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_AVRCP_PLAY))
			{
				SYS_ReleaseTimer(&gMMI_ctl.audioDevCtl.resumeTimer);
				//same type of device--> set active directly
			}
			else
			{
				MMI_A2DP_SendCmd(linkIndex, A2DP_MUSIC_DATA_MEMORY_PUT_CMD);
				if(MMI_KEY_STATE_POWER_OFF == MMI_GetKeyState())
				{
					MMI_SendDSPCmd(linkIndex, DSP_DISABLE_BY_POWER_OFF);
				}
				else
				{
					MMI_SendDSPCmd(linkIndex, DSP_DISABLED);
				}
			}
			break;
		case AUDIO_DEVICE_MIC_TO_SPK:
			#ifdef LINEIN_ENABLE
			MMI_DRV_SetMicSoundLevelInA2DP(gMMI_LineIn_ctl.currentsoundLevel);
			MMI_DRV_KeyEventHandler(linkIndex, KEY_MIC_TO_SPK_DISABLE);
			#endif
			break;

	}
}

PRIVATE void MMI_DRV_ResumeCurrentAudio(void)
{
	switch(gMMI_ctl.audioDevCtl.currentActiveDev)
	{
		case AUDIO_DEVICE_SCO:
		case AUDIO_DEVICE_SCO_HSP:
		case AUDIO_DEVICE_SCO_IDLE:
		case AUDIO_DEVICE_KEY_AT_CMD:
		case AUDIO_DEVICE_MUSIC:
		case AUDIO_DEVICE_MUSIC_CALL_NOTIFY:
		case AUDIO_DEVICE_CALL_STATE:
		case AUDIO_DEVICE_AVRCP_PLAY:
			MMI_DRV_SetAudioDeviceByLink(gMMI_ctl.audioDevCtl.currentActiveLinkIndex, gMMI_ctl.audioDevCtl.currentActiveDev);
			break;

		case AUDIO_DEVICE_LINE_IN:
		case AUDIO_DEVICE_FM:
		#ifdef DEMOSOUND
		case AUDIO_DEVICE_DEMO_SOUND:
		#endif
		case AUDIO_DEVICE_MIC_TO_SPK:
			MMI_DRV_SetAudioDeviceSys(gMMI_ctl.audioDevCtl.currentActiveDev, MMI_DRV_ResumeTimer(gMMI_ctl.audioDevCtl.currentActiveDev));
			break;
	}

	if(gMMI_ctl.isAudioTransparencyEnable)
	{
		gMMI_ctl.isAudioTransparencyEnable = FALSE;
		MMI_DRV_Switch_AudioTransparency(TRUE);
	}
}

PUBLIC BOOL MMI_DRV_IsAudioActiveDev(U8 linkIndex, U8 audioDev)
{
	return(gMMI_ctl.audioDevCtl.currentActiveLinkIndex == linkIndex && gMMI_ctl.audioDevCtl.currentActiveDev == audioDev)? TRUE:FALSE;
}

PUBLIC BOOL MMI_DRV_IsActiveAudioDevInCall(void)
{
	switch(gMMI_ctl.audioDevCtl.currentActiveDev)
	{
		case AUDIO_DEVICE_SCO:
		case AUDIO_DEVICE_SCO_HSP:
		case AUDIO_DEVICE_SCO_IDLE:
		case AUDIO_DEVICE_CALL_STATE:
		case AUDIO_DEVICE_MUSIC_CALL_NOTIFY:
			return TRUE;
		default:
			return FALSE;
	}
}

PUBLIC BOOL MMI_DRV_IsActiveAudioDevInMusic(void)
{
	switch(gMMI_ctl.audioDevCtl.currentActiveDev)
	{
		case AUDIO_DEVICE_MUSIC:
		case AUDIO_DEVICE_AVRCP_PLAY:
			return TRUE;
		default:
			return FALSE;
	}
}

PUBLIC BOOL MMI_DRV_IsActiveAudioDevInFM(void)
{
	return (gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_FM) ? TRUE : FALSE;
}

PUBLIC BOOL MMI_DRV_IsActiveAudioDevInAUX(void)
{
	return (gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_LINE_IN) ? TRUE : FALSE;
}

PUBLIC void MMI_DRV_DSPRefGainCmd(void)
{
	MMIMsgType XDATA_PTR msgPtr;

	msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_GET_DSP_REF_GAIN_CMD);

	if (msgPtr != (MMIMsgType XDATA_PTR)NULL)
	{
	  OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
	}
}

PUBLIC void MMI_DRV_EnterMPStateCmd(void)
{
	U8 state;

	MMI_AddTopState(MMI_EOF, MMI_MP_STATE);
	state = MMI_GetTopStateByLink(DEFAULT_LINK_IND);

	if (state == MMI_MP_STATE)
		MMI_HCI_SendToolCommandResponse(HCI_VCMD_OCF_TOOL_ENTER_MP_STATE, HCI_VEVT_OCF_RESULT_CODE_SUCCESS);
	else
		MMI_HCI_SendToolCommandResponse(HCI_VCMD_OCF_TOOL_ENTER_MP_STATE, HCI_VEVT_OCF_RESULT_CODE_FAIL);

}

extern DRIVER_TEMP_CTL_TYPE XDATA gDriver_Bat_Temp_ctl;
PUBLIC void MMI_DRV_NTCValueReport(void)
{
	MMIMsgType XDATA_PTR msgPtr;

	if(!pMpParameterF->ntcRatioPara.enableNTCRatio)
		MMI_HCI_SendToolCommandResponse(HCI_VCMD_OCF_TOOL_NTC_RATIO_VALUE_REPORT, HCI_VEVT_OCF_RESULT_CODE_FAIL);
	else
	{
		if (msgPtr=MMI_GetCommandMessageMem(HCI_VCMD_AIROHA_TO_UART) )
		{
			msgPtr->paraLen=sizeof(HCI_VCMD_OPCODE_STRU)+sizeof(HCI_VCMD_PARA_NTC_VALUE_DATA);
			msgPtr->msgBodyPtr.hciVCmd.VOpCode.VCmdOcf = HCI_VCMD_OCF_TOOL_NTC_RATIO_VALUE_REPORT;
			msgPtr->msgBodyPtr.hciVCmd.VOpCode.VCmdOgf = HCI_VENDOR_OGF_UART_TOOL_CMD;
			msgPtr->msgBodyPtr.hciVCmd.VPara.respNTCValueData.result = HCI_VEVT_OCF_RESULT_CODE_SUCCESS;
			msgPtr->msgBodyPtr.hciVCmd.VPara.respNTCValueData.signTempADCBiggerValue= gDriver_Bat_Temp_ctl.signTempADCValue;
			msgPtr->msgBodyPtr.hciVCmd.VPara.respNTCValueData.signTempADCSmallerValue= gDriver_Bat_Temp_ctl.signTempADCValue2;
			#if (defined AB1520C) || (defined AB1520D)
			msgPtr->msgBodyPtr.hciVCmd.VPara.respNTCValueData.signTempADCGroundValue=gDriver_Bat_Temp_ctl.signTempADCGroundValue;
			#elif defined(AB1520S)
			msgPtr->msgBodyPtr.hciVCmd.VPara.respNTCValueData.signTempADCGroundValue = 0;
			#endif
			msgPtr->msgBodyPtr.hciVCmd.VPara.respNTCValueData.ratioValue= gDriver_Bat_Temp_ctl.ratioValue;

			MMI_HCI_SendCmd(msgPtr);
		}
	}
}

PUBLIC void MMI_DRV_ToolSetVolGain(HCI_VCMD_PARA_AIR_CMD_GET_VOL_GET XDATA_PTR msgPtr)
{
	U8 spkGainSetIndex, micGainSetIndex;

	if (msgPtr->component == MMI_AUDIO_COMPONENT_SCO)
	{
		if(gMMI_ctl.audioableSCOLink != MMI_EOF)
		{
			MMI_DRV_SetSCOVolValue(gMMI_ctl.audioableSCOLink, msgPtr->soundLevel, msgPtr->smallStepLevel);
		}
		spkGainSetIndex = GET_LINEIN_SPK_GAIN_BY_LEVEL(msgPtr->soundLevel);
		micGainSetIndex = GET_LINEIN_MIC_GAIN_BY_LEVEL(msgPtr->soundLevel);

		if(msgPtr->bandwidth == MMI_AUDIO_WIDE_BAND)
		{
			MMI_SPK_GAINSET_SCOWB[spkGainSetIndex].digitalGainWB	= msgPtr->spkDigitalGain;
			MMI_SPK_GAINSET_SCOWB[spkGainSetIndex].analogGainWB		= msgPtr->spkAnalogGain;
			MMI_MIC_GAINSET_SCOWB[micGainSetIndex].digitalGainWB	= msgPtr->micDigitalGain;
			MMI_MIC_GAINSET_SCOWB[micGainSetIndex].analogGainWB_R	= msgPtr->micAnalogGainR;
			MMI_MIC_GAINSET_SCOWB[micGainSetIndex].analogGainWB_L	= msgPtr->micAnalogGainL;

			if(gMMI_ctl.audioableSCOLink != MMI_EOF && gMMI_ctl.mmiInfo[gMMI_ctl.audioableSCOLink].linkPara.scoCodecType == SCO_CODEC_MSBC)
			{
				MMI_DRV_SendDriverVolCmd(gMMI_ctl.audioableSCOLink, msgPtr->soundLevel, msgPtr->smallStepLevel, micGainSetIndex); //Notify Driver
			}
		}
		else
		{
			MMI_SPK_GAINSET[spkGainSetIndex].digitalGain	= msgPtr->spkDigitalGain;
			MMI_SPK_GAINSET[spkGainSetIndex].analogGain		= msgPtr->spkAnalogGain;
			MMI_MIC_GAINSET[micGainSetIndex].digitalGain	= msgPtr->micDigitalGain;
			MMI_MIC_GAINSET[micGainSetIndex].analogGain_R	= msgPtr->micAnalogGainR;
			MMI_MIC_GAINSET[micGainSetIndex].analogGain_L	= msgPtr->micAnalogGainL;

			if(gMMI_ctl.audioableSCOLink != MMI_EOF && gMMI_ctl.mmiInfo[gMMI_ctl.audioableSCOLink].linkPara.scoCodecType != SCO_CODEC_MSBC)
			{
				MMI_DRV_SendDriverVolCmd(gMMI_ctl.audioableSCOLink, msgPtr->soundLevel, msgPtr->smallStepLevel, micGainSetIndex); //Notify Driver
			}
		}
	}
	#ifdef LINEIN_ENABLE
	else if (msgPtr->component == MMI_AUDIO_COMPONENT_LINE_IN)
	{
		MMI_LineIn_SetVolByLevel(msgPtr->soundLevel, msgPtr->smallStepLevel);

		if(msgPtr->soundLevel)
		{
			U8 soundLevel = msgPtr->soundLevel - 1;

			spkGainSetIndex = GET_LINEIN_SPK_GAIN_BY_LEVEL(soundLevel);
			micGainSetIndex = GET_LINEIN_MIC_GAIN_BY_LEVEL(soundLevel);

			MMI_SPK_GAINSET[spkGainSetIndex].digitalGainL	= msgPtr->spkDigitalGain;
			MMI_SPK_GAINSET[spkGainSetIndex].analogGainL	= msgPtr->spkAnalogGain;
			MMI_MIC_GAINSET[micGainSetIndex].digitalGainL	= msgPtr->micDigitalGain;
			MMI_MIC_GAINSET[micGainSetIndex].analogGainL_R	= msgPtr->micAnalogGainR;
			MMI_MIC_GAINSET[micGainSetIndex].analogGainL_L	= msgPtr->micAnalogGainL;
		}
		MMI_LineIn_SendDriverVolCmd();
	}
	#endif
	#ifdef A2DP_Profile
	else if (msgPtr->component == MMI_AUDIO_COMPONENT_A2DP)
	{
		if(gMMI_ctl.audioableA2DPLink != MMI_EOF)
		{
			MMI_A2DP_SetVolByLevel(gMMI_ctl.audioableA2DPLink, msgPtr->soundLevel, msgPtr->smallStepLevel);
		}

		if(msgPtr->soundLevel)
		{
			U8 soundLevel = msgPtr->soundLevel - 1;

			spkGainSetIndex = GET_A2DP_SPK_GAIN_BY_LEVEL(soundLevel);
			micGainSetIndex = GET_A2DP_MIC_GAIN_BY_LEVEL(soundLevel);

			MMI_SPK_GAINSET[spkGainSetIndex].digitalGainA	= msgPtr->spkDigitalGain;
			MMI_SPK_GAINSET[spkGainSetIndex].analogGainA	= msgPtr->spkAnalogGain;
			MMI_MIC_GAINSET[micGainSetIndex].digitalGainA	= msgPtr->micDigitalGain;
			MMI_MIC_GAINSET[micGainSetIndex].analogGainA_R	= msgPtr->micAnalogGainR;
			MMI_MIC_GAINSET[micGainSetIndex].analogGainA_L	= msgPtr->micAnalogGainL;
		}

		MMI_A2DP_SendDriverVolCmd(msgPtr->soundLevel, msgPtr->smallStepLevel);
	}
	#endif
}

PRIVATE void MMI_DRV_SetVolPtr(HCI_VCMD_PARA_AIR_CMD_SET_CURR_GAIN XDATA_PTR msgPtr, DriverVolumeSetCmd XDATA_PTR volPtr)
{
	volPtr->soundLevel		= VOLUME_DONT_CARE;
	volPtr->spkVols			= msgPtr->spkDigitalGain;
	volPtr->micVols			= msgPtr->micDigitalGain;
	volPtr->analogDaGain	= msgPtr->spkAnalogGain;
	volPtr->analogAdGain_R	= msgPtr->micAnalogGainR;
	volPtr->analogAdGain_L	= msgPtr->micAnalogGainL;
	volPtr->smallStepLevel	= VOLUME_DONT_CARE;
}

PUBLIC void MMI_DRV_ToolSetCurrentGain(HCI_VCMD_PARA_AIR_CMD_SET_CURR_GAIN XDATA_PTR msgPtr)
{
	switch(gMMI_ctl.audioDevCtl.currentActiveDev)
	{
		case AUDIO_DEVICE_SCO:
		case AUDIO_DEVICE_SCO_HSP:
		case AUDIO_DEVICE_SCO_IDLE:
			{
				MMIMsgType XDATA_PTR setVolPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_VOLUME_SET_CMD);
				if(setVolPtr != (MMIMsgType XDATA_PTR)NULL)
				{
					MMI_DRV_SetVolPtr(msgPtr, &setVolPtr->msgBodyPtr.driverCmd.volSetCmd);
					OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)setVolPtr);
				}
			}
			break;

		case AUDIO_DEVICE_MUSIC:
		case AUDIO_DEVICE_AVRCP_PLAY:
			{
				MMIMsgType XDATA_PTR setVolPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_A2DP_VOLUME_SET_CMD);
				if(setVolPtr != (MMIMsgType XDATA_PTR)NULL)
				{
					MMI_DRV_SetVolPtr(msgPtr, &setVolPtr->msgBodyPtr.driverCmd.a2dpVolSetCmd);
					OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)setVolPtr);
				}
			}
			break;

		case AUDIO_DEVICE_LINE_IN:
		case AUDIO_DEVICE_MIC_TO_SPK:
			{
				MMIMsgType XDATA_PTR setVolPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_LINE_IN_VOLUME_SET_CMD);
				if(setVolPtr != (MMIMsgType XDATA_PTR)NULL)
				{
					MMI_DRV_SetVolPtr(msgPtr, &setVolPtr->msgBodyPtr.driverCmd.lineInVolSetCmd);
					OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)setVolPtr);
				}
			}
			break;

		case AUDIO_DEVICE_FM:
		case AUDIO_DEVICE_NONE:
		case AUDIO_DEVICE_MUSIC_CALL_NOTIFY:
		case AUDIO_DEVICE_KEY_AT_CMD:
		case AUDIO_DEVICE_DEMO_SOUND:
		case AUDIO_DEVICE_CALL_STATE:
			break;
	}
}

#ifdef SUPPORT_MIC_IN_A2DP_MODE
PRIVATE void MMI_DRV_MicSpkActionInA2DPMode(U8 linkIndex, BOOL isEnable, BOOL isMicVolSyncSounLevel)
{
	gMMI_ctl.isVolumeSetInitInA2DP = TRUE;
	gMMI_ctl.isMicEnableInA2DP = isEnable;

	if(isMicVolSyncSounLevel)
	{
		CURRENT_MIC_SOUND_LEVEL_IN_A2DP(linkIndex) = CURRENT_A2DP_SOUND_LEVEL(linkIndex);
	}
}

PRIVATE void MMI_DRV_ControlMicInA2DPMode(U8 linkIndex)
{
	MMI_DRV_MicSpkActionInA2DPMode(linkIndex, (gMMI_ctl.isMicEnableInA2DP)? FALSE:TRUE, TRUE);
}


PRIVATE void MMI_DRV_KeyAudioTransparency(U8 linkIndex)
{
	#ifdef AIR_MODULE
	U8 airlink;
	if((airlink = MMI_AIR_GetAirLink(PRODUCT_AIR_TWS)) != MMI_EOF)
	{
		#ifndef TWS_SETTINGS
		if(A2DP_IsLinkFollower(airlink))
			return;

		if(A2DP_IsLinkRelayer(airlink))
		#endif
		{
			#ifdef AVRCP_Profile
			MMI_AVRCP_SendVendorUnique(airlink, AVRCP_VENDOR_UNIQ_SYNC_AND_SWITCH_AUDIO_TRANSPARENCY, (gMMI_ctl.isAudioTransparencyEnable)? FALSE:TRUE);
			#endif
		}
	}
	#endif
	if(!gMMI_ctl.isAudioTransparencyEnable)
	{
		if(gMMI_ctl.mmiTimerInfo.sysTimer.waitATTriggerMediaTimer == (OST XDATA_PTR) NULL)
			SYS_SetTimer(&gMMI_ctl.mmiTimerInfo.sysTimer.waitATTriggerMediaTimer,(U32) 640L);
		MMI_PushMediaEvent(MEDIA_EVT_KEY_AUDIO_TRANSPARENCY);
	}
	else
	{
		MMI_DRV_Switch_AudioTransparency((gMMI_ctl.isAudioTransparencyEnable)? FALSE:TRUE);
		MMI_PushMediaEvent(MEDIA_EVT_KEY_AUDIO_TRANSPARENCY);
	}
	UNUSED(linkIndex);
}

PUBLIC void MMI_DRV_Switch_AudioTransparency(BOOL isEnable)
{
	MMIMsgType XDATA_PTR msgPtr;
	if(gMMI_ctl.isAudioTransparencyEnable == isEnable)
		return;

	if((msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_AUDIO_TRANSPARENCY_CMD)) != (MMIMsgType XDATA_PTR)NULL)
	{
		MMI_LineIn_SendDriverVolCmd();

		gMMI_ctl.isAudioTransparencyEnable = isEnable;
		LightDbgPrint("MMI Audio Transparency:%d",(U8) gMMI_ctl.isAudioTransparencyEnable);
		msgPtr->msgBodyPtr.driverCmd.audioTransparencyCmd.isEnable = isEnable;
		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
	}
}

PUBLIC BOOL MMI_GetAudioTransparencyEnable(void)
{
	return gMMI_ctl.isAudioTransparencyEnable ? TRUE : FALSE;
}
#endif

PRIVATE void MMI_DRV_KeyRoleChange(U8 linkIndex)
{
	#ifdef AIR_MODULE
	MMI_AIR_KeyRoleChange(linkIndex);
	#else
	UNUSED(linkIndex);
	#endif
}

PUBLIC void MMI_DRV_ResumeDSP(U8 reason)
{
	DRIVER_Cmd_ClearSuspendDSPReason(reason);
	if(!DRIVER_Query_IsDSPSuspending())
		MMI_DRV_ResumeCurrentAudio();
}

PUBLIC void MMI_DRV_SuspendDSP(U8 reason, VFUN callback)
{
	if(gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_MUSIC || gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_MUSIC_CALL_NOTIFY || gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_AVRCP_PLAY)
	{
		MMI_A2DP_StopDSP(gMMI_ctl.audioDevCtl.currentActiveLinkIndex);
	}
	else if (gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_LINE_IN)
	{
		MMI_RmvState(MMI_EOF, MMI_LINE_IN);
	}
	#ifdef DEMOSOUND
	else if(gMMI_ctl.audioDevCtl.currentActiveDev == AUDIO_DEVICE_DEMO_SOUND)
	{
		MMI_A2DP_DemoSoundStopCmd();
	}
	#endif

	DRIVER_Cmd_SuspendDSP(reason, callback);
}

PUBLIC void MMI_DRV_ADCRealTimeReading(U8 channel)
{
	S16 ADCValue;

	ADCValue = DRIVER_TEMP_ADCDataReport();
	MMI_HCI_SendToolCommandResponseWithData(HCI_VCMD_OCF_TOOL_GET_ADC_DATA, HCI_VEVT_OCF_RESULT_CODE_SUCCESS, ADCValue);
	UNUSED(channel);
}

PUBLIC U8 MMI_DRV_GetAudioInMusicLink(void)
{
	return gMMI_ctl.audioableA2DPLink;
}



PUBLIC U8 MMI_DRV_WriteFlashAfterRingtoneVPStopped(void)
{

	if((MMI_NEEDS_TO_UPDATE_NVRAM()) && !gSYS_update_by_uart_flash_command && MMI_POWER_DROP_SAVE_LINK_HISTORY_FEAT)
	{
		#ifdef AIR_MODULE
		if(MMI_AIR_PreProcessForWriteFlashAfterRingVP())
		{
			return PENDING_TO_WRITE_FLASH;
		}
		else
		#endif
		{
			return DIRECTLY_WRITE_FLASH;
		}
	}
	return NO_FLASH_WRITTEN_NEEDED;
}

PUBLIC U8 MMI_DRV_SwitchScoToLink(U8 linkIndex)
{
	if(gMMI_ctl.driverCtl.audioSwitchState == MMI_AUDIO_SWITCH_WAITING_HCI_EVT)
		return AUDIO_SWITCH_RESULT_PENDING;

	if((linkIndex < MAX_MULTI_POINT_NO) && (gMMI_ctl.driverCtl.audioSwitchHandler != gMMI_ctl.mmiInfo[linkIndex].linkPara.scoConnHandle))
	{
		switch(gMMI_ctl.driverCtl.audioSwitchState)
		{
			case MMI_AUDIO_SWITCH_ILDE:
				if(MMI_HCI_SendVCmdAudioSwitch(linkIndex))
				{
					gMMI_ctl.driverCtl.audioSwitchState = MMI_AUDIO_SWITCH_WAITING_HCI_EVT;
					return AUDIO_SWITCH_RESULT_PENDING;
				}
				return AUDIO_SWITCH_RESULT_FAIL;
			case MMI_AUDIO_SWITCH_WAITING_HCI_EVT:
				return AUDIO_SWITCH_RESULT_PENDING;

			case MMI_AUDIO_SWITCH_ERROR:
			default:
				gMMI_ctl.driverCtl.audioSwitchState = MMI_AUDIO_SWITCH_ILDE;
				return AUDIO_SWITCH_RESULT_FAIL;
		}
	}
	return AUDIO_SWITCH_RESULT_OK;
}

PUBLIC void MMI_DRV_SetAudioSwitchState(U8 state)
{
	gMMI_ctl.driverCtl.audioSwitchState = state;
}

PUBLIC U8 MMI_DRV_GetAudioSwitchState(void)
{
	return gMMI_ctl.driverCtl.audioSwitchState;
}

PUBLIC BOOL MMI_DRV_IsScoInCVSD(U8 linkIndex)
{
	return (gMMI_ctl.mmiInfo[linkIndex].linkPara.scoCodecType == SCO_CODEC_CVSD) ? TRUE : FALSE;
}

PUBLIC void MMI_DRV_EnableVoicePrompt(void)
{
	gMMI_driver_variation_nvram.misc_para.init.isMiscEnabled &= ~IS_VP_DISABLED;
	gMMI_DRV_ctl.isMiscEnabled &= ~IS_VP_DISABLED;
	MMI_SECTOR_SetUpdateFlag(TRUE);
}

PUBLIC void MMI_DRV_DisableVoicePrompt(void)
{
	gMMI_driver_variation_nvram.misc_para.init.isMiscEnabled |= IS_VP_DISABLED;
	gMMI_DRV_ctl.isMiscEnabled |= IS_VP_DISABLED;
	MMI_SECTOR_SetUpdateFlag(TRUE);
}

PUBLIC BOOL MMI_DRV_IsVoicePromptEnabled(void)
{
	return (gMMI_DRV_ctl.isMiscEnabled & IS_VP_DISABLED) ? FALSE : TRUE;
}



#ifdef AUDIO_BIST
	#include "MMI_AudioBIST.c"
#endif //AUDIO_BIST

PRIVATE void MMI_DRV_Key2KToneEnable(U8 linkIndex)
{
	#ifdef AUDIO_BIST
	MMI_DRV_AudioBistEnableVoiceCmd(VOICE_2M_L_REPORT_SINGLE_SNP);
	#endif
	UNUSED(linkIndex);
}

PRIVATE void MMI_DRV_Key2KToneDisable(U8 linkIndex)
{
	MMI_StopA2DPOrSCOCmd(linkIndex, FALSE);
}

PUBLIC void MMI_DRV_ScoModeControl(U8 linkIndex, BOOL isECNRDisable, BOOL isLightMono)
{
#if defined SUPPORT_VOICE_COMMAND || defined ECNR_OFF_IN_NORMAL_SCO
	MMIMsgType XDATA_PTR msgPtr;

	#ifdef AIR_MODULE
	if(gMMI_Air_ctl.SCOAudioFSSel == 0xFF)
		return;
	#endif

	if((msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_SCO_MODE_CONTROL_CMD)) != (MMIMsgType XDATA_PTR)NULL)
	{
		MMI_DRV_SetSCOPara(linkIndex, msgPtr);
		#ifdef ECNR_OFF_IN_NORMAL_SCO
		msgPtr->msgBodyPtr.driverCmd.scoCmd.enablePara.scoPara.isECNROn = (isECNRDisable)?FALSE:TRUE;
		#else
		msgPtr->msgBodyPtr.driverCmd.scoCmd.enablePara.scoPara.isECNROn = TRUE;
		UNUSED(isECNRDisable);
		#endif
		#ifdef SUPPORT_VOICE_COMMAND
		msgPtr->msgBodyPtr.driverCmd.scoCmd.enablePara.scoPara.isLightMonoMode = (isLightMono)?TRUE:FALSE;
		#else
		msgPtr->msgBodyPtr.driverCmd.scoCmd.enablePara.scoPara.isLightMonoMode = FALSE;
		UNUSED(isLightMono);
		#endif
		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
	}
#else
	UNUSED(linkIndex);
	UNUSED(isECNRDisable);
	UNUSED(isLightMono);
#endif
}

PUBLIC void MMI_DRV_SendAsyncSCOEnableCmd(U8 linkIndex)
{
	MMIMsgType XDATA_PTR msgPtr;

	if((msgPtr = MMI_GetMMIMsgTypeCmdMemory(DRIVER_ASYNC_SCO_CMD)) != (MMIMsgType XDATA_PTR)NULL)
	{
		msgPtr->msgBodyPtr.driverCmd.scoCmd.linkInd = linkIndex;

		OSMQ_Put(OSMQ_DRIVER_Command_ptr, (U8 XDATA_PTR)msgPtr);
		//#ifdef DBG_UART_ENABLE_MMI
		LightDbgPrint("MMI_SendAsyncSCOEnableCmd:%d", (U8)linkIndex);
		//#endif
	}
}


PUBLIC void MMI_DRV_FlashStartUpdating(void)
{
	if(!DRIVER_Query_IsWaitingDSPSuspend(DRV_SUSPEND_DSP_REASON_FOTA))
	{
		MMI_AddTopState(MMI_EOF, MMI_UPDATING);
		MMI_DRV_SuspendDSP(DRV_SUSPEND_DSP_REASON_FOTA, FAR_NULL);
	}
	gSYS_update_by_uart_flash_command = TRUE;
}

PUBLIC void MMI_DRV_FlashUpdateFail(void)
{
	gSYS_update_by_uart_flash_command = FALSE;
	MMI_DRV_ResumeDSP(DRV_SUSPEND_DSP_REASON_FOTA);
	MMI_AddTopState(MMI_EOF, MMI_UPDATED_FAIL);
	#ifdef AIRAPP_Profile
	AirApp_OTAFail();
	#endif
	SYS_ReleaseTimer(&gMMI_ctl.mmiTimerInfo.sysTimer.waitForOTAPacketTimer);
}

PUBLIC void MMI_DRV_FlashUpdateEnd(void)
{
	gSYS_update_by_uart_flash_command = FALSE;
	MMI_DRV_ResumeDSP(DRV_SUSPEND_DSP_REASON_FOTA);
	MMI_RmvState(MMI_EOF, MMI_UPDATING);
	SYS_ReleaseTimer(&gMMI_ctl.mmiTimerInfo.sysTimer.waitForOTAPacketTimer);
}

PUBLIC void MMI_DRV_GetFlashUpdatePacket(void)
{
	SYS_SetTimer(&gMMI_ctl.mmiTimerInfo.sysTimer.waitForOTAPacketTimer, 5 * ONE_SEC);
}

PUBLIC BOOL MMI_DRV_OTAVoicepromptsExist(void)
{
	BOOL exist;
	exist = MMI_DRV_IsOTAVoicepromptsExisting();
	
	if(AUDIO_COMPONENT_IS_ACTIVE(AUDIO_VOICEPROMPT))
	{
		exist = TRUE;
	}

	if(DRIVER_Query_IsDSPSuspending())
        return FALSE;

	if(DRIVER_GetVoicepromptsNumberInQueue() != 0)
	{
		exist = TRUE;
	}

	return exist;
}

PUBLIC void MMI_DRV_SetOTAVoicepromptsExist(BOOL exist)
{
	gDriver_ctl.OTAVoicepromptsExist = exist;
}

PUBLIC BOOL MMI_DRV_IsOTAVoicepromptsExisting(void)
{
	return gDriver_ctl.OTAVoicepromptsExist;
}

#ifdef AIRAPP_Profile
PUBLIC BOOL MMI_DRV_IsDSPLockedByOTA(void)
{
	return AirApp_IsDSPLockedByOTA();
}
#endif